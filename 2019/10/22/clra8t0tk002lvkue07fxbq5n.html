<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nn.png">
  <link rel="icon" type="image/png" href="/img/nn.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="新四青年 的技术分享">
  <meta name="author" content="wwhai">
  <meta name="keywords" content="">
  <title>ErlangCowboy基础教程 - 新四青年</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 40vh;">

  <!-- 顶部提示 -->
  <div class="alert alert-warning" role="alert"
    style="margin-top: 70px; background-color: black;color: rgb(156, 255, 25);text-align: center;padding: 0 0 0 0;">
    <strong>提示：本站一些文章的超时空时间是乱写的，主要是为了排序，并不是真实写作时间。</strong>
  </div>

    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar" style="background-color: #000000;">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>新四青年</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/openlab/academic.html">
                
                FreeOpenLab
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/things/">
                
                作品
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://space.bilibili.com/14649762">
                
                Bilibili
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>

</nav>


    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-10-22 11:04">
      October 22, 2019 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      148
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" style="border: 0px;outline: 1px solid rgb(204,204,204);" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：June 30, 2023 pm
                
              </p>
            
            <article class="markdown-body">
              <p>本文作者：[wangwenhai] # 概要：本文主要讲解Erlang的Web框架Cowboy的基础使用</p>
<span id="more"></span>

<h2 id="1-Cowboy简介"><a href="#1-Cowboy简介" class="headerlink" title="1.Cowboy简介"></a>1.Cowboy简介</h2><p>Cowboy是Erlang的一个Web 服务器框架，比较精简，适合嵌入式WEB服务器系统开发，目前Cowboy在Erlang世界用的比较多，但是中文资料确实不多。为了方便学习，本人将Cowboy官网的文档来做一个简短的解读，方便新手学习，因为本人能力有限，如有错误请联系指出。</p>
<blockquote>
<p>Cowboy关注于构建HTTP服务器，而非基于HTTP的业务系统。所以Cowboy讲的东西大部分比较底层，甚至晦涩，需要我们读者有扎实的HTTP基础。</p>
</blockquote>
<h2 id="2-Cowboy安装"><a href="#2-Cowboy安装" class="headerlink" title="2.Cowboy安装"></a>2.Cowboy安装</h2><h3 id="2-1-Makefile形式"><a href="#2-1-Makefile形式" class="headerlink" title="2.1 Makefile形式"></a>2.1 Makefile形式</h3><ol>
<li>首先，新一个目录,用来存放我们的应用:</li>
</ol>
<pre><code class="hljs erlang">mkdir hello_erlang
cd hello_erlang
wget https://erlang.mk/erlang.mk
make -f erlang.mk bootstrap bootstrap-rel
make run
...
(hello_erlang@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>)<span class="hljs-number">1</span>&gt;</code></pre>
<p>输入<code>i()</code>命令可查看正在运行的进程数据。以上步骤没有做任何事，仅仅是启动了一个节点。</p>
<ol start="2">
<li><p>接下来配置Cowboy,打开Makefile:</p>
<pre><code class="hljs shell">PROJECT = hello_erlang
DEPS = cowboy
dep_cowboy_commit = 2.7.0
DEP_PLUGINS = cowboy
include erlang.mk</code></pre>
</li>
<li><p>执行make run,Cowboy就会被编译进你的项目里面。</p>
</li>
</ol>
<h3 id="2-2-Rebar构建。"><a href="#2-2-Rebar构建。" class="headerlink" title="2.2 Rebar构建。"></a>2.2 Rebar构建。</h3><p>Rebar是Erlang的构建工具，类似于Maven和NPM，目前最新版是Rebar3，本教程就按照Rebar3的形式进行演示。</p>
<ol>
<li><p>新建项目 </p>
<pre><code class="hljs shell">mkdir demo
cd demo
rebar3 new release demo</code></pre>
<p>此时Rebar3会帮我们自动化创建项目结构</p>
<pre><code class="hljs awk">===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo_app.erl
===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo_sup.erl
===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo.app.src
===&gt; Writing demo/rebar.config
===&gt; Writing demo<span class="hljs-regexp">/config/</span>sys.config
===&gt; Writing demo<span class="hljs-regexp">/config/</span>vm.args
===&gt; Writing demo/.gitignore
===&gt; Writing demo/LICENSE
===&gt; Writing demo/README.md</code></pre>
</li>
<li><p>加入Cowboy依赖<br>我们打开rebar.config,加入Cowboy的依赖<code>&#123;cowboy, &quot;2.6.3&quot;, &#123;git, &quot;git://github.com/ninenines/cowboy.git&quot;, &#123;tag, &quot;2.6.3&quot;&#125;&#125;&#125;</code>,版本请自行选择。</p>
</li>
</ol>
<pre><code class="hljs erlang">&#123;erl_opts, [debug_info]&#125;.
&#123;deps, [
  &#123;cowboy, <span class="hljs-string">&quot;2.6.3&quot;</span>, &#123;git, <span class="hljs-string">&quot;git://github.com/ninenines/cowboy.git&quot;</span>, &#123;tag, <span class="hljs-string">&quot;2.6.3&quot;</span>&#125;&#125;&#125;,
]&#125;.

&#123;relx, [&#123;release, &#123;demo, <span class="hljs-string">&quot;0.1.0&quot;</span>&#125;,
  [trap,
    stdlib,
    sasl]&#125;,

  &#123;sys_config, <span class="hljs-string">&quot;./config/sys.config&quot;</span>&#125;,
  &#123;vm_args, <span class="hljs-string">&quot;./config/vm.args&quot;</span>&#125;,

  &#123;dev_mode, true&#125;,
  &#123;include_erts, false&#125;,

  &#123;extended_start_script, true&#125;]
&#125;.

&#123;profiles, [&#123;prod, [&#123;relx, [&#123;dev_mode, false&#125;,
  &#123;include_erts, true&#125;]&#125;]
&#125;]
&#125;.
</code></pre>

<ol start="3">
<li>编译<pre><code class="hljs gauss">rebar3 <span class="hljs-keyword">compile</span></code></pre>

</li>
</ol>
<h2 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3.运行测试"></a>3.运行测试</h2><p>上述流程完成以后，我们接下来测试一下Cowboy是否可以运行。找到项目下的app.erl,然后添加以下代码:</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>
    Dispatch = cowboy_router:compile([
        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;
    ]),
    &#123;ok, _&#125; = cowboy:start_clear(my_http_listener,
        [&#123;port, <span class="hljs-number">8080</span>&#125;],
        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;
    ),
    demo_app_sup:start_link().</code></pre>
<p>这样我们就启动了一个监听器，接下来我们再新建一个handler处理器，来处理web请求：</p>
<p>执行命令:<code>make new t=cowboy.http n=hello_handler</code>，或者手动新建一个hello_handler.erl文件，加入代码：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>
    Req = cowboy_req:reply(<span class="hljs-number">200</span>,
        #&#123;&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;&#125;,
        &lt;&lt;<span class="hljs-string">&quot;Hello Erlang!&quot;</span>&gt;&gt;,
        Req0),
    &#123;ok, Req, State&#125;.</code></pre>
<p>此时我们重新运行：<code>rebar3 shell</code>命令，即可进行调试，没有错误信息以后，浏览器打开<code>http://localhost:8080</code>,即可测试。</p>
<h2 id="4-Listeners：端口监听器"><a href="#4-Listeners：端口监听器" class="headerlink" title="4.Listeners：端口监听器"></a>4.Listeners：端口监听器</h2><p>本质上来说，端口监听器其实还是一个Socket处理器，负责客户端的连接处理，类似于Tomcat的Connector。<br>下面我们分别启动一个最简单的HTTP服务器和HTTPS服务器。</p>
<h3 id="4-1-HTTP服务器"><a href="#4-1-HTTP服务器" class="headerlink" title="4.1 HTTP服务器"></a>4.1 HTTP服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>
    Dispatch = cowboy_router:compile([
        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;
    ]),
    &#123;ok, _&#125; = cowboy:start_clear(my_http_listener,
        [&#123;port, <span class="hljs-number">8080</span>&#125;],
        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;
    ).
    <span class="hljs-comment">%% 其它代码</span></code></pre>
<p>上面给出的代码启动了一个最简单的HTTP服务器，监听8080端口，项目路径是根目录<code>/</code>。</p>
<h3 id="4-2-HTTPS服务器"><a href="#4-2-HTTPS服务器" class="headerlink" title="4.2 HTTPS服务器"></a>4.2 HTTPS服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>
    Dispatch = cowboy_router:compile([
        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;
    ]),
    &#123;ok, _&#125; = cowboy:start_tls(my_https_listener,
        [
            &#123;port, <span class="hljs-number">8443</span>&#125;,
            &#123;certfile, <span class="hljs-string">&quot;/path/to/certfile&quot;</span>&#125;,
            &#123;keyfile, <span class="hljs-string">&quot;/path/to/keyfile&quot;</span>&#125;
        ],
        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;
    ),
        <span class="hljs-comment">%% 其它代码</span></code></pre>
<p>HTTPS服务器和HTTP不同的是，需要指定HTTPS的真证书路径：</p>
<pre><code class="hljs 1c">&#123;certfile, <span class="hljs-string">&quot;/path/to/certfile&quot;</span>&#125;,
&#123;keyfile, <span class="hljs-string">&quot;/path/to/keyfile&quot;</span>&#125;</code></pre>
<blockquote>
<p>HTTP/1.1和HTTP/2协议共享相同的语义(可以查看HTTP RFC相关定义);只有他们的框架不同。HTTP1.1是文本协议，HTTP1.2是二进制协议。<br>Cowboy没有将HTTP/1.1和HTTP/2的配置分开。所有东西都在同一个Map上,配置选项是共享的。</p>
</blockquote>
<h3 id="4-3-代码简要分析"><a href="#4-3-代码简要分析" class="headerlink" title="4.3 代码简要分析"></a>4.3 代码简要分析</h3><p> <code>cowboy_router:compile</code>用来构建路由，cowboy:start_XXX用来启动具体的服务器。</p>
<h3 id="4-4-停止服务器"><a href="#4-4-停止服务器" class="headerlink" title="4.4 停止服务器"></a>4.4 停止服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">(_State)</span> -&gt;</span>
    ok = cowboy:stop_listener(my_http_listener).</code></pre>

<h2 id="5-Routing：路由"><a href="#5-Routing：路由" class="headerlink" title="5.Routing：路由"></a>5.Routing：路由</h2><p>如果你学过JavaEE，或许还记得Java的servlet的路由定义形式：首先定义一个类继承HttpServlet，然后重写Get或者Post方法，最后注册到容器里面。其实这就是web框架通用的一种做法，将一个执行模块提取出来，注册到一个路由下面，然后交给容器去调度。下面我们看一下Cowboy的路由，你会发现其实和JavaEE，Python的Django等框架类似，比较容易理解。</p>
<h3 id="5-1-配置规则"><a href="#5-1-配置规则" class="headerlink" title="5.1 配置规则"></a>5.1 配置规则</h3><p>路由的一般结构定义如下：</p>
<pre><code class="hljs erlang">Routes = [Host1, Host2, ... HostN].</code></pre>


<p>分别给Host配置不同的规则:</p>
<pre><code class="hljs erlang">Host1 = &#123;HostMatch, PathsList&#125;.
Host2 = &#123;HostMatch, Constraints, PathsList&#125;.</code></pre>

<p>配置路由表：</p>
<pre><code class="hljs erlang">PathsList = [Path1, Path2, ... PathN].
</code></pre>

<p>路由模式匹配：</p>
<pre><code class="hljs erlang">Path1 = &#123;PathMatch, Handler, InitialState&#125;.
Path2 = &#123;PathMatch, Constraints, Handler, InitialState&#125;.</code></pre>
<p>匹配规则</p>
<pre><code class="hljs erlang">但级路径匹配：PathMatch1 = <span class="hljs-string">&quot;/&quot;</span>.
多级路径匹配：PathMatch2 = <span class="hljs-string">&quot;/path/to/resource&quot;</span>.
Host匹配：HostMatch1 = <span class="hljs-string">&quot;cowboy.example.org&quot;</span>.</code></pre>

<p>路径参数</p>
<pre><code class="hljs erlang">PathMatch = <span class="hljs-string">&quot;/hats/:name/prices&quot;</span>.
HostMatch = <span class="hljs-string">&quot;:subdomain.example.org&quot;</span>.</code></pre>
<p>其中:name是路径参数，:subdomain是域名参数。举个例子:</p>
<p>匹配域名<code>domain1</code>,name参数<code>name1</code>:</p>
<p>URL:<code>http://domain1.example.org/hats/name1/prices</code></p>
<p>匹配域名<code>domain2</code>,name参数<code>name2</code>:</p>
<p>URL:<code>http://domain2.example.org/hats/name2/prices</code></p>
<p>路径参数可以通过<code>cowboy_req:binding/&#123;2,3&#125;</code>来获取。其中有个特殊的匹配符号就是原子’_’,表示任意匹配。</p>
<p>可选路径参数</p>
<p><code>PathMatch = &quot;/book/[:chapter]/[:page]&quot;.</code>其中chapter，page都是可选字段。</p>
<h3 id="5-2-URL统配符："><a href="#5-2-URL统配符：" class="headerlink" title="5.2 URL统配符：[...]"></a>5.2 URL统配符：<code>[...]</code></h3><pre><code class="hljs erlang">PathMatch = <span class="hljs-string">&quot;/hats/[...]&quot;</span>.
HostMatch = <span class="hljs-string">&quot;[...]ninenines.eu&quot;</span>.</code></pre>

<p><code>[...]</code>通配符可以用来获取匹配剩下的所有URL，例如URL：<code>/a/b/c/e/f........</code>，当配置了<code>/a/[...]</code>以后，匹配到的就是<code>b/c/e/f.......</code>后面的字符串。</p>
<h3 id="5-3-特殊符号："><a href="#5-3-特殊符号：" class="headerlink" title="5.3 特殊符号："></a>5.3 特殊符号：</h3><pre><code class="hljs ini"><span class="hljs-attr">PathMatch1</span> = <span class="hljs-string">&#x27;_&#x27;</span>.
<span class="hljs-attr">HostMatch2</span> = <span class="hljs-string">&#x27;_&#x27;</span>.
<span class="hljs-attr">PathMatch3</span> = <span class="hljs-string">&#x27;*&#x27;</span>.
<span class="hljs-attr">HostMatch4</span> = <span class="hljs-string">&#x27;*&#x27;</span>.</code></pre>
<p><code>&#39;_&#39;</code>匹配所有的URL，<code>&#39;*&#39;</code>是个主机通配符，通常与OPTIONS方法一起使用，用在跨域请求场景下。</p>
<h2 id="6-Constraints：约束条件"><a href="#6-Constraints：约束条件" class="headerlink" title="6.Constraints：约束条件"></a>6.Constraints：约束条件</h2><p>Cowboy这么定义约束条件：匹配完成后，可以根据一组约束对结果绑定进行测试。只有在定义绑定时才测试约束。它们按照你定义的顺序运行。只有他们都成功，匹配才会成功。如果匹配失败，Cowboy将尝试列表中的下一条路由。约束使用的格式与cowboy_req中的匹配函数相同:它们作为可能有一个或多个约束的字段列表提供。虽然路由接受相同的格式，但它会跳过没有约束的字段，如果有默认值，也会忽略。</p>
<p>乍一看这个定义让人头大，如果你学过JavaWEB，肯定对值过滤比较熟悉，没错Cowboy的Constraints就是用来过滤合法值的。比如用户登陆的时候，判断email的合法性或者手机号码的合法性等等。SpringMVC里面叫验证器：Validator。</p>
<h3 id="6-1-约束条件规范"><a href="#6-1-约束条件规范" class="headerlink" title="6.1 约束条件规范"></a>6.1 约束条件规范</h3><p>约束条件以字段列表的形式提供。对于列表中的每个字段，可以应用特定的约束条件，如果字段缺失，还可以应用默认值。<br>字段可以是atom、带约束条件的的tuple <code>&#123;field, constraints&#125;</code>或带约束条件的tuple和默认值<code>&#123;field, constraints, default&#125;</code>的形式，其中field是必填的。<br>请注意，当与路由一起使用时，只有第二种形式是有意义的，因为它不使用默认值，并且field总是有值。每个字段的约束条件以原子或函数的有序列表的形式提供。内置约束条件是原子，而自定义约束条件是函数。</p>
<p>以下约束条件将首先验证并将字段my_value转换为整数，然后检查该整数是否为正:</p>
<pre><code class="hljs erlang">PositiveFun = <span class="hljs-keyword">fun</span>
    (_, V) <span class="hljs-keyword">when</span> V &gt; <span class="hljs-number">0</span> -&gt;
        &#123;ok, V&#125;;
    (_, _) -&gt;
        &#123;error, not_positive&#125;
<span class="hljs-keyword">end</span>,
&#123;my_value, [int, PositiveFun]&#125;.</code></pre>
<p>内置约束条件：</p>
<table>
<thead>
<tr>
<th>条件约束</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>将二进制值转换为整数</td>
</tr>
<tr>
<td>nonempty</td>
<td>确保二进制值不为空</td>
</tr>
</tbody></table>
<h3 id="6-2-自定义约束条件"><a href="#6-2-自定义约束条件" class="headerlink" title="6.2 自定义约束条件"></a>6.2 自定义约束条件</h3><p> 自定义约束是一个函数。这个函数有两个参数。第一个参数表示要执行的操作，第二个参数是值。值是什么以及必须返回什么取决于操作。  Cowboy目前定义三个操作。用于验证和转换用户输入的操作是 <code>forward</code> 操作。 </p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(forward, Value)</span> -&gt;</span>
    <span class="hljs-keyword">try</span>
        &#123;ok, binary_to_integer(Value)&#125;
    <span class="hljs-keyword">catch</span> _:_ -&gt;
        &#123;error, not_an_integer&#125;
    <span class="hljs-keyword">end</span>;</code></pre>

<blockquote>
<p>即使没有约束条件，Value也依序被返回。</p>
</blockquote>
<p>  reverse 的操作则相反:它获取一个转换后的值并将其返回回用户输入的值 。其实就是类型转换。</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(reverse, Value)</span> -&gt;</span>
	<span class="hljs-keyword">try</span>
		&#123;ok, integer_to_binary(Value)&#125;
	<span class="hljs-keyword">catch</span> _:_ -&gt;
		&#123;error, not_an_integer&#125;
	<span class="hljs-keyword">end</span>;</code></pre>

<p> 最后，<code>format_error</code>操作接受任何其他操作返回的错误，并返回格式化的可读的错误消息。 主要用来返回条件约束处理错误的信息。</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(format_error, &#123;not_an_integer, Value&#125;)</span> -&gt;</span>
	io_lib:format(<span class="hljs-string">&quot;The value ~p is not an integer.&quot;</span>, [Value]).</code></pre>

<blockquote>
<p> Cowboy不会捕获来自约束函数的异常。它们应该被编写成不抛出任何异常。 </p>
</blockquote>
<h2 id="7-Handlers：请求处理器"><a href="#7-Handlers：请求处理器" class="headerlink" title="7.Handlers：请求处理器"></a>7.Handlers：请求处理器</h2><p>到这部分就容易理解了，其实对应的就是SpringMVC的Controller。学习这一节之前，我们再来回顾一下JavaEE一些旧知识点。</p>
<p>首先我们写一个简单的JavaServlet。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">javax</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">http</span>.<span class="hljs-title">HttpServlet</span></span>&#123;   
    <span class="hljs-meta">@Override</span>    
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
       System.out.println(<span class="hljs-string">&quot;helloWorld&quot;</span>);
        <span class="hljs-keyword">super</span>.doGet(req, resp);  
    &#125;
&#125;</code></pre>

<p>上述代码中我们实现了<code>javax.servlet.http.HttpServlet</code>类，重写了<code>doGet</code>方法。这其实就是一个典型的HTTP处理过程。</p>
<p>接下来我们换到Cowboy，实现一个同样功能的处理器</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(index_handler)</span>.
<span class="hljs-keyword">-author</span><span class="hljs-params">(<span class="hljs-string">&quot;wangwenhai&quot;</span>)</span>.
<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(cowboy_handler)</span>.
<span class="hljs-comment">%% API-export([init/2, terminate/3]).</span>
<span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;&#125;)</span>.

<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>
    Req = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
        &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;
    &#125;, &lt;&lt;<span class="hljs-string">&quot;Hello World!&quot;</span>&gt;&gt;, Req0),
    &#123;ok, Req, State&#125;.

<span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _Req, _State)</span> -&gt;</span>
  ok.
</code></pre>

<p>认真观察一下两处代码的共同之处：</p>
<ol>
<li><p>Java和Cowboy都实现了某个模块，或者类</p>
</li>
<li><p>二者都实现了某个特定的函数</p>
</li>
</ol>
<p>对于Cowboy而言，则是实现了特定的行为模式（行为模式是Erlatng的语法特性，请自行学习相关知识）:<code>-behaviour(cowboy_handler).</code>,然后重写了<code>init</code>和<code>terminate</code>。返回值为：<code>&#123;ok, Reply, State&#125;</code>,Reply通过<code>cowboy_req:reply</code>构建。</p>
<p> 所有处理程序类型都提供可选的<code>terminate/3</code>回调。 需要注意的是，此函数只要调用，表示当前处理器已经被销毁，我们不可以在这里写自己的业务逻辑。</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _Req, _State)</span> -&gt;</span>
    ok.</code></pre>



<h2 id="8-Loop-handlers：循环处理器"><a href="#8-Loop-handlers：循环处理器" class="headerlink" title="8.Loop handlers：循环处理器"></a>8.Loop handlers：循环处理器</h2><p>到目前未知，个人感觉这一节是最陌生的。貌似我在做JavaWeb的时候，压根没听过循环处理器这种说法。我们直接翻译官方的说明看看：</p>
<blockquote>
<p>循环处理程序是一种特殊类型的HTTP处理程序，用于无法立即发送响应。处理程序进入一个接收循环，等待正确的消息，然后才能发送响应。 </p>
<p> 循环处理程序用于这样的请求:响应可能不是立即可用的，但是您希望在响应到达时保持连接打开一段时间。这种实践最著名的例子是长轮询。循环处理程序也可以用于响应部分可用的请求，并且您需要在连接打开时传输响应主体。这种实践最著名的例子是服务器发送的事件，但是它也适用于任何需要很长时间发送的响应。虽然可以使用普通的HTTP处理程序来完成相同的工作，但是建议使用循环处理程序，因为它们经过了良好的测试，并且允许使用内置特性，比如休眠和超时。 </p>
</blockquote>
<p>哪怕是读到这里都感觉头大：我还是不理解这个循环处理器是什么用途？认证想了一下，貌似这种场景我们经常遇到，但是平时的项目开发中却很少见，我也比较新奇。大家设想一下这个场景：我们肯定有使用过一些在线处理图片或者压缩文件的网站，我们压缩比较大的文件的时候，速度会比较慢，比如压缩文件会让我们等待1分钟。这种场景表示的就是耗时操作，而Cowboy把这个叫：循环处理器。</p>
<p>理解了这个场景以后，其实就很容易使用它。循环处理器就是特殊的Handler而已，只不过<code>init/2</code>函数必须返回一个 <code>cowboy_loop</code> 原子，如下所示：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
    &#123;cowboy_loop, Req, State&#125;.</code></pre>

<p>同样我们如果要终止请求，可以使用<code>hibernate</code>:</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
    &#123;cowboy_loop, Req, State, hibernate&#125;.</code></pre>

<p> 初始化后，Cowboy将等待进程消息到达进程邮箱。当消息到达时，Cowboy调用info/3函数 。 下面的代码段在从另一个进程接收到应答消息时发送应答，或者在其他情况下等待另一个消息。 </p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(&#123;reply, Body&#125;, Req, State)</span> -&gt;</span>
    cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;&#125;, Body, Req),
    &#123;stop, Req, State&#125;;
<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(_Msg, Req, State)</span> -&gt;</span>
    &#123;ok, Req, State, hibernate&#125;.</code></pre>

<p> 请注意，这里的应答元组可以是任何消息，它只是一个示例。  此回调可以执行任何必要的操作，包括发送应答的全部或部分，并随后返回一个tuple，该tuple表示是否需要发送更多消息。  回调也可以选择什么都不做，直接跳过接收到的消息。  如果发送了应答，那么应该返回stop元组。这将指定Cowboy结束请求。  否则应该返回一个ok元组 。</p>
<p> 另一个非常适合循环处理程序的常见情况是以Erlang消息的形式接收流式数据。这可以通过在init/2回调中初始化一个 块(chunk)应答，然后在每次接收到消息时使用<code>cowboy_req:chunk/2</code>来实现。 </p>
<p> 从下面的代码片段可以看到，每次接收到事件消息时都会发送一个块(chunk)，而通过发送<code>eof</code>消息来停止循环。 </p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>
    Req2 = cowboy_req:stream_reply(<span class="hljs-number">200</span>, Req),
    &#123;cowboy_loop, Req2, State&#125;.

<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(eof, Req, State)</span> -&gt;</span>
    &#123;stop, Req, State&#125;;
<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(&#123;event, Data&#125;, Req, State)</span> -&gt;</span>
    cowboy_req:stream_body(Data, nofin, Req),
    &#123;ok, Req, State&#125;;
<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(_Msg, Req, State)</span> -&gt;</span>
    &#123;ok, Req, State&#125;.</code></pre>

<p> 为了节省内存，可以在接收到的消息之间休眠进程。这是通过作为循环元组回调的一部分返回原子<code>hibernate来</code>实现的。只要在最后添加一个原子，Cowboy就会相应休眠。 </p>
<p>下面是<code>cowboy_req:stream_reply</code>的定义。 报头名称必须以小写二进制字符串的形式给出。虽然标题名不区分大小写，但Cowboy要求将它们以小写形式给出才能正常工作。 详细请看:<a target="_blank" rel="noopener" href="https://ninenines.eu/docs/en/cowboy/2.7/manual/cowboy_req.stream_reply/">https://ninenines.eu/docs/en/cowboy/2.7/manual/cowboy_req.stream_reply/</a></p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">stream_reply</span><span class="hljs-params">(Status, Req :: cowboy_req:req())</span></span>
<span class="hljs-function">    -&gt;</span> stream_reply(StatusCode, #&#123;&#125;, Req)

stream_reply(Status, Headers, Req :: cowboy_req:req())
    -&gt; Req

Status  :: cowboy:http_status()
Headers :: cowboy:http_headers()</code></pre>

<p>这一节讲的比较晦涩，其实我本人也是对块的概念不熟悉，其他项目的框架不会涉及到这些，因此这里只做了简单的讲解和部分概念直接翻译，后期加深框架了解以后方可更新本章。同时欢迎对本章内容熟悉的朋友提出修改建议。</p>
<h2 id="9-Static-files：静态资源"><a href="#9-Static-files：静态资源" class="headerlink" title="9.Static files：静态资源"></a>9.Static files：静态资源</h2><p>静态资源想必大家都比较熟悉了，常见的静态资源比如模板引擎，配置文件，JS脚本，CSS文件等等。本章主要就是讲解Cowboy如何处理静态文件。</p>
<p>Cowboy附带了一个随时可用的处理程序来提供静态文件。它的提供是为了方便在开发过程中为文件提供服务。对于生产中的系统，请考虑使用市场上提供的众多内容分发网络(CDN)中的一种，因为它们是提供文件的最佳解决方案。</p>
<p>静态处理程序可以为给定目录中的一个文件或所有文件提供服务。可以配置etag生成和mime类型。</p>
<p>可以使用静态处理程序从应用程序的私有目录提供一个特定的文件，当客户端请求<code>/</code>路径时返回一个<code>index.html</code>文件是一个不错的选择，相当于是一个默认页面。静态文件的路径定式应用程序私有的的相对目录。下面的案例将在访问路径<code>/</code>时从应用程序<code>my_app</code>的私有目录读取文件<code>static/index.html</code>。</p>
<h3 id="9-1-相对路径的形式"><a href="#9-1-相对路径的形式" class="headerlink" title="9.1 相对路径的形式:"></a>9.1 相对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;priv_file, my_app, <span class="hljs-string">&quot;static/index.html&quot;</span>&#125;&#125;</code></pre>

<blockquote>
<p>访问 / 路径的时候，返回my_qpp/static/index.html，其中my_app是我们的项目。</p>
</blockquote>
<h3 id="9-2-绝对路径的形式"><a href="#9-2-绝对路径的形式" class="headerlink" title="9.2 绝对路径的形式:"></a>9.2 绝对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;file, <span class="hljs-string">&quot;/var/www/index.html&quot;</span>&#125;&#125;</code></pre>

<blockquote>
<p>访问 / 路径的时候，返回/var/www/index.html，可以任意指定路径。</p>
</blockquote>
<p>注意：<code>priv_file</code>原子和<code>file</code>是不一样的。</p>
<p>以上是最简单的静态文件处理方式，因为就一个index.html文件。接下来我们继续看一下如何以一个目录作为静态资源容器。</p>
<h3 id="9-3-相对路径的形式"><a href="#9-3-相对路径的形式" class="headerlink" title="9.3 相对路径的形式:"></a>9.3 相对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>&#125;&#125;</code></pre>

<blockquote>
<p>访问 / 下某个文件的时候，Cowboy从<code>my_app/static/assets</code>目录中开始查找文件，如果存在就返回，其中my_app是我们的项目。</p>
</blockquote>
<h3 id="9-4-绝对路径的形式"><a href="#9-4-绝对路径的形式" class="headerlink" title="9.4 绝对路径的形式:"></a>9.4 绝对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;dir, <span class="hljs-string">&quot;/var/www/assets&quot;</span>&#125;&#125;</code></pre>

<blockquote>
<p>访问 / 下某个文件的时候，Cowboy从<code>/var/www/assets</code>目录中开始查找文件，如果存在就返回，其中<code>/var/www/assets</code> 是我们的磁盘的绝对路径。</p>
</blockquote>
<p>除此之外，我们还可以自定义MimeType。</p>
<blockquote>
<p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准，说白了也就是文件的媒体类型。浏览器可以根据它来区分文件，然后决定什么内容用什么形式来显示。</p>
</blockquote>
<p>我们可以通过浏览器查看MimeType，按下浏览器界面下的F12：</p>
<p><img src="/uploads/image-20191024142943282.png" srcset="/img/loading.gif" alt="image-20191024142943282"></p>
<p>常见的MimeType：</p>
<p><img src="/uploads/image-20191024141436305.png" srcset="/img/loading.gif" alt="image-20191024141436305"></p>
<p> 默认情况下，Cowboy将通过查看扩展名尝试识别静态文件的mimetype 。 我们可以重写关联静态文件的mimetype的函数。当Cowboy缺少需要处理的mimetype时，或者当希望减少列表以加快查找速度时，它非常有用。您还可以提供一个硬编码的mimetype，它将被无条件地使用。 </p>
<p> Cowboy有两个内置函数。默认函数只处理构建Web应用程序时使用的常见文件类型。另一个函数是一个包含数百个mimetypes的扩展列表，可以满足我们几乎所有需求。当然，我们可以创建自己的函数。 </p>
<p> 要使用默认函数，我们不需要配置任何东西，因为它是默认的。如果你确实需要自定义Mimetype的话，下面的方法就可以了 。</p>
<blockquote>
<p>本段直接翻译官网文档。</p>
</blockquote>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,
    [&#123;mimetypes, cow_mimetypes, web&#125;]&#125;&#125;</code></pre>

<p> 如您所见，有一个可选字段可能包含一个较少使用的选项列表，如mimetypes或etag。所有选项类型都有这个可选字段。  要使用几乎可以检测所有mimetype的函数，可以执行以下配置 ：</p>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,
    [&#123;mimetypes, cow_mimetypes, all&#125;]&#125;&#125;</code></pre>

<p> 通过上述代码我们发现：配置需要一个模块和一个函数名，因此可以使用自己的任何函数 。</p>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,
    [&#123;mimetypes, Module, Function&#125;]&#125;&#125;</code></pre>

<p>Function就是我们需要处理MimeType的自定义函数。</p>
<p> 执行mimetype检测的函数接收一个参数，该参数是磁盘上文件的路径。建议以元组形式返回mimetype，但也允许使用二进制字符串(但需要额外的处理)。如果函数找不到mimetype，则返回{&lt; “application”&gt;&gt;， &lt;&lt;”octet-stream”&gt;&gt;，[]}。  当静态处理程序找不到扩展名时，它将以application/octet-stream的形式发送文件。接收到该文件的浏览器将尝试将其直接下载到磁盘。  最后，可以对所有文件硬编码mimetype。这是特别有用的组合文件和priv_file选项，因为它避免了不必要的计算。</p>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;priv_file, my_app, <span class="hljs-string">&quot;static/index.html&quot;</span>,
    [&#123;mimetypes, &#123;&lt;&lt;<span class="hljs-string">&quot;text&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;html&quot;</span>&gt;&gt;, []&#125;&#125;]&#125;&#125;</code></pre>

<blockquote>
<p>本段直接翻译官网文档。</p>
</blockquote>
<p>接下来看如何生成etag。</p>
<blockquote>
<p> HTTP协议规格说明定义ETag为“被请求变量的实体值”。另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：ETag:”50b1c1d4f775c61:df3”客户端的查询更新格式是这样的：If-None-Match : W / “50b1c1d4f775c61:df3”如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要在断点下载时比较有用。 </p>
</blockquote>
<p> 默认情况下，静态处理程序将根据大小和修改时间生成etagHTTP请求头值。但是，这个解决方案不能适用于所有的系统。例如，它在节点集群上的性能相当差，因为文件元数据在不同服务器之间会有所不同，在每个服务器上提供不同的etag。 然而，你可以改变etag的计算方法: </p>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,
    [&#123;etag, Module, Function&#125;]&#125;&#125;</code></pre>

<p> 这个函数将接收三个参数:磁盘上文件的路径、文件大小和最后修改时间。在分布式设置中，通常使用文件路径来检索所有服务器上相同的etag值。 </p>
<p> 你也可以完全禁用etag处理 :</p>
<pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,
    [&#123;etag, false&#125;]&#125;&#125;</code></pre>

<p>本章内容讲的比较底层，涉及到了HTTP协议的一些东西。可能我们在开发项目的过程中，这些东西都用不到，文件也不会放到本地服务器上，一般都是CDN来处理，但是这章仍然可以作为大家拓展知识的一个章节。</p>
<h2 id="10-Request-details：客户端请求"><a href="#10-Request-details：客户端请求" class="headerlink" title="10.Request details：客户端请求"></a>10.Request details：客户端请求</h2><p>这一节也是很好理解，学过Java的都知道HttpServletRequest，学PHP的都知道<code>$_POST</code>和<code>$_GET</code>。Cowboy把这部分内容封装成了Request。</p>
<p>Req对象是一个变量，用于获取关于请求、读取其主体或发送响应的信息。它实际上不是面向对象意义上的对象，其实是Erlang的一种数据结构，它是一个简单的映射，可以在从cowboy_req模块调用函数时直接访问或使用。</p>
<p>Req对象是几个不同章节的主题。在本章中，我们将学习Req对象，并了解如何检索关于请求的信息。</p>
<p>Req映射包含许多字段，这些字段已被文档化，可以直接访问。它们是直接映射到HTTP的字段:请求方法;使用的HTTP版本;有效的URI组件方案、主机、端口、路径和qs;请求头;连接的对等地址和端口;及TLS证书证书(如适用)。<br>请注意，version字段可用于确定连接是否使用HTTP/2。</p>
<p>上面是翻译过来的官网文档，其实对应的就类似于Java里面的<code>HttpServletRequest</code>：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpServletRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServletRequest</span> </span>&#123;
   <span class="hljs-comment">//省略代码</span>
&#125;
</code></pre>

<p>我们可以看到有很多获取客户端数据的方法，对应到Cocboy的Req对象，其实也是大同小异， 要访问字段，只需匹配函数头。下面的示例在方法为GET时发送一个简单的“Hello world!”响应，否则发送一个405错误。 </p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0=#&#123;method := &lt;&lt;<span class="hljs-string">&quot;GET&quot;</span>&gt;&gt;&#125;, State)</span> -&gt;</span>
    Req = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
        &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;
    &#125;, &lt;&lt;<span class="hljs-string">&quot;Hello world!&quot;</span>&gt;&gt;, Req0),
    &#123;ok, Req, State&#125;;
<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>
    Req = cowboy_req:reply(<span class="hljs-number">405</span>, #&#123;
        &lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;GET&quot;</span>&gt;&gt;
    &#125;, Req0),
    &#123;ok, Req, State&#125;.</code></pre>

<p>任何其他字段都是内部的，不应该被访问。它们可能会在未来的版本(包括维护版本)中发生变化，而不另行通知。<br>虽然允许修改Req对象，但除非绝对必要，否则不建议修改。如果添加了新字段，请确保对字段名称命名空间，这样就不会与未来的Cowboy更新或第三方项目发生冲突。对比Java，可以理解为私有的数据不能被随便修改，是只读属性。</p>
<h3 id="10-1-cowboy-req接口简介"><a href="#10-1-cowboy-req接口简介" class="headerlink" title="10.1 cowboy_req接口简介"></a>10.1 cowboy_req接口简介</h3><p>cowboy_req模块中的函数提供对请求信息的访问，以及处理HTTP请求时常见的各种操作。以动词开头的所有函数都表示动作。其他函数只是返回相应的值(有时确实需要构建该值，但是操作的成本相当于检索一个值)。 一些cowboy_req函数返回一个更新的Req对象。它们是read、reply、set和delete函数。虽然忽略返回的Req不会导致某些错误的行为，但是强烈建议始终保留并使用最后一个返回的Req对象。cowboy_req的手册详细介绍了这些函数以及对Req对象所做的修改。对cowboy_req的一些调用有副作用。这是read和reply函数的情况。Cowboy读取请求体，或者在调用函数时立即响应。如果出了问题，所有的函数都会崩溃。通常不需要捕获这些错误，Cowboy将根据崩溃发生的位置发送适当的4xx或5xx响应。</p>
<blockquote>
<p>本段直接翻译文档</p>
</blockquote>
<h3 id="10-2-获取请求方法"><a href="#10-2-获取请求方法" class="headerlink" title="10.2 获取请求方法"></a>10.2 获取请求方法</h3><p>通过记录获取：</p>
<pre><code class="hljs erlang">#&#123;method := Method&#125; = Req.</code></pre>

<p>或者直接获取：</p>
<pre><code class="hljs erlang">Method = cowboy_req:method(Req).</code></pre>

<p> 该方法是区分大小写的二进制字符串。标准方法包括GET、HEAD、OPTIONS、PATCH、POST、PUT或DELETE。 </p>
<h3 id="10-3-HTTP版本"><a href="#10-3-HTTP版本" class="headerlink" title="10.3 HTTP版本"></a>10.3 HTTP版本</h3><p>HTTP版本是信息性（ informational ：这个单词我不知道怎么翻译好，个人理解是：版本是个规范，有没有实现就是客户端的问题了）的。它并不表示客户机很好地或完全地实现了协议。通常不需要根据HTTP版本改变行为:Cowboy已经为您做了。不过，它在某些情况下可能有用。例如，您可能希望重定向HTTP/1.1客户端以使用Websocket，而HTTP/2客户端继续使用HTTP/2。<br>HTTP版本可以直接获取:</p>
<pre><code class="hljs erlang">#&#123;version := Version&#125; = Req.</code></pre>

<p>或者通过函数获取：</p>
<pre><code class="hljs erlang">Version = cowboy_req:version(Req).</code></pre>

<p> Cowboy定义了“HTTP/1.0”、“HTTP/1.1”和“HTTP/2”版本。自定义协议可以将自己的值定义为原子。 </p>
<h3 id="10-4-有效的请求URI"><a href="#10-4-有效的请求URI" class="headerlink" title="10.4  有效的请求URI"></a>10.4  有效的请求URI</h3><p> 有效请求URI的请求方法、主机、端口、路径和查询字符串组件都可以直接获取：</p>
<pre><code class="hljs erlang">#&#123;
    scheme := Scheme,
    host := Host,
    port := Port,
    path := Path,
    qs := Qs
&#125; = Req.</code></pre>

<p>或者使用函数获取：</p>
<pre><code class="hljs erlang">Scheme = cowboy_req:scheme(Req),
Host = cowboy_req:host(Req),
Port = cowboy_req:port(Req),
Path = cowboy_req:path(Req).
Qs = cowboy_req:qs(Req).</code></pre>

<p>HTTP请求方法和主机是大小写不敏感的二进制字符串。端口是表示端口号的整数。路径和查询字符串是区分大小写的二进制字符串。Cowboy只定义了&lt;&lt;”http”&gt;&gt;和&lt;&lt;”https”&gt;&gt;方案。它们被选中，因此对于安全HTTP/1.1或HTTP/2连接上的请求，该方案将仅为&lt;&lt;”https”&gt;&gt;。</p>
<p>有效的请求URI本身可以使用cowboy_req: URI /1,2函数进行重构。默认情况下，返回一个绝对URI:</p>
<pre><code class="hljs erlang"><span class="hljs-comment">%% scheme://host[:port]/path[?qs]</span>
URI = cowboy_req:uri(Req).</code></pre>

<p> 可以使用选项禁用或替换部分或全部组件。可以通过这种方式生成各种URI或URI格式，包括原始表单: </p>
<pre><code class="hljs erlang"><span class="hljs-comment">%% /path[?qs]</span>
URI = cowboy_req:uri(Req, #&#123;host =&gt; undefined&#125;).</code></pre>

<p>协议相关的：</p>
<pre><code class="hljs erlang"><span class="hljs-comment">%% //host[:port]/path[?qs]</span>
URI = cowboy_req:uri(Req, #&#123;scheme =&gt; undefined&#125;).</code></pre>

<p>查询字符串</p>
<pre><code class="hljs erlang">URI = cowboy_req:uri(Req, #&#123;qs =&gt; undefined&#125;).</code></pre>

<p>Host:</p>
<pre><code class="hljs erlang">URI = cowboy_req:uri(Req, #&#123;host =&gt; &lt;&lt;<span class="hljs-string">&quot;example.org&quot;</span>&gt;&gt;&#125;).</code></pre>

<h3 id="10-5-绑定"><a href="#10-5-绑定" class="headerlink" title="10.5 绑定"></a>10.5 绑定</h3><p>绑定是在定义应用程序路由时选择提取的主机和路径组件。它们只在路由之后可用。<br>Cowboy提供一些函数去获取绑定的值。</p>
<p>获取单个值：</p>
<pre><code class="hljs erlang">Value = cowboy_req:binding(userid, Req).</code></pre>

<p>默认值的情况：</p>
<pre><code class="hljs erlang">Value = cowboy_req:binding(userid, Req, <span class="hljs-number">42</span>).</code></pre>

<p>获取所有绑定的值：</p>
<pre><code class="hljs erlang">Bindings = cowboy_req:bindings(Req).</code></pre>

<p>它们作为映射返回，键是原子。Cowboy路由器还允许您使用<code>...</code>定符：</p>
<p>获取Host：</p>
<pre><code class="hljs erlang">HostInfo = cowboy_req:host_info(Req).</code></pre>

<p>获取路径：</p>
<pre><code class="hljs erlang">PathInfo = cowboy_req:path_info(Req).</code></pre>

<p> Cowboy将返回未定义如果<code>...</code>这条路线没有使用。 </p>
<h3 id="10-6-查询参数"><a href="#10-6-查询参数" class="headerlink" title="10.6 查询参数"></a>10.6 查询参数</h3><p> Cowboy提供了两个函数来访问查询参数。您可以使用第一个参数来获得整个参数列表。 </p>
<pre><code class="hljs erlang">QsVals = cowboy_req:parse_qs(Req),
&#123;_, Lang&#125; = lists:keyfind(&lt;&lt;<span class="hljs-string">&quot;lang&quot;</span>&gt;&gt;, <span class="hljs-number">1</span>, QsVals).</code></pre>

<p> Cowboy只解析查询字符串，不进行任何转换。因此，这个函数可能返回重复的值，或者没有关联值的参数名。返回列表的顺序未定义。 当查询字符串key=1&amp;key=2时，返回的列表将包含name key的两个参数。  当尝试使用php风格的后缀[]时也是如此。当查询字符串key[]=1&amp;key[]=2时，返回的列表将包含name key[]的两个参数。  当查询字符串是简单的键时，Cowboy将返回列表[{&lt;&lt;”key”&gt;&gt;， true}]，使用true表示参数键已定义，但没有值。  Cowboy提供的第二个函数允许您仅匹配感兴趣的参数，同时使用约束进行任何需要的后处理。这个函数返回一个映射。 </p>
<pre><code class="hljs erlang">#&#123;id := ID, lang := Lang&#125; = cowboy_req:match_qs([id, lang], Req).</code></pre>

<p> 约束可以自动应用。当id参数不是整数或lang参数为空时，以下代码段将崩溃。同时，id的值将被转换为整数项: </p>
<pre><code class="hljs erlang">QsMap = cowboy_req:match_qs([&#123;id, int&#125;, &#123;lang, nonempty&#125;], Req).</code></pre>

<p> 也可以提供默认值。如果没有找到lang密钥，则使用默认值。如果找到的键值为空，则不会使用它。 </p>
<pre><code class="hljs erlang">#&#123;lang := Lang&#125; = cowboy_req:match_qs([&#123;lang, [], &lt;&lt;<span class="hljs-string">&quot;en-US&quot;</span>&gt;&gt;&#125;], Req).</code></pre>

<p> 如果没有提供默认值，并且缺少该值，则查询字符串将被视为无效，进程将崩溃。当查询字符串key=1&amp;key=2时，key的值将是列表[1,2]。参数名不需要包含php风格的后缀。可以使用约束来确保只传递一个值。 </p>
<h3 id="10-7-HTTP请求头"><a href="#10-7-HTTP请求头" class="headerlink" title="10.7 HTTP请求头"></a>10.7 HTTP请求头</h3><p> 头值可以作为二进制字符串，也可以解析为更有意义的表示。 </p>
<p>获取原始值：</p>
<pre><code class="hljs erlang">HeaderVal = cowboy_req:header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req).</code></pre>

<p>Cowboy期望所有头名都以小写二进制字符串的形式提供。无论底层协议是什么，请求和响应都是如此。<br>当请求缺少header时，将返回undefined。可以提供一个不同的默认值:</p>
<pre><code class="hljs erlang">HeaderVal = cowboy_req:header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req, &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;).</code></pre>

<p> 所有的标题可以直接一次获取：</p>
<pre><code class="hljs erlang">#&#123;headers := AllHeaders&#125; = Req.</code></pre>

<p>通过函数获取：</p>
<pre><code class="hljs erlang">AllHeaders = cowboy_req:headers(Req).</code></pre>

<p> Cowboy提供了解析各个header的等效函数。没有一次解析所有标题的函数。 </p>
<pre><code class="hljs erlang">ParsedVal = cowboy_req:parse_header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req).</code></pre>

<p>如果不知道如何解析给定的HTTP请求头，或者该值无效，则会引发异常。已知HTTP请求头和默认值的列表可以在手册中找到。当头文件丢失时，将返回undefined。您可以更改默认值。注意，它应该是直接解析的值:</p>
<pre><code class="hljs erlang">ParsedVal = cowboy_req:parse_header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req,
    &#123;&lt;&lt;<span class="hljs-string">&quot;text&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;plain&quot;</span>&gt;&gt;, []&#125;).</code></pre>

<h3 id="10-8-Peer"><a href="#10-8-Peer" class="headerlink" title="10.8 Peer"></a>10.8 Peer</h3><blockquote>
<p>这个单词我不知道怎么翻译，大家可以这么理解：服务器偷偷喵一眼客户端的基本信息。不过在网络里面有个peer的概念，表示的是点对点连接的两个端点，或许这里也是这个意思：获取连接客户端的基本信息</p>
</blockquote>
<p> 可以直接使用函数获取连接的对等地址和端口号：</p>
<pre><code class="hljs erlang">#&#123;peer := &#123;IP, Port&#125;&#125; = Req.</code></pre>

<p>或者使用函数：</p>
<pre><code class="hljs erlang">&#123;IP, Port&#125; = cowboy_req:peer(Req).</code></pre>

<p> 请注意，对应到服务器的连接的远程端，服务器可能是客户机本身，也可能不是客户机本身。它也可以是代理或网关。 </p>
<h2 id="11-Reading-the-request-body：请求体获取"><a href="#11-Reading-the-request-body：请求体获取" class="headerlink" title="11.Reading the request body：请求体获取"></a>11.Reading the request body：请求体获取</h2><p>可以使用Req对象读取body。Cowboy在请求之前不会试图读取body。您需要调用body读取函数来检索它。</p>
<p>Cowboy不会缓存body，因此只能读取一次。但是，你不需要读取body。如果存在未读的正文，Cowboy将根据协议取消或跳过其下载。Cowboy提供读取原始body、读取和解析urlenencoded或多部分body的函数。</p>
<h3 id="11-1-判断请求体是否存在"><a href="#11-1-判断请求体是否存在" class="headerlink" title="11.1  判断请求体是否存在"></a>11.1  判断请求体是否存在</h3><p>如果有一个请求体，它返回true;否则错误。实际上，很少使用这个函数。当方法是POST、PUT或PATCH时，应用程序通常需要请求体，应用程序应该尝试直接读取它。</p>
<pre><code class="hljs erlang">cowboy_req:has_body(Req).</code></pre>

<h3 id="11-2-请求体的长度"><a href="#11-2-请求体的长度" class="headerlink" title="11.2 请求体的长度"></a>11.2 请求体的长度</h3><pre><code class="hljs erlang">Length = cowboy_req:body_length(Req).</code></pre>

<p>注意，长度可能不会提前知道。在这种情况下，undefined将被返回。这种情况可能发生在HTTP/1.1的分块传输编码中，或者在没有提供内容长度时发生在HTTP/2中。当读取完Req对象的主体后，Cowboy将更新该对象的主体长度。在完整读取主体后尝试调用此函数时，将始终返回一个长度。</p>
<h3 id="11-3-读取Body"><a href="#11-3-读取Body" class="headerlink" title="11.3 读取Body"></a>11.3 读取Body</h3><pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0).</code></pre>

<p>当body被完全读取时，Cowboy返回一个ok元组。默认情况下，Cowboy将尝试读取最多8MB的数据，最多持续15秒。一旦Cowboy读取了至少8MB的数据，或者在15秒周期结束时，调用将返回。</p>
<p> 这些值可以定制。例如，读取最多1MB，最多5秒: </p>
<pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0,
    #&#123;length =&gt; <span class="hljs-number">1000000</span>, period =&gt; <span class="hljs-number">5000</span>&#125;).</code></pre>

<p> 你也可以禁用长度限制: </p>
<pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0, #&#123;length =&gt; infinity&#125;).</code></pre>

<p>这将使函数等待15秒并返回在此期间到达的所有内容。对于面向公众的应用程序，不建议这样做。这两个选项可以有效地用于控制请求体的传输速率。</p>
<h3 id="11-4-流式处理Body"><a href="#11-4-流式处理Body" class="headerlink" title="11.4  流式处理Body"></a>11.4  流式处理Body</h3><p> 当Body太大时，第一个调用将返回更多的tuple而不是ok。可以再次调用该函数来读取更多的主体内容，一次读取一个块。 </p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">read_body_to_console</span><span class="hljs-params">(Req0)</span> -&gt;</span>
    <span class="hljs-keyword">case</span> cowboy_req:read_body(Req0) <span class="hljs-keyword">of</span>
        &#123;ok, Data, Req&#125; -&gt;
            io:format(<span class="hljs-string">&quot;~s&quot;</span>, [Data]),
            Req;
        &#123;more, Data, Req&#125; -&gt;
            io:format(<span class="hljs-string">&quot;~s&quot;</span>, [Data]),
            read_body_to_console(Req)
    <span class="hljs-keyword">end</span>.</code></pre>

<p><code>length</code>和<code>period</code>选项被使用了，它们必须在每次调用的时候都被传递进去。</p>
<h3 id="11-5-读取urlencoded-body"><a href="#11-5-读取urlencoded-body" class="headerlink" title="11.5 读取urlencoded body"></a>11.5 读取urlencoded body</h3><p> Cowboy提供了一个便捷的函数，用于读取和解析以 application /x-www-form-urlencoded 发送的正文。 </p>
<pre><code class="hljs erlang">&#123;ok, KeyValues, Req&#125; = cowboy_req:read_urlencoded_body(Req0).</code></pre>

<p>这个函数返回一个键/值列表，与函数cowboy_req:parse_qs/1完全相同。这个函数的默认值是不同的。Cowboy将读取最多64KB和最多5秒。它可以调整：</p>
<pre><code class="hljs erlang">&#123;ok, KeyValues, Req&#125; = cowboy_req:read_urlencoded_body(Req0,
    #&#123;length =&gt; <span class="hljs-number">4096</span>, period =&gt; <span class="hljs-number">3000</span>&#125;).</code></pre>



<h2 id="12-Sending-a-response：请求返回"><a href="#12-Sending-a-response：请求返回" class="headerlink" title="12.Sending a response：请求返回"></a>12.Sending a response：请求返回</h2><p>请求返回也是很容易理解，每个WEB框架都有这个概念，我们还是继续拿Java的来讲，其实对应的就是HttpServletReponse：</p>
<pre><code class="hljs java">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericServlet</span></span>&#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;
        <span class="hljs-comment">//servletResponse.xxx</span>
    &#125;
&#125;</code></pre>

<p>其他理论性的说明就不翻译了，我们直接看使用方法即可。</p>
<h3 id="1-一般返回值"><a href="#1-一般返回值" class="headerlink" title="1. 一般返回值"></a>1. 一般返回值</h3><p>设置HTTP状态码：</p>
<pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, Request).</code></pre>

<p>设置HTTP返回头：</p>
<pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">303</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;location&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;https://ninenines.eu&quot;</span>&gt;&gt;
&#125;, Request).</code></pre>

<p>设置返回内容：</p>
<pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;
&#125;, <span class="hljs-string">&quot;Hello world!&quot;</span>, Request).</code></pre>

<blockquote>
<p> 响应体和标头值必须是二进制或iolist 。</p>
</blockquote>
<p>构建多类型返回：</p>
<pre><code class="hljs erlang">Title = <span class="hljs-string">&quot;Hello world!&quot;</span>,
Body = &lt;&lt;<span class="hljs-string">&quot;Hats off!&quot;</span>&gt;&gt;,
Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;
&#125;, [<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;</span>, Title, <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;&quot;</span>,
    <span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;&quot;</span>, Body, <span class="hljs-string">&quot;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>], Request).</code></pre>

<p> 这种构建响应的方法比拼接字符串更有效。在后台，列表中的每个元素都只是一个指针，可以直接写入Socket。</p>
<h3 id="2-字节流返回"><a href="#2-字节流返回" class="headerlink" title="2.字节流返回"></a>2.字节流返回</h3><p>Cowboy提供了两个用于初始化响应的函数，以及一个用于流化（数据转字节流）附加函数。Cowboy将向响应添加任何必需的头信息。当你只需要设置状态代码时，使用cowboy_req:stream_reply/2。</p>
<pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, Requset),
cowboy_req:stream_body(<span class="hljs-string">&quot;Hello...&quot;</span>, nofin, Req),
cowboy_req:stream_body(<span class="hljs-string">&quot;chunked...&quot;</span>, nofin, Req),
cowboy_req:stream_body(<span class="hljs-string">&quot;world!!&quot;</span>, fin, Req).</code></pre>

<p>cowboy_req的第二个参数:stream_body/3表示该数据是否终止该body。使用fin作为最后的标志，否则使用nofin。<br>此代码段没有设置内容类型标头。不建议这样做。具有正文的所有响应都应该具有内容类型。头可以预先设置，或使用cowboy_req:stream_reply/3:</p>
<pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;
&#125;, Request),
cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;Hello world!&lt;/head&gt;&quot;</span>, nofin, Request),
cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Hats off!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, fin, Request).</code></pre>

<p>HTTP提供了一些不同的方法来流化响应主体。Cowboy将根据HTTP版本和请求和响应头选择最合适的一个。<br>虽然无论如何都不是必需的，但如果事先知道，建议在响应中设置content-length头。这将确保选择最佳响应方法，并帮助客户理解何时完全接收到响应。Cowboy还提供了发送响应片的功能。</p>
<pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;,
    &lt;&lt;<span class="hljs-string">&quot;trailer&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;expires, content-md5&quot;</span>&gt;&gt;
&#125;, Request),

cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;Hello world!&lt;/head&gt;&quot;</span>, nofin, Req),
cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Hats off!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, nofin, Req),

cowboy_req:stream_trailers(#&#123;
    &lt;&lt;<span class="hljs-string">&quot;expires&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;Sun, 10 Dec 2017 19:13:47 GMT&quot;</span>&gt;&gt;,
    &lt;&lt;<span class="hljs-string">&quot;content-md5&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;c6081d20ff41a42ce17048ed1c0345e2&quot;</span>&gt;&gt;
&#125;, Response).</code></pre>

<blockquote>
<p>其实就是用底层的方实构建HTTP的请求返回值。</p>
</blockquote>
<h3 id="3-预设响应标头"><a href="#3-预设响应标头" class="headerlink" title="3.  预设响应标头"></a>3.  预设响应标头</h3><p> Cowboy提供设置响应头而不立即发送它们的函数。它们存储在Req对象中，并在调用应答函数时作为响应的一部分发送。 </p>
<p> 设置响应标头: </p>
<pre><code class="hljs erlang">Req = cowboy_req:set_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, <span class="hljs-string">&quot;GET&quot;</span>, Req0).</code></pre>

<p> 检查响应头是否已经设置: </p>
<pre><code class="hljs erlang">cowboy_req:has_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, Req).</code></pre>

<p> 删除之前设置的响应标头: </p>
<pre><code class="hljs erlang">Req = cowboy_req:delete_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, Req0).</code></pre>

<h3 id="4-覆盖标头"><a href="#4-覆盖标头" class="headerlink" title="4. 覆盖标头"></a>4. 覆盖标头</h3><p> 因为Cowboy提供了不同的方法设置响应头和身体,可能发生冲突,因此当一个标头被设置两次以后会发生什么事情是很重要的。</p>
<p>标头有五种不同的来源: </p>
<ul>
<li>协议规范的标头（比如HTTP版本）</li>
<li>其他标头（比如日期）</li>
<li>预设标头</li>
<li>返回函数给的标头</li>
<li>Cookie标头</li>
</ul>
<p>Cowboy不允许重写特定于协议的头文件。Set-cookie头信息总是在发送响应之前附加在头信息列表的末尾。</p>
<p>提供给应答函数的标头将始终覆盖预设标头和所需标头。如果在其中的两个或三个中发现一个标头，则选择应答函数中的标头，并删除其他标头。类似地，预置头将总是覆盖所需的头。</p>
<p>为了说明这一点，请看下面的代码片段。Cowboy默认发送值为“Cowboy”的服务器头。我们可以覆盖它:</p>
<pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;server&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;yaws&quot;</span>&gt;&gt;
&#125;, Request).</code></pre>



<h3 id="5-预设返回内容"><a href="#5-预设返回内容" class="headerlink" title="5.预设返回内容"></a>5.预设返回内容</h3><p>Cowboy提供了一些函数来设置响应体，而不需要立即发送它。它存储在Req对象中，并在调用应答函数时发送。<br>       设置响应主体:</p>
<pre><code class="hljs erlang">Response = cowboy_req:set_resp_body(<span class="hljs-string">&quot;Hello world!&quot;</span>, Request).</code></pre>

<p> 查看是否已经设置了响应: </p>
<pre><code class="hljs erlang">cowboy_req:has_resp_body(Request).</code></pre>

<p>如果主体设置为非空，则返回true，否则返回false。只有当使用的应答函数是cowboy_req:reply/2或cowboy_req:reply/3时，才会发送预设的响应体。</p>
<h3 id="6-发送文件"><a href="#6-发送文件" class="headerlink" title="6.发送文件"></a>6.发送文件</h3><p> Cowboy提供了发送文件的快捷方式。当使用cowboy_req:reply/4时，或者在预先设置响应头时，你可以给Cowboy一个sendfile元组: </p>
<pre><code class="hljs erlang">&#123;sendfile, Offset, Length, Filename&#125;</code></pre>

<p> 根据偏移量或长度的值，可以发送整个文件，也可以只发送一部分。  即使发送整个文件也需要这个长度。Cowboy在 content-length 头中设置。 </p>
<pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; <span class="hljs-string">&quot;image/png&quot;</span>
&#125;, &#123;sendfile, <span class="hljs-number">0</span>, <span class="hljs-number">12345</span>, <span class="hljs-string">&quot;path/to/logo.png&quot;</span>&#125;, Request).</code></pre>

<h3 id="7-信息化返回值"><a href="#7-信息化返回值" class="headerlink" title="7.信息化返回值"></a>7.信息化返回值</h3><p>Cowboy可以发送信息响应。信息响应是状态码在100到199之间的响应。任何数字都可以在正确的响应之前发送。发送一个信息响应并不会改变正确响应的行为，客户端应该忽略任何他们不理解的信息响应。</p>
<p>下面的代码段发送了103个信息响应，其中包含一些预期在最终响应中出现的头信息。</p>
<pre><code class="hljs erlang">Response = cowboy_req:inform(<span class="hljs-number">103</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;link&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;&lt;/style.css&gt;; rel=preload; as=style, &lt;/script.js&gt;; rel=preload; as=script&quot;</span>&gt;&gt;
&#125;, Request).</code></pre>

<blockquote>
<p>这些概念可能都难以理解，主要我们平时的日常开发都是以应用为主，而没有多接触过规范，上面讲的这个Informational responses，可以在HTTP的RFC文档中找到。</p>
</blockquote>
<h3 id="8-Push"><a href="#8-Push" class="headerlink" title="8.Push"></a>8.Push</h3><p>HTTP/2协议引入了推送与响应中发送的资源相关的资源的能力。Cowboy为此提供了两个数:cowboy_req:push/3,4。Push只适用于HTTP/2。如果协议不支持它，Cowboy将自动忽略push请求。</p>
<p>push函数必须在任何应答函数之前调用。否则会导致崩溃。要推送资源，您需要提供与执行请求的客户机相同的信息。这包括HTTP方法、URI和任何必要的请求头。</p>
<p> Cowboy默认情况下只需要您提供资源和请求头的路径。URI的其余部分取自当前请求(不包括查询字符串，设置为空)，该方法默认为GET。 </p>
<p> 下面的代码段推送一个在响应中链接的CSS文件 ：</p>
<pre><code class="hljs erlang">cowboy_req:push(<span class="hljs-string">&quot;/static/style.css&quot;</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;accept&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/css&quot;</span>&gt;&gt;
&#125;, Request),
Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;
&#125;, [<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;My web page&lt;/title&gt;&quot;</span>,
    <span class="hljs-string">&quot;&lt;link rel=&#x27;stylesheet&#x27; type=&#x27;text/css&#x27; href=&#x27;/static/style.css&#x27;&gt;&quot;</span>,
    <span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Welcome to Erlang!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>], Request).</code></pre>

<p> 要覆盖方法、方案、主机、端口或查询字符串，只需传入第四个参数。下面的代码段使用了不同的主机名: </p>
<pre><code class="hljs erlang">cowboy_req:push(<span class="hljs-string">&quot;/static/style.css&quot;</span>, #&#123;
    &lt;&lt;<span class="hljs-string">&quot;accept&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/css&quot;</span>&gt;&gt;
&#125;, #&#123;host =&gt; &lt;&lt;<span class="hljs-string">&quot;cdn.example.org&quot;</span>&gt;&gt;&#125;, Req),</code></pre>

<p>推送的资源不一定是文件。只要推送请求是可缓存的、安全的，并且不包含正文，就可以推送资源。在底层，Cowboy处理推入的请求与处理普通请求相同:创建一个不同的进程，该进程最终将向客户机发送响应。</p>
<blockquote>
<p>Push是http2的一种规范，更多内容请看这里：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009782985">https://segmentfault.com/a/1190000009782985</a></p>
</blockquote>
<h2 id="13-Using-cookies：使用HTTPCookie"><a href="#13-Using-cookies：使用HTTPCookie" class="headerlink" title="13.Using cookies：使用HTTPCookie"></a>13.Using cookies：使用HTTPCookie</h2><h2 id="14-Multipart：文件处理"><a href="#14-Multipart：文件处理" class="headerlink" title="14.Multipart：文件处理"></a>14.Multipart：文件处理</h2><h2 id="15-REST-principles：Rest设计规范"><a href="#15-REST-principles：Rest设计规范" class="headerlink" title="15.REST principles：Rest设计规范"></a>15.REST principles：Rest设计规范</h2><h2 id="16-Handling-REST-requests：处理Rest请求"><a href="#16-Handling-REST-requests：处理Rest请求" class="headerlink" title="16.Handling REST requests：处理Rest请求"></a>16.Handling REST requests：处理Rest请求</h2><h2 id="17-REST-flowcharts：流式Rest请求处理"><a href="#17-REST-flowcharts：流式Rest请求处理" class="headerlink" title="17.REST flowcharts：流式Rest请求处理"></a>17.REST flowcharts：流式Rest请求处理</h2><h2 id="18-Designing-a-resource-handler：设计一个资源处理器"><a href="#18-Designing-a-resource-handler：设计一个资源处理器" class="headerlink" title="18.Designing a resource handler：设计一个资源处理器"></a>18.Designing a resource handler：设计一个资源处理器</h2><h2 id="19-The-Websocket-protocol：Websocket"><a href="#19-The-Websocket-protocol：Websocket" class="headerlink" title="19.The Websocket protocol：Websocket"></a>19.The Websocket protocol：Websocket</h2><h2 id="20-Websocket-handlers：Websocket处理器"><a href="#20-Websocket-handlers：Websocket处理器" class="headerlink" title="20.Websocket handlers：Websocket处理器"></a>20.Websocket handlers：Websocket处理器</h2><h2 id="21-Streams：流式处理"><a href="#21-Streams：流式处理" class="headerlink" title="21.Streams：流式处理"></a>21.Streams：流式处理</h2><h2 id="22-Middlewares：请求中间件"><a href="#22-Middlewares：请求中间件" class="headerlink" title="22.Middlewares：请求中间件"></a>22.Middlewares：请求中间件</h2><p>大家对于中间件可能有不同的理解，主要是目前很多框架对于中间件的叫法不一样。比如Python世界里，中间件就是用来拦截用户请求的，但是JavaWEB世界，中间件则泛指消息队列。而拦截请求的组件通常又叫拦截器。</p>
<p>对于Cowboy的中间件，大家可以按照自己的技术栈的名词进行理解即可。</p>
<p>为了加深大家对中间件的理解，拿Java拦截器作为案例来对比学习。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123; 
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        
    &#125;
&#125;</code></pre>

<p>Java同样是实现了一个类，重写<code>preHandle</code>, <code>postHandle</code>，<code>afterCompletion</code>方法。其中如果<code>preHandle</code>返回false，则终端请求，返回true则继续。</p>
<p>  对于Cowboy来讲，则是实现另一个行为模式: <code>cowboy_middleware</code>  。它也有类似的一套规则。</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(index_middleware)</span>.
<span class="hljs-keyword">-author</span><span class="hljs-params">(<span class="hljs-string">&quot;wangwenhai&quot;</span>)</span>.
<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(cowboy_middleware)</span>.
<span class="hljs-comment">%% API</span>
<span class="hljs-keyword">-export</span><span class="hljs-params">([execute/<span class="hljs-number">2</span>])</span>.

<span class="hljs-function"><span class="hljs-title">execute</span><span class="hljs-params">(Request, Env)</span> -&gt;</span>
      &#123;ok, Request, Env&#125;.
</code></pre>

<p>配置中间件</p>
<pre><code class="hljs erlang">&#123;ok, _&#125; = cowboy:start_clear(http_listener,
  [&#123;port, Port&#125;],
  #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;,
    middlewares =&gt; [cowboy_router, index_middleware, cowboy_handler]
  &#125;
),</code></pre>

<p>其中<code>execute</code>函数的返回值决定了是否继续本次请求：</p>
<ul>
<li><code>&#123;ok, Req, Env&#125;</code>继续本次请求</li>
<li><code>&#123;suspend, Module, Function, Args&#125;</code>当前请求重定向到另一个MFA</li>
<li><code>&#123;stop, Req&#125;</code> 直接终止请求</li>
</ul>
<blockquote>
<p><code>&#123;suspend, Module, Function, Args&#125;</code>会丢失所有之前的参数和堆栈信息。</p>
</blockquote>
<p> 中间件环境被定义在env参数。它是一个元组列表，第一个元素是atom，第二个元素是任何Erlang项。 </p>
<p> 环境中保留两个值: </p>
<ul>
<li><code>listener</code> ：包含前面的监听器的名称</li>
<li><code>result：</code>包含进程信息</li>
</ul>
<p>其中listener始终都包含值，result可以被任何一个中间件设置。 如果设置为ok以外的任何值，Cowboy将不处理此连接上的任何后续请求。 </p>
<blockquote>
<p>Env一般可以用来设置一些环境变量。 可以通过调用cowboy:set_env/3便利函数来更新环境，在环境中添加或替换一个值。 </p>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/erlang/">erlang</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/erlang/">erlang</a>
                    
                      <a class="hover-with-bg" href="/tags/cowboy/">cowboy</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/10/25/clra8t0tb001evkue89zjdcpl.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">EMQX插件开发基础</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/10/15/clra8t0tj002fvkue501u6xbr.html">
                        <span class="hidden-mobile">Rebar3的基础使用教程</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              <!-- Comments -->
              <div class="comments" id="comments">
                  <script src="https://utteranc.es/client.js"
                    repo="wwhai/gitalk"
                    issue-term="url"
                    label="[Utterances]"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
                  </script>
              </div>

          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ErlangCowboy基础教程&nbsp;",
      ],
      cursorChar: "$>",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "#"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  










  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?fe7a4b213463c7ca15598e31d7eabfd4";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>