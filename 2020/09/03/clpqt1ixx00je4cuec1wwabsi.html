<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nn.png">
  <link rel="icon" type="image/png" href="/img/nn.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="新四青年 的技术分享">
  <meta name="author" content="wwhai">
  <meta name="keywords" content="">
  <title>4.Netty基础知识-Netty深度解析 - 新四青年</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 40vh;">

  <!-- 顶部提示 -->
  <div class="alert alert-warning" role="alert"
    style="margin-top: 70px; background-color: black;color: rgb(156, 255, 25);text-align: center;padding: 0 0 0 0;">
    <strong>提示：本站一些文章的超时空时间是乱写的，主要是为了排序，并不是真实写作时间。</strong>
  </div>

    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar" style="background-color: #000000;">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>新四青年</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/openlab/academic.html">
                
                FreeOpenLab
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/things/">
                
                作品
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://space.bilibili.com/14649762">
                
                Bilibili
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>

</nav>


    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-03 17:02">
      September 3, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" style="border: 0px;outline: 1px solid rgb(204,204,204);" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：June 30, 2023 pm
                
              </p>
            
            <article class="markdown-body">
              <p>Netty深度解析:在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应</p>
<span id="more"></span>
<blockquote>
<p>本文来源于：【<a target="_blank" rel="noopener" href="https://github.com/ztgreat/blog-docs.git】">https://github.com/ztgreat/blog-docs.git】</a><br>编者仅仅做了简单排版和搬运收藏，非商业用途，最终知识版权归原作者所有。</p>
</blockquote>
<h2 id="Channel-与-ChannelPipeline"><a href="#Channel-与-ChannelPipeline" class="headerlink" title="Channel 与 ChannelPipeline"></a>Channel 与 ChannelPipeline</h2><p>相信大家都知道了, 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121175150.png" srcset="/img/loading.gif" alt="ChannelPipeline"></p>
<p>通过上图我们可以看到, <strong>一个 Channel 包含了一个 ChannelPipeline</strong>, 而 ChannelPipeline 中又维护了一个由 <strong>ChannelHandlerContext</strong> 组成的双向链表。</p>
<p>这个链表的头是 HeadContext, 链表的尾是 TailContext, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler.<br>上面的图示给了我们一个对 ChannelPipeline 的直观认识, 但是实际上 Netty 实现的 Channel 是否真的是这样的呢? 我们继续用源码说话.</p>
<p>关于pipeline的实例化，这个我们需要回顾一下Channel的初始化过程</p>
<h3 id="回顾Channel-初始化"><a href="#回顾Channel-初始化" class="headerlink" title="回顾Channel 初始化"></a>回顾Channel 初始化</h3><p>下面的代码是 AbstractChannel 构造器:</p>
<pre><code class="hljs reasonml">protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;
    this.parent = parent;
    unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;
    pipeline = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPipeline(<span class="hljs-params">this</span>)</span>;
&#125;</code></pre>

<p>AbstractChannel 有一个 pipeline 字段, 在构造器中会初始化它为 <code>DefaultChannelPipeline</code>的实例. 这里的代码就印证了一点: <code>每个 Channel 都有一个 ChannelPipeline</code>.</p>
<h3 id="DefaultChannelPipeline"><a href="#DefaultChannelPipeline" class="headerlink" title="DefaultChannelPipeline"></a>DefaultChannelPipeline</h3><p>接着我们跟踪一下 DefaultChannelPipeline 的初始化过程.<br>首先进入到 DefaultChannelPipeline 构造器中:</p>
<pre><code class="hljs haxe"><span class="hljs-keyword">public</span> DefaultChannelPipeline(AbstractChannel channel) &#123;
    <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">&quot;channel&quot;</span>);
    &#125;
    <span class="hljs-built_in">this</span>.channel = channel;

    tail = <span class="hljs-keyword">new</span> <span class="hljs-type">TailContext</span>(<span class="hljs-built_in">this</span>);
    head = <span class="hljs-keyword">new</span> <span class="hljs-type">HeadContext</span>(<span class="hljs-built_in">this</span>);

    head.next = tail;
    tail.prev = head;
&#125;</code></pre>

<p>在 DefaultChannelPipeline 构造器中, 首先将与之关联的 Channel 保存到字段 channel 中, 然后实例化两个 ChannelHandlerContext, 一个是 HeadContext 实例 head, 另一个是 TailContext 实例 tail. 接着将 head 和 tail 互相指向, 构成一个双向链表.</p>
<h4 id="head-handler-与taile-handler"><a href="#head-handler-与taile-handler" class="headerlink" title="head handler 与taile handler"></a>head handler 与taile handler</h4><p>我们再来看看 这个 head和tail的结构：</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190119184358.png" srcset="/img/loading.gif" alt="headContext"></p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190119184541.png" srcset="/img/loading.gif" alt="tailContext"></p>
<p>从类层次结构图中可以很清楚地看到, head 实现了 <strong>ChannelInboundHandler</strong>和 <strong>ChannelOutboundHandler</strong>, 而 tail 实现了 <strong>ChannelInboundHandler</strong>接口, 并且它们都实现了 <strong>ChannelHandlerContext</strong> 接口, 因此可以说 <strong>head 和 tail 即是一个 ChannelHandler, 又是一个 ChannelHandlerContext.</strong></p>
<p>接着看一下 HeadContext 和 TailContext的构造器:</p>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">HeadContext</span>(<span class="hljs-params">DefaultChannelPipeline pipeline</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, HEAD_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
    unsafe = pipeline.channel().unsafe();
    setAddComplete();
&#125;

<span class="hljs-function"><span class="hljs-title">TailContext</span>(<span class="hljs-params">DefaultChannelPipeline pipeline</span>)</span> &#123;
    <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, TAIL_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);
    setAddComplete();
&#125;
</code></pre>

<p>它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = true, outbound = true.<br>TailContext 它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = true, outbound = false.<br><strong>即 header 既是一个 outboundHandler又是一个inboundHandler , 而 tail 只是一个inboundHandler</strong>。</p>
<h3 id="ChannelInitializer-的添加"><a href="#ChannelInitializer-的添加" class="headerlink" title="ChannelInitializer 的添加"></a>ChannelInitializer 的添加</h3><p>我们已经分析了 Channel 的组成, 其中我们了解到, 最开始的时候 ChannelPipeline 中含有两个 ChannelHandlerContext(同时也是 ChannelHandler), 但是这个 Pipeline并不能实现什么特殊的功能, 因为我们还没有给它添加自定义的 ChannelHandler.<br>通常来说, 我们在初始化 Bootstrap, 会添加我们自定义的 ChannelHandler, 就以我们熟悉的 EchoClient 来举例吧:</p>
<pre><code class="hljs pgsql">Bootstrap b = <span class="hljs-built_in">new</span> Bootstrap();
b.<span class="hljs-keyword">group</span>(<span class="hljs-keyword">group</span>)
 .channel(NioSocketChannel.<span class="hljs-keyword">class</span>)
 .<span class="hljs-keyword">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)
 .<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
     @Override
     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;
         ChannelPipeline p = ch.pipeline();
         p.addLast(<span class="hljs-built_in">new</span> EchoClientHandler());
     &#125;
 &#125;);</code></pre>

<p>上面代码的初始化过程, 相信大家都不陌生. 在调用 handler 时, 传入了 ChannelInitializer 对象, 它提供了一个 initChannel 方法供我们初始化 ChannelHandler. 那么这个初始化过程是怎样的呢? 下面我们就来揭开它的神秘面纱.</p>
<p>ChannelInitializer 实现了 ChannelHandler, 那么它是在什么时候添加到 ChannelPipeline 中的呢? 进行了一番搜索后, 我们发现它是在 Bootstrap.init 方法中添加到 ChannelPipeline 中的.<br>其代码如下:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    ChannelPipeline p = channel.pipeline();
    p.addLast(config.<span class="hljs-keyword">handler</span>());
    ...
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelHandler <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">return</span> bootstrap.<span class="hljs-title">handler</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-keyword">final</span> <span class="hljs-function">ChannelHandler <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span>;
&#125;</code></pre>

<p>上面的代码将 handler() 返回的 ChannelHandler 添加到 Pipeline 中, 而 handler() 返回的是handler 其实就是我们在初始化 Bootstrap 调用 handler 设置的 ChannelInitializer 实例, 因此这里就是将 ChannelInitializer 插入到了 Pipeline 的末端.<br>此时 Pipeline 的结构如下图所示:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184340.png" srcset="/img/loading.gif" alt="ChannelPipline"></p>
<p>有朋友可能就有疑惑了, 我明明插入的是一个 ChannelInitializer 实例, 为什么在 ChannelPipeline 中的双向链表中的元素却是一个 ChannelHandlerContext? 为了解答这个问题, 我们继续在代码中寻找答案吧.<br>我们刚才提到, 在 Bootstrap.init 中会调用 p.addLast() 方法, 将 ChannelInitializer 插入到链表末端:</p>
<pre><code class="hljs reasonml">@Override
public ChannelPipeline add<span class="hljs-constructor">Last(EventExecutorGroup <span class="hljs-params">group</span>, <span class="hljs-params">final</span> String <span class="hljs-params">name</span>, ChannelHandler <span class="hljs-params">handler</span>)</span> &#123;
    synchronized (this) &#123;
        check<span class="hljs-constructor">DuplicateName(<span class="hljs-params">name</span>)</span>; <span class="hljs-comment">// 检查此 handler 是否有重复的名字</span>

        AbstractChannelHandlerContext newCtx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelHandlerContext(<span class="hljs-params">this</span>, <span class="hljs-params">group</span>, <span class="hljs-params">name</span>, <span class="hljs-params">handler</span>)</span>;
        add<span class="hljs-constructor">Last0(<span class="hljs-params">name</span>, <span class="hljs-params">newCtx</span>)</span>;
    &#125;

    return this;
&#125;</code></pre>

<p>addLast 有很多重载的方法, 我们关注这个比较重要的方法就可以了.<br>上面的 addLast 方法中, 首先检查这个 ChannelHandler 的名字是否是重复的, 如果不重复的话, 则为这个 Handler 创建一个对应的 DefaultChannelHandlerContext 实例, 并与之关联起来(Context 中有一个 handler 属性保存着对应的 Handler 实例). 判断此 Handler 是否重名的方法很简单: Netty 中有一个 <strong>name2ctx</strong> Map 字段, key 是 handler 的名字, 而 value 则是 handler 本身. 因此通过如下代码就可以判断一个 handler 是否重名了:</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void check<span class="hljs-constructor">DuplicateName(String <span class="hljs-params">name</span>)</span> &#123;
    <span class="hljs-keyword">if</span> (name2ctx.contains<span class="hljs-constructor">Key(<span class="hljs-params">name</span>)</span>) &#123;
        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">&quot;Duplicate handler name: &quot;</span> + <span class="hljs-params">name</span>)</span>;
    &#125;
&#125;</code></pre>

<p>为了添加一个 handler 到 pipeline 中, 必须<strong>把此 handler 包装成 ChannelHandlerContext</strong>. 因此在上面的代码中我们可以看到新实例化了一个 newCtx 对象, 并将 handler 作为参数传递到构造方法中. 那么我们来看一下实例化的 DefaultChannelHandlerContext 到底有什么玄机吧.<br>首先看它的构造器:</p>
<pre><code class="hljs pgsql">DefaultChannelHandlerContext(
        DefaultChannelPipeline pipeline, EventExecutorGroup <span class="hljs-keyword">group</span>, String <span class="hljs-type">name</span>, ChannelHandler <span class="hljs-keyword">handler</span>) &#123;
    super(pipeline, <span class="hljs-keyword">group</span>, <span class="hljs-type">name</span>, isInbound(<span class="hljs-keyword">handler</span>), isOutbound(<span class="hljs-keyword">handler</span>));
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>) &#123;
        throw <span class="hljs-built_in">new</span> NullPointerException(&quot;handler&quot;);
    &#125;
    this.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;
&#125;</code></pre>

<p>DefaultChannelHandlerContext 的构造器中, 调用了两个很有意思的方法: <strong>isInbound</strong> 与 <strong>isOutbound</strong>, 这两个方法是做什么的呢?</p>
<pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInbound</span><span class="hljs-params">(ChannelHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span> <span class="hljs-keyword">instanceof</span> ChannelInboundHandler;
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOutbound</span><span class="hljs-params">(ChannelHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span> <span class="hljs-keyword">instanceof</span> ChannelOutboundHandler;
&#125;</code></pre>

<p>从源码中可以看到, 当一个 handler 实现了 ChannelInboundHandler 接口, 则 isInbound 返回真; 相似地, 当一个 handler 实现了 ChannelOutboundHandler 接口, 则 isOutbound 就返回真.<br>而这两个 boolean 变量会传递到父类 AbstractChannelHandlerContext 中, 并初始化父类的两个字段: <strong>inbound</strong> 与 <strong>outbound</strong>.<br>那么这里的 ChannelInitializer 所对应的 DefaultChannelHandlerContext 的 inbound 与 inbound 字段分别是什么呢? 那就看一下 ChannelInitializer 到底实现了哪个接口不就行了? 如下是 ChannelInitializer 的类层次结构图:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184503.png" srcset="/img/loading.gif" alt="ChannelInitializer"></p>
<p>可以清楚地看到, <strong>ChannelInitializer 仅仅实现了 ChannelInboundHandler 接口</strong>, 因此这里实例化的 DefaultChannelHandlerContext 的 inbound = true, outbound = false.<br>不就是 inbound 和 outbound 两个字段嘛, 为什么需要这么大费周章地分析一番? 其实这两个字段关系到 pipeline 的事件的流向与分类, 因此是十分关键的。</p>
<p>当创建好 Context 后, 就将这个 Context 插入到 Pipeline 的双向链表中:</p>
<pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void addLast0(final <span class="hljs-keyword">String</span> name, AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>) &#123;
    checkMultiplicity(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);

    AbstractChannelHandlerContext prev = tail.prev;
    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.prev = prev;
    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.next = tail;
    prev.next = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;
    tail.prev = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;

    name2ctx.put(name, <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);

    callHandlerAdded(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);
&#125;</code></pre>

<p>显然, 这个代码就是典型的双向链表的插入操作了. 当调用了 addLast 方法后, Netty 就会将此 handler 添加到双向链表中 tail 元素之前的位置.</p>
<h3 id="自定义-ChannelHandler-的添加过程"><a href="#自定义-ChannelHandler-的添加过程" class="headerlink" title="自定义 ChannelHandler 的添加过程"></a>自定义 ChannelHandler 的添加过程</h3><p>接下来就来探讨一下 ChannelInitializer 在哪里被调用, ChannelInitializer 的作用, 以及我们自定义的 ChannelHandler 是如何插入到 Pipeline 中的.</p>
<pre><code class="hljs pgsql">Bootstrap b = <span class="hljs-built_in">new</span> Bootstrap();
b.<span class="hljs-keyword">group</span>(<span class="hljs-keyword">group</span>)
 .channel(NioSocketChannel.<span class="hljs-keyword">class</span>)
 .<span class="hljs-keyword">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)
 .<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
     @Override
     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;
         ChannelPipeline p = ch.pipeline();
         p.addLast(<span class="hljs-built_in">new</span> EchoClientHandler());
     &#125;
 &#125;);</code></pre>

<p>最简单的方式便是在 initChannel 方法中设置断点，然后查看调用栈，这样方式可以很快的找到切入点，对于我不是很熟悉的框架，我个人便是采用的这种方式，下面是一个调用栈，这个可以自己尝试一下：</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190119190129.png" srcset="/img/loading.gif" alt="20190119190129"></p>
<p>先不管在什么时候调用，我们知道会先调用 ChannelInitializer 中的 一个 initChannel</p>
<h4 id="initChannel"><a href="#initChannel" class="headerlink" title="initChannel"></a>initChannel</h4><p>ChannelInitializer -&gt; initChannel：</p>
<pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Guard against re-entrance.</span>
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//调用我们自定义的handler 添加方法</span>
            initChannel((C) ctx.channel());
        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;
            exceptionCaught(ctx, cause);
        &#125; <span class="hljs-keyword">finally</span> &#123;
            <span class="hljs-comment">//注意这里</span>
            remove(ctx);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;
     <span class="hljs-keyword">try</span> &#123;
         ChannelPipeline pipeline = ctx.pipeline();
         <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-keyword">null</span>) &#123;
             <span class="hljs-comment">//从pipeline 中删除 该 Context</span>
             pipeline.remove(<span class="hljs-keyword">this</span>);
          &#125;
      &#125; <span class="hljs-keyword">finally</span> &#123;
         initMap.remove(ctx);
      &#125;
&#125;</code></pre>

<p>initChannel 方法内容会调用 我们另一个 initChannel 方法（重载），而这个方法就是用户端实现的handler 添加逻辑，也就是我们在初始化 Bootstrap 时, 调用 handler 方法传入的匿名内部类所实现的方法:</p>
<pre><code class="hljs aspectj">.<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;
     <span class="hljs-meta">@Override</span>
     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
         ChannelPipeline p = ch.pipeline();
         p.addLast(<span class="hljs-keyword">new</span> EchoClientHandler());
     &#125;
 &#125;);</code></pre>

<p>因此当调用了这个方法后, 我们自定义的 ChannelHandler 就插入到 Pipeline 了, 此时的 Pipeline 如下图所示:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121195152.png" srcset="/img/loading.gif" alt="ChannelPipeline"></p>
<h4 id="ChannelInitializer的移除"><a href="#ChannelInitializer的移除" class="headerlink" title="ChannelInitializer的移除"></a>ChannelInitializer的移除</h4><p>当添加了自定义的 ChannelHandler 后, <strong>会删除 ChannelInitializer 这个 ChannelHandler</strong>, 即 “ctx.pipeline().remove(this)”, 因此最后的 Pipeline 如下:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121193057.png" srcset="/img/loading.gif" alt="ChannelPipeline"></p>
<p>好了, 到了这里, 我们的 <strong>自定义 ChannelHandler 的添加过程</strong> 也分析的查不多了.</p>
<h2 id="Pipeline-的事件传输机制"><a href="#Pipeline-的事件传输机制" class="headerlink" title="Pipeline 的事件传输机制"></a>Pipeline 的事件传输机制</h2><p>从前面我们知道 AbstractChannelHandlerContext 中有 inbound 和 outbound 两个 boolean 变量, 分别用于标识 Context 所对应的 handler 的类型, 即:</p>
<ul>
<li>inbound 为真时, 表示对应的 ChannelHandler 实现了 ChannelInboundHandler 方法.</li>
<li>outbound 为真时, 表示对应的 ChannelHandler 实现了 ChannelOutboundHandler 方法.</li>
</ul>
<p>读者朋友肯定很疑惑了吧: 那究竟这两个字段有什么作用呢? 其实这还要从 ChannelPipeline 的传输的事件类型说起.<br><strong>Netty 的事件可以分为 Inbound 和 Outbound 事件.</strong></p>
<p>如下是从 Netty 官网上拷贝的一个图示:</p>
<pre><code class="hljs gherkin">                          I/O Request
                         via Channel or
                         ChannelHandlerContext
                                |<span class="hljs-string"></span>
<span class="hljs-string">+---------------------------------------------------+---------------+</span>
<span class="hljs-string"></span>|<span class="hljs-string">                           ChannelPipeline         </span>|<span class="hljs-string">               </span>|
|<span class="hljs-string">                                                  \</span>|<span class="hljs-string">/              </span>|
|<span class="hljs-string">    +---------------------+            +-----------+----------+    </span>|
|<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  N  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  1  </span>|<span class="hljs-string">    </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>|
|<span class="hljs-string">               </span>|<span class="hljs-string">                                  \</span>|<span class="hljs-string">/              </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler N-1 </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  2  </span>|<span class="hljs-string">    </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  .               </span>|
|<span class="hljs-string">               .                                   .               </span>|
|<span class="hljs-string"> ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()</span>|
|<span class="hljs-string">        [ method call]                       [method call]         </span>|
|<span class="hljs-string">               .                                   .               </span>|
|<span class="hljs-string">               .                                  \</span>|<span class="hljs-string">/              </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  2  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler M-1 </span>|<span class="hljs-string">    </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>|
|<span class="hljs-string">               </span>|<span class="hljs-string">                                  \</span>|<span class="hljs-string">/              </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  1  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  M  </span>|<span class="hljs-string">    </span>|
|<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>|
|<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>|
+---------------+-----------------------------------+---------------+
              |<span class="hljs-string">                                  \</span>|<span class="hljs-string">/</span>
<span class="hljs-string">+---------------+-----------------------------------+---------------+</span>
<span class="hljs-string"></span>|<span class="hljs-string">               </span>|<span class="hljs-string">                                   </span>|<span class="hljs-string">               </span>|
|<span class="hljs-string">       [ Socket.read() ]                    [ Socket.write() ]     </span>|
|<span class="hljs-string">                                                                   </span>|
|<span class="hljs-string">  Netty Internal I/O Threads (Transport Implementation)            </span>|
+-------------------------------------------------------------------+</code></pre>

<p>从上图可以看出, inbound 事件和 outbound 事件的流向是不一样的:</p>
<ul>
<li>inbound 事件的流行是从下至上</li>
<li>outbound 事件的流行 是从上到下</li>
</ul>
<p>inbound 的传递方式是通过调用相应的 <strong>ChannelHandlerContext.fireIN_EVT()</strong> 方法。</p>
<p> outbound 方法的的传递方式是通过调用 <strong>ChannelHandlerContext.OUT_EVT()</strong> 方法. </p>
<p>例如 <strong>ChannelHandlerContext.fireChannelRegistered()</strong> 调用会发送一个 <strong>ChannelRegistered</strong> 的 inbound 给下一个ChannelHandlerContext, 而 <strong>ChannelHandlerContext.bind</strong> 调用会发送一个 <strong>bind</strong> 的 outbound 事件给 下一个 ChannelHandlerContext.</p>
<p>Inbound 事件传播方法有:</p>
<pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelRegistered()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelActive()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelRead(Object)</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelReadComplete()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ExceptionCaught(Throwable)</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">UserEventTriggered(Object)</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelWritabilityChanged()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelInactive()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelUnregistered()</span></code></pre>

<p>Oubound 事件传输方法有:</p>
<pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>bind(SocketAddress, ChannelPromise)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>connect(SocketAddress, SocketAddress, ChannelPromise)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>write(Object, ChannelPromise)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>flush<span class="hljs-literal">()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>read<span class="hljs-literal">()</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>disconnect(ChannelPromise)
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>close(ChannelPromise)</code></pre>

<p><code>注意, 如果我们捕获了一个事件, 并且想让这个事件继续传递下去, 那么需要调用 Context 相应的传播方法.</code><br>例如:</p>
<pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    public void channelActive(<span class="hljs-type">ChannelHandlerContext</span> ctx) &#123;
        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Connected!&quot;</span>);
        ctx.fireChannelActive();
    &#125;
&#125;

public clas <span class="hljs-type">MyOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">ChannelOutboundHandlerAdapter</span> &#123;
    <span class="hljs-meta">@Override</span>
    public void close(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">ChannelPromise</span> promise) &#123;
        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Closing ..&quot;</span>);
        ctx.close(promise);
    &#125;
&#125;</code></pre>

<p>上面的例子中, MyInboundHandler 收到了一个 channelActive 事件, 它在处理后, 如果希望将事件继续传播下去, 那么需要接着调用 ctx.fireChannelActive().</p>
<h3 id="Outbound-操作"><a href="#Outbound-操作" class="headerlink" title="Outbound 操作"></a>Outbound 操作</h3><p><code>Outbound 事件都是请求事件(request event)</code>, 即请求某件事情的发生, 然后通过 Outbound 事件进行通知.<br>Outbound 事件的传播方向是 tail -&gt; customContext -&gt; head.</p>
<h4 id="connect-事件传播"><a href="#connect-事件传播" class="headerlink" title="connect 事件传播"></a>connect 事件传播</h4><p>我们接下来以 connect 事件为例, 分析一下 Outbound 事件的传播机制.<br>首先, 当用户调用了 Bootstrap.connect 方法时, 就会触发一个 <strong>Connect 请求事件</strong>, 此调用会触发如下调用链:</p>
<pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bootstrap</span>.</span></span>connect -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bootstrap</span>.</span></span>doConnect  -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span></span>connect</code></pre>

<p>继续跟踪的话, 我们就发现, AbstractChannel.connect 其实由调用了 DefaultChannelPipeline.connect 方法:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">return</span> pipeline.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, promise)</span></span>;
&#125;</code></pre>

<p>而 pipeline.connect 的实现如下:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, promise)</span></span>;
&#125;</code></pre>

<p>可以看到, 当 outbound 事件(这里是 connect 事件)传递到 Pipeline 后, 它其实是以 tail 为起点开始传播的.<br>而 tail.connect 其实调用的是 AbstractChannelHandlerContext.connect 方法:</p>
<pre><code class="hljs axapta">@Override
<span class="hljs-keyword">public</span> ChannelFuture connect(
        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise) &#123;
    ...
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextOutbound();
    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();
    ...
    <span class="hljs-keyword">next</span>.invokeConnect(remoteAddress, localAddress, promise);
    ...
    <span class="hljs-keyword">return</span> promise;
&#125;</code></pre>

<p>findContextOutbound() 顾名思义, 它的作用是以当前 Context 为起点, 向 Pipeline 中的 Context 双向链表的前端寻找第一个 <strong>outbound</strong> 属性为真的 Context(即关联着 ChannelOutboundHandler 的 Context), 然后返回.<br>它的实现如下:</p>
<pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext findContextOutbound() &#123;
    AbstractChannelHandlerContext ctx = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">do</span> &#123;
        ctx = ctx.prev;
    &#125; <span class="hljs-keyword">while</span> (!ctx.outbound);
    <span class="hljs-keyword">return</span> ctx;
&#125;</code></pre>

<p>当我们找到了一个 outbound 的 Context 后, 就调用它的 invokeConnect 方法, 这个方法中会调用 Context 所关联着的 ChannelHandler 的 connect 方法:</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void invoke<span class="hljs-constructor">Connect(SocketAddress <span class="hljs-params">remoteAddress</span>, SocketAddress <span class="hljs-params">localAddress</span>, ChannelPromise <span class="hljs-params">promise</span>)</span> &#123;
    <span class="hljs-keyword">try</span> &#123;
        ((ChannelOutboundHandler) handler<span class="hljs-literal">()</span>).connect(this, remoteAddress, localAddress, promise);
    &#125; catch (Throwable t) &#123;
        notify<span class="hljs-constructor">OutboundHandlerException(<span class="hljs-params">t</span>, <span class="hljs-params">promise</span>)</span>;
    &#125;
&#125;</code></pre>

<p>如果用户没有重写 ChannelHandler 的 connect 方法, 那么会调用 ChannelOutboundHandlerAdapter 所实现的方法:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span>
<span class="hljs-params"><span class="hljs-function">        SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    ctx.connect(remoteAddress, localAddress, promise);
&#125;</code></pre>

<p>我们看到, ChannelOutboundHandlerAdapter.connect 仅仅调用了 ctx.connect, 而这个调用又回到了:</p>
<pre><code class="hljs xl">C<span class="hljs-function"><span class="hljs-title">ontext</span>.connect -&gt;</span> C<span class="hljs-function"><span class="hljs-title">onnect</span>.findContextOutbound -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span>.invokeConnect -&gt;</span> <span class="hljs-function"><span class="hljs-title">handler</span>.connect -&gt;</span> Context.connect</code></pre>

<p>这样的循环中, 直到 connect 事件传递到DefaultChannelPipeline 的双向链表的头节点, 即 head 中. 为什么会传递到 head 中呢? 回想一下, head 实现了 ChannelOutboundHandler, 因此它的 outbound 属性是 true.<br><code>因为 head 本身既是一个 ChannelHandlerContext, 又实现了 ChannelOutboundHandler 接口</code>, 因此当 connect 消息传递到 head 后, 会将消息转递到对应的 ChannelHandler 中处理, 而恰好, head 的 handler() 返回的就是 head 本身:</p>
<p><code>HeadContext</code>-&gt;<code>handler</code></p>
<pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> ChannelHandler handler() &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre>

<p>因此最终 connect 事件是在 head 中处理的. head 的 connect 事件处理方法如下:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span>
<span class="hljs-params"><span class="hljs-function">        ChannelHandlerContext ctx,</span></span>
<span class="hljs-params"><span class="hljs-function">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span>
<span class="hljs-params"><span class="hljs-function">        ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    unsafe.connect(remoteAddress, localAddress, promise);
&#125;</code></pre>

<p>到这里, 整个 Connect 请求事件就结束了.<br>下面以一幅图来描述一个整个 Connect 请求事件的处理过程:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184504.png" srcset="/img/loading.gif" alt="ChannelPipeline"></p>
<p>我们仅仅以 Connect 请求事件为例, 分析了 Outbound 事件的传播过程, 但是其实所有的 outbound 的事件传播都遵循着一样的传播规律, 读者可以试着分析一下其他的 outbound 事件, 体会一下它们的传播过程.</p>
<h3 id="Inbound-事件"><a href="#Inbound-事件" class="headerlink" title="Inbound 事件"></a>Inbound 事件</h3><p>Inbound 事件和 Outbound 事件的处理过程有点镜像.<br><code>Inbound 事件是一个通知事件</code>, 即某件事已经发生了, 然后通过 Inbound 事件进行通知. Inbound 通常发生在 Channel 的状态的改变或 IO 事件就绪.<br>Inbound 的特点是它传播方向是 head -&gt; customContext -&gt; tail.</p>
<p>既然上面我们分析了 Connect 这个 Outbound 事件, 那么接着分析 Connect 事件后会发生什么 Inbound 事件, 并最终找到 Outbound 和 Inbound 事件之间的联系.</p>
<h4 id="ChannelActive-事件传播"><a href="#ChannelActive-事件传播" class="headerlink" title="ChannelActive 事件传播"></a>ChannelActive 事件传播</h4><p>当 Connect 这个 Outbound 传播到 unsafe 后, 其实是在 AbstractNioUnsafe.connect 方法中进行处理的:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span>
<span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;
    ...
    <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;
        fulfillConnectPromise(promise, wasActive);
    &#125; <span class="hljs-keyword">else</span> &#123;
        ...
    &#125;
    ...
&#125;</code></pre>

<p>在 AbstractNioUnsafe.connect 中, 首先调用 doConnect 方法进行实际上的 Socket 连接, 当连接上后, 会调用 fulfillConnectPromise 方法:</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void fulfill<span class="hljs-constructor">ConnectPromise(ChannelPromise <span class="hljs-params">promise</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">wasActive</span>)</span> &#123;<span class="hljs-operator"></span>
<span class="hljs-operator">    ...</span>
<span class="hljs-operator">    </span><span class="hljs-comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span>
    <span class="hljs-comment">// because what happened is what happened.</span>
    <span class="hljs-keyword">if</span> (!wasActive<span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">Active()</span>) &#123;
        pipeline<span class="hljs-literal">()</span>.fire<span class="hljs-constructor">ChannelActive()</span>;
    &#125;<span class="hljs-operator"></span>
<span class="hljs-operator">    ...</span>
<span class="hljs-operator"></span>&#125;</code></pre>

<p>我们看到, 在 fulfillConnectPromise 中, 会通过调用 pipeline().fireChannelActive() 将通道激活的消息(即 Socket 连接成功)发送出去.<br><code>而这里, 当调用 pipeline.fireXXX 后, 就是 Inbound 事件的起点.</code><br>因此当调用了 pipeline().fireChannelActive() 后, 就产生了一个 ChannelActive Inbound 事件, 我们就从这里开始看看这个 Inbound 事件是怎么传播的吧.</p>
<pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelActive() &#123;
	AbstractChannelHandlerContext.invokeChannelActive(head);
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre>

<p>继续看看里面在干什么？（<strong>注意这里传入了head</strong>）</p>
<pre><code class="hljs axapta">@Override
<span class="hljs-keyword">public</span> ChannelHandlerContext fireChannelActive() &#123;
    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextInbound();
    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();
    ...
    <span class="hljs-keyword">next</span>.invokeChannelActive();
    ...
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre>

<p>这个方法和 Outbound 的对应方法(例如 invokeConnect) 如出一辙. </p>
<p>invokeChannelActive 方法如下:</p>
<pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">try</span> &#123;
        ((ChannelInboundHandler) <span class="hljs-keyword">handler</span>()).channelActive(<span class="hljs-keyword">this</span>);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        notifyHandlerException(t);
    &#125;
&#125;</code></pre>

<p>同 Outbound 一样, 如果用户没有重写 channelActive 方法, 那么会调用 ChannelInboundHandler 的 channelActive 方法:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    ctx.fireChannelActive();
    readIfIsAutoRead();
&#125;</code></pre>

<p>哈哈, 果然, 调用的是 fireChannelActive() 方法, <code>因此可以证明了, Inbound 事件在 Pipeline 中传输的起点是 head.</code></p>
<p>同理, tail 本身 实现了 <strong>ChannelInboundHandler</strong> 接口, 因此当 channelActive 消息传递到 tail 后, 会将消息转递到对应的 ChannelHandler 中处理, 而恰好, tail 的 handler() 返回的就是 tail 本身:</p>
<pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> ChannelHandler handler() &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
&#125;</code></pre>

<p>因此 channelActive Inbound 事件最终是在 tail 中处理的, 我们看一下它的处理方法:</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
	onUnhandledInboundChannelActive();
&#125;
<span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundChannelActive</span><span class="hljs-params">()</span> </span>&#123;
&#125;</code></pre>

<p>TailContext.channelActive  会调用onUnhandledInboundChannelActive()方法 . 默认情况下 它的实现都是空的. 可见, 如果是 Inbound, 当用户没有实现自定义的处理器时, 那么默认是不处理的.</p>
<p>用一幅图来总结一下 Inbound 的传输过程吧:</p>
<p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184505.png" srcset="/img/loading.gif" alt="ChannelPipeline"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 Outbound事件:</p>
<ul>
<li>Outbound 事件是请求事件(由 Connect 发起一个请求, 并最终由 unsafe 处理这个请求)</li>
<li>Outbound 事件的发起者是 Channel</li>
<li>Outbound 事件的处理者是 unsafe</li>
<li>Outbound 事件在 Pipeline 中的传输方向是 tail -&gt; head.</li>
<li>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Hnalder, 则需要调用 ctx.xxx (例如 ctx.connect) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</li>
<li>Outbound 事件流: Context.OUT_EVT -&gt; Connect.findContextOutbound -&gt; nextContext.invokeOUT_EVT -&gt; nextHandler.OUT_EVT -&gt; nextContext.OUT_EVT</li>
</ul>
<p>对于 Inbound 事件:</p>
<ul>
<li>Inbound 事件是通知事件, 当某件事情已经就绪后, 通知上层.</li>
<li>Inbound 事件发起者是 unsafe</li>
<li>Inbound 事件的处理者是 Channel, 如果用户没有实现自定义的处理方法, 那么Inbound 事件默认的处理者是 TailContext, 并且其处理方法是空实现.</li>
<li>Inbound 事件在 Pipeline 中传输方向是 head -&gt; tail</li>
<li>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Hnalder, 则需要调用 ctx.fireIN_EVT (例如 ctx.fireChannelActive) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</li>
<li>Outbound 事件流: Context.fireIN_EVT -&gt; Connect.findContextInbound -&gt; nextContext.invokeIN_EVT -&gt; nextHandler.IN_EVT -&gt; nextContext.fireIN_EVT</li>
</ul>
<p>outbound 和 inbound 事件十分的镜像, 并且 Context 与 Handler 直接的调用关系是否容易混淆, 因此读者在阅读这里的源码时, 需要特别的注意.</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Netty%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Netty基础知识</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Netty/">Netty</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/03/clpqt1ixw00jd4cueevwn5qdn.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">3.Netty基础知识-异步接口实现原理</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/13/clpqt1ivj006w4cue5pkzelfz.html">
                        <span class="hidden-mobile">在闽回忆录</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              <!-- Comments -->
              <div class="comments" id="comments">
                  <script src="https://utteranc.es/client.js"
                    repo="wwhai/gitalk"
                    issue-term="url"
                    label="[Utterances]"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
                  </script>
              </div>

          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "4.Netty基础知识-Netty深度解析&nbsp;",
      ],
      cursorChar: "$>",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "#"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  










  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?fe7a4b213463c7ca15598e31d7eabfd4";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>