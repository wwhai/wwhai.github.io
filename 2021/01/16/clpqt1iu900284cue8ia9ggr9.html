<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/nn.png">
  <link rel="icon" type="image/png" href="/img/nn.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="新四青年 的技术分享">
  <meta name="author" content="wwhai">
  <meta name="keywords" content="">
  <title>30分钟学Erlang (二) - 新四青年</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 40vh;">

  <!-- 顶部提示 -->
  <div class="alert alert-warning" role="alert"
    style="margin-top: 70px; background-color: black;color: rgb(156, 255, 25);text-align: center;padding: 0 0 0 0;">
    <strong>提示：本站一些文章的超时空时间是乱写的，主要是为了排序，并不是真实写作时间。</strong>
  </div>

    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar" style="background-color: #000000;">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>新四青年</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/openlab/academic.html">
                
                FreeOpenLab
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/things/">
                
                作品
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://space.bilibili.com/14649762">
                
                Bilibili
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>

</nav>


    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-01-16 21:01">
      January 16, 2021 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      91
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" style="border: 0px;outline: 1px solid rgb(204,204,204);" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：June 30, 2023 pm
                
              </p>
            
            <article class="markdown-body">
              <p>作者：Shawn # 概要：那些已经有过至少一门编程语言基础，并且需要快速了解Erlang，掌握其基本要点，并马上投入工作中的人。<br>文章挺长，所以分成了几篇。但只要掌握了本文中提到的这些知识点，你就可以上手工作了。剩下的就是在实践中继续学习。</p>
<span id="more"></span>

<blockquote>
<p>本文来自我的同事Shawn大佬的总结，Shawn大佬是目前国内Erlang领域内的权威开发架构师，30分钟学erlang系列文章是Shawn的一线经验，对于新入门的朋友很有帮助。再次感谢Shawn花时间整理博客，和贡献文档供社区学习。</p>
</blockquote>
<h1 id="30分钟学Erlang-一"><a href="#30分钟学Erlang-一" class="headerlink" title="30分钟学Erlang (一)"></a>30分钟学Erlang (一)</h1><h3 id="本文写给谁看的？"><a href="#本文写给谁看的？" class="headerlink" title="本文写给谁看的？"></a>本文写给谁看的？</h3><p>那些已经有过至少一门编程语言基础，并且需要快速了解Erlang，掌握其基本要点，并马上投入工作中的人。<br>文章挺长，所以分成了几篇。但只要掌握了本文中提到的这些知识点，你就可以上手工作了。剩下的就是在实践中继续学习。<br><code>Erlang 读作 ai lan, er lan, er lang 都行，但你别单个字母读 E-R-L-A-N-G，那样我就不跟你玩了。</code></p>
<h3 id="什么时候用-Erlang？"><a href="#什么时候用-Erlang？" class="headerlink" title="什么时候用 Erlang？"></a>什么时候用 Erlang？</h3><p>Erlang 的设计目标非常明确，就是专门为大型的电信系统设计。<br>所以它的应用场景和设计需求就是电信领域里需要解决的问题。<br>主要是三个： <strong>高并发</strong>、<strong>高容错</strong>、<strong>软实时</strong>。电信系统负载非常大，需要同时服务大量用户的能力；同时不允许出错，电话频繁掉线会很快把客户赶到竞争对手那边；再者，即便某个通话再繁忙也不能影响其他通话的正常进行，到技术层面就是，不能因为某个任务很重，就把其他的任务的资源都占用了，while loop 占用 100% CPU是绝对不允许的。</p>
<p>Erlang 是实用主义的语言，属于函数式语言但并不是完全的函数式，使用 Actor 并发模型，并在此之上提供了一些更高级别的设计模式，还提供了各种常用的功能组件(e.g. HTTP客户端, XML编解码等)。Erlang 早已经脱离电信行业，飞奔到互联网行业了，因为这些年互联网行业所面临的问题，跟几十年前的电信系统越来越像。如今，<a target="_blank" rel="noopener" href="http://www.emqtt.io">Erlang 正在进入物联网行业</a>，它将为世界物联网的发展做出自己的贡献。</p>
<h3 id="Erlang-的不同之处"><a href="#Erlang-的不同之处" class="headerlink" title="Erlang 的不同之处"></a>Erlang 的不同之处</h3><p>如果问到 Erlang (相较于其他编程语言) 的特别之处，有人会回答它的并发能力，有人会说并发模型或者分布式能力。这些人都不是真正理解 Erlang 设计目的的“正规军”，因为 Erlang 与其他语言最大的区别在于他的容错能力。Erlang 从设计之初就将容错作为最高级别的任务，它的大多数特性是都为容错服务的：</p>
<p>抢占式调度的虚拟机和基于每个进程的垃圾回收保证了软实时能力，进程并发模型保证了单个进程异常终止不会将异常扩散到其他进程，消息传递模型消除了共享内存导致的竞态条件，OTP 提供的程序组织结构 application 和 supervisor tree 更是 Erlang 独有的高容错架构，热更新功能则提供了开着跑车换轮子的能力。</p>
<p>所以当别人问到你 Erlang 最大的特点是什么，就两个字：容错。</p>
<h2 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h2><p>学习 Erlang 等小众语言的过程中，没有太多中文资料，所以这篇文章里，对于名词、概念类的，还是用英文原词不做翻译。以免造成以后学习的障碍。</p>
<h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li>For <a target="_blank" rel="noopener" href="http://brew.sh/">Homebrew</a> on OS X: brew install erlang</li>
<li>For <a target="_blank" rel="noopener" href="https://www.macports.org/">MacPorts</a> on OS X: port install erlang</li>
<li>For <a target="_blank" rel="noopener" href="http://www.ubuntu.com/">Ubuntu</a> and <a target="_blank" rel="noopener" href="https://www.debian.org/">Debian</a>: apt-get install erlang</li>
<li>For <a target="_blank" rel="noopener" href="https://getfedora.org/">Fedora</a>: yum install erlang</li>
<li>For <a target="_blank" rel="noopener" href="https://www.freebsd.org/">FreeBSD</a>: pkg install erlang</li>
</ul>
<h5 id="启动-Erlang-Shell"><a href="#启动-Erlang-Shell" class="headerlink" title="启动 Erlang Shell"></a>启动 Erlang Shell</h5><p>安装完成后，在终端里敲 ‘erl’ 进入 Erlang 的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF">REPL</a>，erlang shell:</p>
<pre><code class="hljs shell">➜  ~ erl
Erlang/OTP 20 [erts-9.3] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V9.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> io:format(<span class="hljs-string">&quot;hello world!~n&quot;</span>).</span>
hello world!
ok
<span class="hljs-meta">2&gt;</span><span class="bash"> 1 + 1.</span>
2
<span class="hljs-meta">3&gt;</span><span class="bash"> q().</span>
ok                                                                       
➜  ~</code></pre>

<p>上面 Erlang shell 里:</p>
<ul>
<li>第一行 <code>io:format(&quot;hello world!~n&quot;).</code> 向标准输出写了一行 <code>&quot;hello world!&quot;</code>, 并以 “~n” 换行结尾。最后显示的那个 <code>ok</code> 是<code>io:format()</code> 函数的返回值。</li>
<li>第二行 <code>1 + 1.</code> 做了个加法运算，返回值是 <code>2</code>。</li>
<li>第三行 <code>q().</code> 是退出 erlang shell, 是 <code>init:stop().</code> 的快捷方式. 连续按两次<code>Ctrl - C</code>, 或者 <code>Ctrl - C</code> 之后选 <code>q</code>, 是一样的效果。</li>
</ul>
<p>上面的两个例子展示了几个要点：</p>
<ul>
<li>Erlang 的每个语句都要用 <code>.</code> 结尾。</li>
<li>Erlang 是函数式语言，所有的函数、表达式都必须有一个返回值。输出 “hello world” 会返回一个 atom 类型的 <code>ok</code>。</li>
<li><code>Ctrl - C</code> 然后 <code>q</code> or <code>a</code>, 或者 <code>q().</code> 会退出 shell，如果你运行了代码的话，你的应用程序会连带着一起关掉。所以线上系统千万不要 <code>Ctrl - C</code>。</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Erlang 里用 % 来做行注释，相当于C语言里的 //, 或者Python里的 #。 没有块注释。</p>
<pre><code class="hljs erlang"><span class="hljs-comment">% I am a comment</span>
<span class="hljs-function"><span class="hljs-title">test_fuc</span><span class="hljs-params">()</span> -&gt;</span>
   <span class="hljs-string">&quot;test&quot;</span>.</code></pre>

<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p><code>摘取自 learn-you-some-erlang，并为你们这些有经验的程序员删减和加工</code></p>
<h5 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h5><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> 2 + 15.</span>
17
<span class="hljs-meta">2&gt;</span><span class="bash"> 49 * 100.</span>
4900
<span class="hljs-meta">3&gt;</span><span class="bash"> 1892 - 1472.</span>
420
<span class="hljs-meta">4&gt;</span><span class="bash"> 5 / 2.   %% 最常用的浮点数除法</span>
2.5
<span class="hljs-meta">5&gt;</span><span class="bash"> 5 div 2.  %% div 是整除</span>
2
<span class="hljs-meta">6&gt;</span><span class="bash"> 5 rem 2.  %% rem 是取余运算</span>
1
...
<span class="hljs-meta">%</span><span class="bash">% 数字前面可以用 ‘<span class="hljs-comment">#’ 来标注其 ‘Base’</span></span>
<span class="hljs-meta">%</span><span class="bash">% 语法：Base<span class="hljs-comment">#Value</span></span>
<span class="hljs-meta">%</span><span class="bash">% 默认的 Base 是 10</span> 
...
<span class="hljs-meta">10&gt;</span><span class="bash"> 2<span class="hljs-comment">#101010.  %% 2 进制的 101010</span></span>
42
<span class="hljs-meta">11&gt;</span><span class="bash"> 8<span class="hljs-comment">#0677.  %% 8 进制的 0677</span></span>
447
<span class="hljs-meta">12&gt;</span><span class="bash"> 16<span class="hljs-comment">#AE.   %% 16 进制的 AE</span></span>
174</code></pre>

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>Erlang 是函数式语言(虽然也支持副作用)。这意味着 Erlang 里的变量 ‘ <strong>Immutable</strong>’ (不可变的).<br>Immutable variables 在设计上简单，减少了并发过程中处理状态改变带来的复杂性。理解这一点很重要。</p>
<p>Erlang 是动态类型的语言，但它也是强类型的语言。动态类型意味着你声明变量时不需要指定类型，而强类型是说，erlang 不会偷偷做类型转换:</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> 6 + <span class="hljs-string">&quot;1&quot;</span>.</span>
** exception error: bad argument in an arithmetic expression
in operator  +/2
called as 6 + &quot;1&quot;</code></pre>

<p>Erlang 里变量的命名有约定，必须首字母大写。因为首字母小写的，会被认为是 <code>atom</code> (原子) 类型。<br><code>这一点在 elixir 里有改进</code></p>
<p>正常的变量命名比如 Hello, Test. 而像 hello, test 这种的不是变量名，他们是 <code>atom</code> 类型，跟数字、字符串一样，是值类型：</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Hello = <span class="hljs-string">&quot;hello?&quot;</span>.</span>
&quot;hello?&quot;
<span class="hljs-meta">2&gt;</span><span class="bash"> Test = <span class="hljs-string">&quot;testing words&quot;</span>.</span>
&quot;testing words&quot;
<span class="hljs-meta">3&gt;</span><span class="bash"> hello.</span>
hello
<span class="hljs-meta">4&gt;</span><span class="bash"> V1 = hello.  %% <span class="hljs-built_in">bind</span> atom hello to V1</span>
hello
<span class="hljs-meta">5&gt;</span><span class="bash"> V1.</span>
hello</code></pre>

<p>Erlang 里没有赋值语句。<code>=</code> 在 Erlang 里是 <code>pattern matching</code> (匹配、模式匹配)，如果 <code>=</code> 左侧跟右侧的值不相等，就叫没匹配上，这时那个 erlang 进程会直接异常崩溃(不要害怕，erlang 里面崩溃挺正常的)。如果 <code>=</code> 左侧的变量还没有值，这次匹配过后，右侧的值就会 <code>bind</code> (绑定) 到那个变量上。</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> One.     %% 变量没绑定，不能使用。所以这里出错了。</span>
* 1: variable &#x27;One&#x27; is unbound
<span class="hljs-meta">2&gt;</span><span class="bash"> One = 1.   %% 匹配变量 One 与 1. 由于One 之前没有绑定过值，这里将 Number 1 绑定给 One</span>
1
<span class="hljs-meta">3&gt;</span><span class="bash"> Un = Uno = One = 1.</span>  
<span class="hljs-meta">%</span><span class="bash">% 1) 匹配 Un, Uno, One 和 1. One 的值是 1, 所以最右侧的 One = 1 匹配成功，匹配操作返回值是 1.</span> 
<span class="hljs-meta">%</span><span class="bash">% 2) 然后继续与左边的 Uno 匹配。 Uno 之前没有绑定过值，所以将 1 绑定给 Uno，匹配操作返回值也是 1.</span>  
<span class="hljs-meta">%</span><span class="bash">% 3) 同理 Un 也被绑定为 1. 返回值也是 1.</span>
1
<span class="hljs-meta">4&gt;</span><span class="bash"> Two = One + One. %% Two 这时候被绑定为 2.</span>
2
<span class="hljs-meta">5&gt;</span><span class="bash"> Two = 2.    %% 尝试匹配 2 = 2. 成功并返回 2.</span>
2
<span class="hljs-meta">6&gt;</span><span class="bash"> Two = Two + 1.  %% 尝试匹配 2 = 3. 失败了，所以当前的 erlang shell 进程崩溃了，然后又自动给你启动了一个新的 erlang shell。</span>
** exception error: no match of right hand side value 3
<span class="hljs-meta">7&gt;</span><span class="bash"> two = 2.  %% 尝试匹配一个 atom 和一个数字: two = 2. 匹配, 失败崩溃了。</span>
** exception error: no match of right hand side value 2
<span class="hljs-meta">8&gt;</span><span class="bash"> _ = 14+3.  %% 下划线 _ 是个特殊保留字，表示 <span class="hljs-string">&quot;ignore&quot;</span>，可以匹配任何值。</span>
17
<span class="hljs-meta">9&gt;</span><span class="bash"> _.</span>
* 1: variable &#x27;_&#x27; is unbound
<span class="hljs-meta">10&gt;</span><span class="bash"> _Ignore = 2.  %% 以下划线开头的变量跟普通的变量作用没有什么区别，只不过在代码中，以下滑线开头的变量告诉编译器，<span class="hljs-string">&quot;如果这个变量后面我没用到的话，也不要警告我!&quot;</span></span>
2
<span class="hljs-meta">11&gt;</span><span class="bash"> _Ignore.</span>
2 
<span class="hljs-meta">12&gt;</span><span class="bash"> _Ignore = 3.</span>
** exception error: no match of right hand side value 3</code></pre>

<h5 id="Atoms"><a href="#Atoms" class="headerlink" title="Atoms"></a>Atoms</h5><p>上面已经提到过了，Erlang 里面有 <code>atom</code> 类型，atom 类型使用的内存很小，所以常用来做函数的参数和返回值。参加 pattern matching 的时候，运算也非常快速。<br>在其他没有 atom 的语言里，你可能用过 <code>constant</code> 之类的东西，一个常量需要对应一个数字值或者其他类型的值。比如：</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> red = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> green = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> blue = <span class="hljs-number">3</span>;</code></pre>
<p>但多了这个映射，其实用起来不大方便，后面对应的值 1， 2，3 一般只是用来比较，具体是什么值都关系不大。所以有了 <code>atom</code> 就很方便了，我们从字面上就能看出，这个值是干嘛的:</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> red.</span>
red</code></pre>

<p><code>atom</code> 类型支持的写法：</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> atom.</span>
atom
<span class="hljs-meta">2&gt;</span><span class="bash"> atoms_rule.</span>
atoms_rule
<span class="hljs-meta">3&gt;</span><span class="bash"> atoms_rule@erlang.</span>
atoms_rule@erlang
<span class="hljs-meta">4&gt;</span><span class="bash"> <span class="hljs-string">&#x27;Atoms can be cheated!&#x27;</span>.  %% 包含空格等特殊字符的 atom 需要用单引号括起来</span>
&#x27;Atoms can be cheated!&#x27;
<span class="hljs-meta">5&gt;</span><span class="bash"> atom = <span class="hljs-string">&#x27;atom&#x27;</span>.</span>
atom</code></pre>
<p><strong>需要注意的是</strong>：在一个 erlang vm 里，可创建的 atom 的数量是有限制的(默认是 1,048,576 )，因为erlang 虚拟机创建 atom 表也是需要内存的。一旦创建了某个 atom，它就一直存在那里了，不会被垃圾回收。不要在代码里动态的做 string -&gt; atom 的类型转换，这样最终会使你的 erlang atom 爆表。比如在你的接口逻辑处理的部分做 to atom 的转换的话，别人只需要用不一样的参数不停地调用你的接口，就可以攻击你。</p>
<h5 id="Boolean-以及比较"><a href="#Boolean-以及比较" class="headerlink" title="Boolean 以及比较"></a>Boolean 以及比较</h5><p><code>atom</code> 类型的 <code>true</code> 和 <code>false</code> 两个值，被用作布尔处理。</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> <span class="hljs-literal">true</span> and <span class="hljs-literal">false</span>.     %% 逻辑 并</span>
false
<span class="hljs-meta">2&gt;</span><span class="bash"> <span class="hljs-literal">false</span> or <span class="hljs-literal">true</span>.     %% 逻辑 或</span>
true
<span class="hljs-meta">3&gt;</span><span class="bash"> <span class="hljs-literal">true</span> xor <span class="hljs-literal">false</span>.     %% 逻辑 异或</span>
true
<span class="hljs-meta">4&gt;</span><span class="bash"> not <span class="hljs-literal">false</span>.     %% 逻辑 非</span>
true
<span class="hljs-meta">5&gt;</span><span class="bash"> not (<span class="hljs-literal">true</span> and <span class="hljs-literal">true</span>).</span>
false</code></pre>
<p>还有两个与 <code>and</code> 和 <code>or</code> 类似的操作：<code>andalso</code> 和 <code>orelse</code>。区别是 <code>and</code> 和 <code>or</code> 不论左边的运算结果是真还是假，都会执行右边的操作。而 <code>andalso</code> 和 <code>orelse</code>是短路的，意味着右边的运算不一定会执行。</p>
<p>来看一下比较：</p>
<pre><code class="hljs shell"><span class="hljs-meta">6&gt;</span><span class="bash"> 5 =:= 5.    %% =:= 是<span class="hljs-string">&quot;严格相等&quot;</span>运算符，== <span class="hljs-string">&quot;是大概相等&quot;</span></span>
true
<span class="hljs-meta">7&gt;</span><span class="bash"> 1 =:= 0.</span>
false
<span class="hljs-meta">8&gt;</span><span class="bash"> 1 =/= 0.   %%  =/= 是<span class="hljs-string">&quot;严格不等&quot;</span>运算符，/= <span class="hljs-string">&quot;是相差很多&quot;</span></span>
true
<span class="hljs-meta">9&gt;</span><span class="bash"> 5 =:= 5.0.</span>
false
<span class="hljs-meta">10&gt;</span><span class="bash"> 5 == 5.0.</span>
true
<span class="hljs-meta">11&gt;</span><span class="bash"> 5 /= 5.0.</span>
false</code></pre>
<p>一般如果懒得纠结太多，用 =:= 和 =/= 就可以了。</p>
<pre><code class="hljs shell"><span class="hljs-meta">12&gt;</span><span class="bash"> 1 &lt; 2.</span>
true
<span class="hljs-meta">13&gt;</span><span class="bash"> 1 &lt; 1.</span>
false
<span class="hljs-meta">14&gt;</span><span class="bash"> 1 &gt;= 1.      %% 大于等于</span>
true
<span class="hljs-meta">15&gt;</span><span class="bash"> 1 =&lt; 1.      %% 注意这个 <span class="hljs-string">&quot;小于等于&quot;</span> 的写法，= 在前面。因为 =&gt; 还有其他的用处。。</span>
true
<span class="hljs-meta">17&gt;</span><span class="bash"> 0 == <span class="hljs-literal">false</span>.  %% 数字和 atom 类型是不相等的</span>
false
<span class="hljs-meta">18&gt;</span><span class="bash"> 1 &lt; <span class="hljs-literal">false</span>.</span>  
true</code></pre>
<p>虽然不同的类型之间可以比较，也有个对应的顺序，但一般情况用不到的:<br><code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</code></p>
<h5 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h5><p><code>Tuple</code> 类型是多个不同类型的值组合成的类型。有点类似于 C 语言里的 <code>struct</code>。<br>语法是：<code>&#123;Element1, Element2, ..., ElementN&#125;</code></p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> X = 10, Y = 4.</span>
4
<span class="hljs-meta">2&gt;</span><span class="bash"> Point = &#123;X,Y&#125;.  %% Point 是个 Tuple 类型，包含了两个整形的变量 X 和 Y</span>
&#123;10,4&#125;</code></pre>
<p>实践中，我们经常 在 tuple 的第一个值放一个 atom 类型，来标注这个 tuple 的含义。这种叫做 tagged tuple: </p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Data1 = &#123;point, 1, 2&#125;.</span>
&#123;point,1,2&#125;
<span class="hljs-meta">2&gt;</span><span class="bash"> Data2 = &#123;rectangle, 20, 30&#125;.</span>
&#123;rectangle,20,30&#125;</code></pre>
<p>后面的代码如果要处理 Data1 和 Data2 的话，只需要检查 tuple 的第一项，就知道这个 tuple 是个点坐标，还是个矩形:</p>
<pre><code class="hljs shell"><span class="hljs-meta">3&gt;</span><span class="bash"> <span class="hljs-keyword">case</span> Data1 of</span>
<span class="hljs-meta">3&gt;</span><span class="bash">   &#123;point, X, Y&#125; -&gt; <span class="hljs-string">&quot;this is a point&quot;</span>;</span>
<span class="hljs-meta">3&gt;</span><span class="bash">   &#123;rectangle, Length, Width&#125; -&gt; <span class="hljs-string">&quot;this is a rectangle&quot;</span></span>
<span class="hljs-meta">3&gt;</span><span class="bash"> end.</span>
&quot;this is a point&quot;</code></pre>
<p>上面用 <code>case</code> 做 pattern matching ，这个后面还要讲。</p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><code>List</code> 就是我们经常说的链表，数据结构里学的那个。但 List 类型在 Erlang 里使用极其频繁，因为用起来很方便。</p>
<p><code>List</code> 可以包含各种类型的值:</p>
<pre><code class="hljs erlang-repl"><span class="hljs-meta">1&gt; </span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, &#123;numbers,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;, <span class="hljs-number">5.34</span>, atom].
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,&#123;numbers,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;,<span class="hljs-number">5.34</span>,atom]</code></pre>
<p>上面这个 list 包含了数字类型 1，2，3，一个 tuple，一个浮点数，一个 atom 类型。</p>
<p>来看看这个：</p>
<pre><code class="hljs erlang-repl"><span class="hljs-meta">2&gt; </span>[<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>].
<span class="hljs-string">&quot;abc&quot;</span></code></pre>
<p>卧槽这什么意思？！因为 Erlang 的 String 类型其实就是 List！所以 erlang shell 自动给你显示出来了。<br>就是说如果你这么写 <code>&quot;abc&quot;</code>, 跟 <code>[97, 98, 99]</code> 是等效的。<br>链表存储空间还是比纯字符串数组大的，拼接等操作也费时，所以一般如果你想用 ‘真 · 字符串’ 的时候，用 Erlang 的 <code>Binary</code> 类型，这样写：<code>&lt;&lt;&quot;abc&quot;&gt;&gt;</code>。这样内存消耗就小很多了。Binary 这是后话了，这篇文章里不介绍。</p>
<p>我知道一开始你可能不大明白 tuple 跟 list 的区别，这样吧：</p>
<ul>
<li>当你知道你的数据结构有多少项的时候，用 <code>Tuple</code>；</li>
<li>当你需要动态长度的数据结构时，用 <code>List</code>。</li>
</ul>
<p><strong>List 处理:</strong></p>
<pre><code class="hljs shell"><span class="hljs-meta">5&gt;</span><span class="bash"> [1,2,3] ++ [4,5].       %% ++ 运算符是往左边的那个 List 尾部追加右边的 List。</span>
<span class="hljs-meta">%</span><span class="bash">% 这样挺耗时的。链表嘛你知道的，往链表尾部追加，需要先遍历这个链表，找到链表的尾部。</span>
<span class="hljs-meta">%</span><span class="bash">% 所以 <span class="hljs-string">&quot;abc&quot;</span> ++ <span class="hljs-string">&quot;de&quot;</span> 这种的操作的复杂度，取决于前面 <span class="hljs-string">&quot;abc&quot;</span> 的长度。</span>
[1,2,3,4,5]
<span class="hljs-meta">6&gt;</span><span class="bash"> [1,2,3,4,5] -- [1,2,3].  %% -- 是移除操作符。</span>
[4,5]
<span class="hljs-meta">7&gt;</span><span class="bash"> [2,4,2] -- [2,4].</span>
[2]
<span class="hljs-meta">8&gt;</span><span class="bash"> [2,4,2] -- [2,4,2].</span>
[]
<span class="hljs-meta">9&gt;</span><span class="bash"> [] -- [1, 3].   %% 如果左边的 List 里不包含需要移除的值，也没事儿。不要拿这种东西来做面试题，这样会没朋友的。</span>
[]
<span class="hljs-meta">11&gt;</span><span class="bash"> hd([1,2,3,4]).</span>  
1
<span class="hljs-meta">12&gt;</span><span class="bash"> tl([1,2,3,4]).</span>
[2,3,4]</code></pre>
<p>上面 hd/1 是取 Head 函数。tl/1 是取 Tail. 这俩都是 BIF (Built-In-Function)，就是 Erlang 内置函数.<br>第一行里你也看到了，List 的追加操作会有性能损耗 (lists:append/2 跟 ++ 是一回事儿)，所以我们需要一个从头部插入 List 的操作: </p>
<pre><code class="hljs shell"><span class="hljs-meta">13&gt;</span><span class="bash"> List = [2,3,4].</span>
[2,3,4]
<span class="hljs-meta">14&gt;</span><span class="bash"> NewList = [1|List].   %% 注意这个 | 的左边应该放元素，右边应该放 List。</span>
[1,2,3,4]
<span class="hljs-meta">15&gt;</span><span class="bash"> [1, 2 | [0]].   %% 左边元素有好几个的话，erlang 会帮你一个一个的插到头部。先插 2，后插1.</span>
[1,2,0]
<span class="hljs-meta">16&gt;</span><span class="bash"> [1, 2 | 0].     %%  右边放的不是 List，这种叫 <span class="hljs-string">&#x27;improper list&#x27;</span>。</span>
<span class="hljs-meta">%</span><span class="bash">% 虽然你可以生成这种列表，但不要这么做，代码里出现这种一般就是个 bug。忘了这种用法吧。</span>
[1,2|0]
<span class="hljs-meta"></span>
<span class="hljs-meta">20&gt;</span><span class="bash"> [1 | []].       %% List 可以分解为 [ 第一个元素 | 剩下的 List ]。仔细看一下这几行体会一下。</span>
[1]
<span class="hljs-meta">21&gt;</span><span class="bash"> [2 | [1 | []]].</span>
[2,1]
<span class="hljs-meta">22&gt;</span><span class="bash"> [3 | [2 | [1 | []] ] ].</span>
[3,2,1]</code></pre>

<h5 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h5><p>实践中我们经常会从一个 List 中，取出我们需要的那些元素，然后做处理，最后再将处理过的元素重新构造成一个新的元素。<br>你马上就想到了 map，reduce。在 Erlang 里，我们可以用  List Comprehensions 语法，很方便的做一些简单的处理。</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> [2*N || N &lt;- [1,2,3,4]].   %% 取出  [1,2,3,4] 中的每个元素，然后乘2，返回值再组成一个新的 List</span>
[2,4,6,8]
<span class="hljs-meta">2&gt;</span><span class="bash"> [X || X &lt;- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].   %% 取出右边列表里所有偶数。</span>
[2,4,6,8,10]</code></pre>

<h5 id="Anonymous-functions"><a href="#Anonymous-functions" class="headerlink" title="Anonymous functions"></a>Anonymous functions</h5><p>让我们定义一个函数：</p>
<pre><code class="hljs shell">Add = fun (A, B) -&gt; A + B end.</code></pre>
<p>上面的代码里，我们用 fun() 定义了一个 匿名函数, 接收两个参数，并将两个参数的和作为返回值。<br>最后将这个函数 bind 到 Add 变量:</p>
<pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Add = fun (A, B) -&gt; A + B end.</span>
<span class="hljs-meta">#</span><span class="bash">Fun&lt;erl_eval.12.118419387&gt;</span>
<span class="hljs-meta">2&gt;</span><span class="bash"> Add(1, 2).</span>
3</code></pre>

<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>本章代码在：<a target="_blank" rel="noopener" href="https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/modules">https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/modules</a></p>
<p>Erlang Shell 是一个快速尝试新想法的地方，但我们真正的代码是要写到文件里，然后参与编译的。</p>
<p>Erlang 里代码是用 Module 组织的。一个 Module 包含了一组功能相近的函数。<br>用一个函数的时候，要这么调用：<code>Module:Function(arg1, arg2)</code>。<br>或者你先 <code>import</code> 某个 Module 里的函数，然后用省略Module名的方式调用：<code>Function(arg1, arg2)</code>。</p>
<p>Module 可也提供代码管理的作用，加载一个 Module 到 Erlang VM就加载了那个 Module 里的所有代码，然后你想热更新代码的话，直接更新这个 Module 就行了。</p>
<p>来看 Erlang 自带的几个 Module：</p>
<pre><code class="hljs erlang-repl"><span class="hljs-meta">1&gt; </span>erlang:element(<span class="hljs-number">2</span>, &#123;a,b,c&#125;).
b
<span class="hljs-meta">2&gt; </span>element(<span class="hljs-number">2</span>, &#123;a,b,c&#125;).
b
<span class="hljs-meta">3&gt; </span>lists:seq(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>).
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
<span class="hljs-meta">4&gt; </span>seq(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>).
** exception error: undefined shell command seq/<span class="hljs-number">2</span></code></pre>
<p>上面的例子里，你能直接用 <code>erlang</code> Module 里的 element/2 函数，是因为 erlang 里的常用函数会被 潜在的 <code>import</code> 过来。其他的 Module 比如 lists 不会.</p>
<p><code>erlang</code> module 里的函数叫做 <code>BIF</code>.</p>
<p><strong>使用 Module 写 functions:</strong><br>建立一个名为 useless.erl 的文件。<br>在文件的第一行, 用 -module(useless) 来声明你的 module name。注意跟 java 类似，module 名要跟文件名一样。<br>然后你在你的 module 里写你的函数：</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(useless)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([add/<span class="hljs-number">2</span>, add/<span class="hljs-number">3</span>])</span>. <span class="hljs-comment">%% export 是导出语法，指定导出 add/2, add/3 函数。没导出的函数在 Module 外是无法访问的。</span>

<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> -&gt;</span>
  A + B.
<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B, C)</span> -&gt;</span>
  A + B + C.</code></pre>
<p>然后你用 erlc 编译</p>
<pre><code class="hljs shell">mkdir -p ./ebin
erlc -o ebin useless.erl</code></pre>

<p>编译后的 beam 文件会在 ebin 目录下，然后你启动 erlang shell：</p>
<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ./ebin</span>
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> useless:add(1, 2).</span>
3
<span class="hljs-meta">2&gt;</span><span class="bash"> useless:add(1, 2, 1).</span>
4</code></pre>

<p>erl -pa 参数的意思是 <code>Path Add</code>, 添加目录到 erlang 的 beam 文件查找目录列表里。<br>就是说，你运行  useless:add(1, 2). 的时候，erlang 发现 module ‘useless’ 没加载，就在那些查找目录里找 useless.beam，然后加载进来。</p>
<p>Erlang 里面函数是用 函数名/参数个数来表示的，如果两个函数的函数名与参数个数都一样，他们就是一个函数的两个分支，必须写在一起，分支之间用分号分割。<br>上面的 add(A, B) 可以叫做 add/2, 而 add(A, B, C) 函数叫做 add/3. 注意这个 add/3和 add/2 因为参数个数不一样，所以被认为两个不同的函数，即使他们的函数名是一样的。<br>所以，第一个函数用 <code>.</code> 结尾。如果是一个函数的多个 clause, 是要用 <code>;</code> 分割的：</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(clauses)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([add/<span class="hljs-number">2</span>])</span>.

<span class="hljs-comment">%% goes into this clause when both A and B are numbers</span>
<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_number</span><span class="hljs-params">(A)</span>, <span class="hljs-title">is_number</span><span class="hljs-params">(B)</span> -&gt;</span>
  A + B;
<span class="hljs-comment">%% goes this clause when both A and B are lists</span>
<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_list</span><span class="hljs-params">(A)</span>, <span class="hljs-title">is_list</span><span class="hljs-params">(B)</span> -&gt;</span>
  A ++ B.
<span class="hljs-comment">%% crashes when no above clauses matched.</span></code></pre>
<p>上面代码里，定义了一个函数：add/2. 这个函数有两个 clause 分支，一个是计算数字相加的，一个是计算字符串相加的。<br>代码里 <code>when</code> 是一个 <code>Guard</code> 关键字。<code>Pattern Matching</code> 和 <code>Guard</code> 后面讲解。<br>运行 add/2 时会从上往下挨个匹配：</p>
<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> clauses:add(<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-string">&quot;DEF&quot;</span>).  %% 第一个 clause 没匹配上。走的是第二个 clause。</span>
&quot;ABCDEF&quot;
<span class="hljs-meta">2&gt;</span><span class="bash"> clauses:add(1, 2).  %% 走第一个 clause</span>
3
<span class="hljs-meta">3&gt;</span><span class="bash"> clauses:add(1, 2.4).</span>
3.4
<span class="hljs-meta">4&gt;</span><span class="bash"> clauses:add(1, <span class="hljs-string">&quot;no&quot;</span>).  %% 两个 clause 都没匹配上，崩溃了。</span>
** exception error: no function clause matching clauses:add(1,&quot;no&quot;) (clauses.erl, line 4)</code></pre>


<h3 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h3><h5 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h5><p>Erlang 里到处都用匹配的。</p>
<p><strong>1. case clauses</strong><br>下面的代码里，我们定义了一个 greet/2 函数</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(case_matching)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([greet/<span class="hljs-number">2</span>])</span>.

<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(Gender, Name)</span> -&gt;</span>
  <span class="hljs-keyword">case</span> Gender <span class="hljs-keyword">of</span>
    male -&gt;
      io:format(<span class="hljs-string">&quot;Hello, Mr. ~s!~n&quot;</span>, [Name]);
    female -&gt;
      io:format(<span class="hljs-string">&quot;Hello, Mrs. ~s!~n&quot;</span>, [Name]);
    _ -&gt;
      io:format(<span class="hljs-string">&quot;Hello, ~s!~n&quot;</span>, [Name])
  <span class="hljs-keyword">end</span>.</code></pre>
<p>case 的各个分支是自上往下依次匹配的，如果 Gender 是 atom ‘male’, 则走第一个，如果是 ‘female’ 走第二个，如果上面两个都没匹配上，则走第三个。</p>
<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> case_matching:greet(male, <span class="hljs-string">&quot;Shawn&quot;</span>).</span>
Hello, Mr. Shawn!
ok</code></pre>

<p><strong>2. function clauses</strong><br>我们把上面的例子改一下，让代码更规整一点：</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(function_matching)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([greet/<span class="hljs-number">2</span>])</span>.

<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(male, Name)</span> -&gt;</span>
  io:format(<span class="hljs-string">&quot;Hello, Mr. ~s!~n&quot;</span>, [Name]);
<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(female, Name)</span> -&gt;</span>
  io:format(<span class="hljs-string">&quot;Hello, Mrs. ~s!~n&quot;</span>, [Name]);
<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(_, Name)</span> -&gt;</span>
  io:format(<span class="hljs-string">&quot;Hello, ~s!~n&quot;</span>, [Name]).</code></pre>
<p>这个 function 有三个 clause，与 case 一样，自上往下依次匹配。</p>
<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> function_matching:greet(female, <span class="hljs-string">&quot;Scarlett&quot;</span>).</span>
Hello, Mrs. Scarlett!
ok
<span class="hljs-meta">2&gt;</span></code></pre>

<h5 id="在匹配中获取值"><a href="#在匹配中获取值" class="headerlink" title="在匹配中获取值"></a>在匹配中获取值</h5><pre><code class="hljs shell"><span class="hljs-meta">3&gt;</span><span class="bash"> &#123;X, 1, 5&#125; = &#123;2, 1, 5&#125;.     %% 如果匹配成功的话，将对应的值 <span class="hljs-built_in">bind</span> 到 X 上。</span>
&#123;2,1,5&#125;
<span class="hljs-meta">4&gt;</span><span class="bash"> X.</span> 
2
<span class="hljs-meta">5&gt;</span><span class="bash"> [H | T] = [1, 2, 3].       %% 现在我们使用匹配来解析 List，将第一个元素绑定到 H, 将其余绑定到 T。</span>
[1,2,3]
<span class="hljs-meta">6&gt;</span><span class="bash"> H.</span>
1
<span class="hljs-meta">7&gt;</span><span class="bash"> T.</span>
[2,3]
<span class="hljs-meta"></span>
<span class="hljs-meta">8&gt;</span><span class="bash"> [_ | T2] = T.      %% 我可以一直这么做下去</span>
[2,3]
<span class="hljs-meta">9&gt;</span><span class="bash"> T2.</span>
[3]
<span class="hljs-meta">10&gt;</span><span class="bash"> [_ | T3] = T2.    %% 再来</span>
[3]
<span class="hljs-meta">11&gt;</span><span class="bash"> T3.</span>
[]
<span class="hljs-meta">12&gt;</span><span class="bash"> f().              %% Erlang 里面变量是 immutable 的，所以我们现在解绑一下所有变量，清理之前用过的变量名。</span>
ok
<span class="hljs-meta">13&gt;</span><span class="bash"> Add = fun(&#123;A, B&#125;) -&gt; A + B end.  %% 我们重新定义了 Add 函数，现在它只接收一个 tuple 参数</span>
<span class="hljs-meta">%</span><span class="bash">% 然后在参数列表里我们做了 pattern matching 以获取 tuple 中的两个值，解析到 A，B.</span>
<span class="hljs-meta">#</span><span class="bash">Fun&lt;erl_eval.6.118419387&gt;</span>
<span class="hljs-meta">14&gt;</span><span class="bash"> Add(&#123;1, 2&#125;).</span>   
3</code></pre>

<p>好了，就问你厉不厉害？</p>
<h5 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h5><p>前面有用过 <code>when</code>, 提到过 guards. 现在我们来认真讨论它：<br>learn-you-some-erlang 的作者那边 16岁才能”开车” (笑). 那我们写个函数判断一下，某个人能不能开车？</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;
...
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">14</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(_)</span> -&gt;</span> <span class="hljs-literal">true</span>.</code></pre>
<p>上面这个又点太繁琐了，所以我们得另想办法：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16 -&gt;</span> <span class="hljs-literal">true</span>;
<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(_)</span> -&gt;</span> <span class="hljs-literal">false</span>.</code></pre>
<p>然后作者又说了，超过 104 岁的人，禁止开车：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16, X =&lt; 104 -&gt;</span>   <span class="hljs-comment">%% 注意这里用了逗号，表示 and</span>
   <span class="hljs-literal">true</span>;
<span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(_)</span> -&gt;</span>
   <span class="hljs-literal">false</span>.</code></pre>
<p><code>when</code> 语句里，<code>,</code>表示 <code>and</code>, <code>;</code> 表示 <code>or</code>, 如果你想用短路运算符的话，用 <code>andalso</code> 和<code>orelse</code>,  这么写：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16 <span class="hljs-title">andalso</span> X =&lt; 104 -&gt;</span> <span class="hljs-literal">true</span>;</code></pre>

<h5 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h5><p>前面讲过 <code>tagged tuple</code>，但它用起来还不够方便，因为没有个名字，也不好访问其中的变量。<br>我们来定义一个好用点的 <code>tagged tuple</code>，Erlang 里就是<code>record</code>：</p>
<pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(records)</span>.
<span class="hljs-keyword">-export</span><span class="hljs-params">([get_user_name/<span class="hljs-number">1</span>,</span>
<span class="hljs-params">         get_user_phone/<span class="hljs-number">1</span>])</span>.

<span class="hljs-keyword">-record</span><span class="hljs-params">(user, &#123;</span>
<span class="hljs-params">  name,</span>
<span class="hljs-params">  phone</span>
<span class="hljs-params">&#125;)</span>.

<span class="hljs-function"><span class="hljs-title">get_user_name</span><span class="hljs-params">(#user&#123;name=Name&#125;)</span> -&gt;</span>
  Name.

<span class="hljs-function"><span class="hljs-title">get_user_phone</span><span class="hljs-params">(#user&#123;phone=Phone&#125;)</span> -&gt;</span>
  Phone.</code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl</span>
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V8.3  (abort with ^G)
<span class="hljs-meta">1&gt;</span><span class="bash"> c(records).   %% 这是编译 erlang 代码的另外一种办法。c/1 编译并加载 module。</span>
&#123;ok,records&#125;
<span class="hljs-meta">2&gt;</span><span class="bash"> rr(records).  %% 将 records module 中的所有 record 都加载到 erl shell 里。</span>
[user]
<span class="hljs-meta">4&gt;</span><span class="bash"> Shawn = <span class="hljs-comment">#user&#123;name = &lt;&lt;&quot;Shawn&quot;&gt;&gt;, phone = &lt;&lt;&quot;18253232321&quot;&gt;&gt;&#125;.</span></span>
<span class="hljs-meta">#</span><span class="bash">user&#123;name = &lt;&lt;<span class="hljs-string">&quot;Shawn&quot;</span>&gt;&gt;,phone = &lt;&lt;<span class="hljs-string">&quot;18253232321&quot;</span>&gt;&gt;&#125;</span>
<span class="hljs-meta">5&gt;</span><span class="bash"> records:get_user_phone(Shawn).</span>
&lt;&lt;&quot;18253232321&quot;&gt;&gt;
<span class="hljs-meta">6&gt;</span><span class="bash"> records:get_user_name(Shawn).</span>
&lt;&lt;&quot;Shawn&quot;&gt;&gt;
<span class="hljs-meta"></span>
<span class="hljs-meta">%</span><span class="bash">% record 其实就是个 tagged tuple, 第一个元素是 record 名字。</span>
<span class="hljs-meta">7&gt;</span><span class="bash"> records:get_user_name(&#123;user, &lt;&lt;<span class="hljs-string">&quot;Shawn&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;18253232321&quot;</span>&gt;&gt;&#125;).</span>
&lt;&lt;&quot;Shawn&quot;&gt;&gt;
<span class="hljs-meta"></span>
<span class="hljs-meta">9&gt;</span><span class="bash"> Shawn<span class="hljs-comment">#user.name.</span></span>
&lt;&lt;&quot;Shawn&quot;&gt;&gt;
<span class="hljs-meta">10&gt;</span><span class="bash"> <span class="hljs-comment">#user.name.</span></span>
2</code></pre>
<p>你看到 <code>#user&#123;&#125;</code> 其实只是一个第一个元素为 <code>user</code> 的 tagged tuple <code>&#123;user, name, phone&#125;</code>, 而 #user.name 是这个 tuple 里 <code>name</code> 字段的位置号 2。<br><code>注意: Erlang 里面的位置、Index 等都是约定从 1 开始的。</code></p>
<p> Shawn#user.name 的意思是取 Shawn 里的第 2 个元素。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Erlang 是函数式语言，变量 immutable 的，所以没有 while loop。因为不能让你定义一个递增的 counter 变量。<br>所以我们用递归来解决大多数问题。<br>先来一个计算 List 长度的函数：</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([])</span> -&gt;</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">%% 空列表的长度是 0</span>
<span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([_|T])</span> -&gt;</span> <span class="hljs-number">1</span> + len(T)   <span class="hljs-comment">%% 列表的长度，是 1 + 剩余列表的长度。</span></code></pre>

<p>简单吧？但是你知道的，这样子如果要计算的 List 长度太长的话，调用栈就特别长，会吃尽内存。计算过程是这样的:</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])</span> = <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">1</span> | [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])</span></span>
<span class="hljs-function">               = 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">2</span> | [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])</span></span>
<span class="hljs-function">               = 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">3</span> | [<span class="hljs-number">4</span>]])</span></span>
<span class="hljs-function">               = 1 + 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">4</span> | []])</span></span>
<span class="hljs-function">               = 1 + 1 + 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([])</span></span>
<span class="hljs-function">               = 1 + 1 + 1 + 1 + 0</span>
<span class="hljs-function">               = 1 + 1 + 1 + 1</span>
<span class="hljs-function">               = 1 + 1 + 2</span>
<span class="hljs-function">               = 1 + 3 </span>
<span class="hljs-function">               = 4</span></code></pre>

<p>所以我们必须用 <code>Tail Recursion</code> (尾递归) 来改写一下:</p>
<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(L)</span> -&gt;</span> len(L,<span class="hljs-number">0</span>).   <span class="hljs-comment">%% 这其实只是给 len/2 的第二个参数设置了一个默认值 0.</span>
 
<span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([], Acc)</span> -&gt;</span> Acc;  <span class="hljs-comment">%% 所有的元素都读完了</span>
<span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([_|T], Acc)</span> -&gt;</span> len(T,Acc+<span class="hljs-number">1</span>).  <span class="hljs-comment">%% 读一个元素，Acc 增1，然后计算剩下的 List 的长度。</span></code></pre>
<p>尾递归就是，最后一个语句是调用自身的那种递归。Erlang 遇到这总递归的时候，不会再保留调用栈。这样的递归相当于一个 while loop。</p>
<p>我们用 Acc 来记录每次计算的结果，读取一个元素 Acc 就增 1，一直到读取完所有的元素。</p>
<p>第一个例子里，第二个 clause 的最后一个调用是 <code>1 + len(T)</code> ，这不是尾递归。因为系统还要保留着调用栈，等其算出 len(T) 之后，再回来跟 1 做加法运算。只有 <code>len(T,Acc+1).</code> 这种才是。</p>
<p><strong>尾递归与递归的区别：</strong><br>有个比喻可以帮你理解他们的差异。<br>假设玩一个游戏，你需要去收集散落了一路，并通向远方的硬币。</p>
<p>于是你一个一个的捡，一边捡一边往前走，但是你必须往地上撒些纸条做记号，因为不做记号你就忘了回来的路。于是你一路走，一路捡，一路撒纸条。等你捡到最后一个硬币时，你开始沿着记号回来了，一路走，一路捡纸条(保护环境)。等回到出发点时，你把硬币装你包里，把纸条扔进垃圾桶。<br>这就是<strong>非尾递归</strong>，纸条就是你的调用栈，是内存记录。</p>
<p>下次再玩这个游戏时，你学聪明了，你直接背着包过去了，一路走，一路捡，一路往包里塞。等到了终点时，最后一个硬币进包了，任务完成了，你不回来了！<br>这就是<strong>尾递归</strong>，省去了调用栈的消耗。</p>
<p><strong>书接下文</strong>：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5b7e73576dcb">30 分钟学 Erlang (二)</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Erlang%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Erlang程序设计</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Erlang/">Erlang</a>
                    
                      <a class="hover-with-bg" href="/tags/OTP/">OTP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/01/16/clpqt1iub002e4cuecn2yhzoy.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">30分钟学Erlang (三)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/01/16/clpqt1iu800264cue8xx6dpnv.html">
                        <span class="hidden-mobile">30分钟学Erlang (一)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              <!-- Comments -->
              <div class="comments" id="comments">
                  <script src="https://utteranc.es/client.js"
                    repo="wwhai/gitalk"
                    issue-term="url"
                    label="[Utterances]"
                    theme="preferred-color-scheme"
                    crossorigin="anonymous"
                    async>
                  </script>
              </div>

          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "30分钟学Erlang (二)&nbsp;",
      ],
      cursorChar: "$>",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "#"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  










  <script  src="https://cdn.staticfile.org/mermaid/8.5.0/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?fe7a4b213463c7ca15598e31d7eabfd4";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>