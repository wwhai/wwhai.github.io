<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2018-2023—我的5年</title>
    <link href="/2023/12/03/clpqt1ivf006d4cue9w6oe6mt.html"/>
    <url>/2023/12/03/clpqt1ivf006d4cue9w6oe6mt.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2018-2023—我的5年</p><span id="more"></span><h2 id="我的5年"><a href="#我的5年" class="headerlink" title="我的5年"></a>我的5年</h2><p>2018年毕业以后从福州去了厦门，2018年秋天回福州波折了半年，2019年3月入职某研究院。研究院干了1年多，2020年6月去了杭州。2021年杭州没有久留，于是7月到了深圳，在深圳干了整整2年；2023年8月又回到了福州。<strong>离开的那天还是个青年，回来的时候白发都有了</strong>。</p><div style="font-size:120%; color: blue;"><p>时间如白驹过隙。</p><p>犹如薛定谔的时间理论忽然长忽然短。</p><p>5年时间长到当年的同学们好多都安居乐业，为人妻为人夫。</p><p>5年时间短到我的人生旅程还没结束，还在来往的火车上。</p><p>宛如南柯一梦。</p></div><object data="/pdf/2018_2023.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是个歌舞升平的好时代</title>
    <link href="/2023/11/23/clpqt1ivu00844cuecsxv6one.html"/>
    <url>/2023/11/23/clpqt1ivu00844cuecsxv6one.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：这是个歌舞升平的好时代。</p><span id="more"></span><hr><p><img src="/uploads/2023public/d1.png" alt="1700744057228"></p><div style="text-align:center;font-size:150%; color: blue;"><p>感谢我出生在那个百废俱兴的时代。</p><p>庆幸我没有在这个百兴俱废的时代。</p><p>这是个美好的时代。</p><div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋日桂花</title>
    <link href="/2023/11/05/clpqt1iw8009y4cueb95k66w9.html"/>
    <url>/2023/11/05/clpqt1iw8009y4cueb95k66w9.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：秋日桂花。</p><span id="more"></span><hr><p>这是一篇散文。</p><object data="/pdf/guihua.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoTHub简单设计</title>
    <link href="/2023/09/18/clpqt1iwf00ar4cuebbq0g15i.html"/>
    <url>/2023/09/18/clpqt1iwf00ar4cuebbq0g15i.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：曾经的一个简单的IotHUB平台设计，供给参考。</p><span id="more"></span><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>文章用PDF而作, 本页面如果没有开启PDF阅读器，需要用电脑浏览器才能访问。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个文档是大致方向思路文档，而不是具体的产品设计文档。因此有些东西没有细说，是个研发人员看的而不是给产品人员或者项目人员。其价值是提出了一些技术设计规范而非产品思路。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><object data="/pdf/IOTHUB-1.4.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tdengine简单实战</title>
    <link href="/2023/09/18/clpqt1iwf00an4cue7oewa4u5.html"/>
    <url>/2023/09/18/clpqt1iwf00an4cue7oewa4u5.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要是一次Tdengine实战的记录，供给参考。</p><span id="more"></span><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>文章用PDF而作, 本页面如果没有开启PDF阅读器，需要用电脑浏览器才能访问。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p><strong>很多人不理解Tdengine的超级表的用法，下面这个简单设计是我曾经用在真实项目中的，放出来给大家参考</strong></p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><object data="/pdf/TDEngine1.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>918纪念日：我辈当自强</title>
    <link href="/2023/09/18/clpqt1ivs007u4cueb6zy8zqp.html"/>
    <url>/2023/09/18/clpqt1ivs007u4cueb6zy8zqp.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我辈当自强。</p><span id="more"></span><h2 id="牢记耻辱，我辈当自强。"><a href="#牢记耻辱，我辈当自强。" class="headerlink" title="牢记耻辱，我辈当自强。"></a>牢记耻辱，我辈当自强。</h2><p><img src="/uploads/20230918/1.jpg" alt="2022"></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和一个小卖部老板的闲聊</title>
    <link href="/2023/08/14/clpqt1ivr007s4cueb6u07iy1.html"/>
    <url>/2023/08/14/clpqt1ivr007s4cueb6u07iy1.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：和一个小卖部老板的闲聊。</p><span id="more"></span><p><img src="/uploads/20230814/1.png" alt="1570850340262"></p><p>最近刚到新的地方，又开始了新的一轮置办家用。</p><p>不过有意思的是，某天晚上快十二点了，在村里一个小卖部卖杂碎的时候，遇到个健谈的老板，他说得一番话差点让我彻夜难眠。</p><p>晚上突然记起来还有点东西没买，出去到一个小卖部。老板是个中年男人，看起来约莫有40多岁，闲来无事就和他聊聊。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><ul><li>老板：你为啥走这么远来我们这里。</li><li>我：为了工作。</li><li>老板：你看起来是个大学生吧？</li><li>我：是的。</li><li>老板：我见过你们太多大学生了，都是出来打工或者工作的，我觉得大学就是白上，没有任何意义。</li><li>我：怎么能白上呢，大学学到了知识。</li><li>老板：学到有什么用，还不是赚不到钱。</li><li>我：上大学不一定能赚钱，学到知识可以帮我们认识这个世界，打开眼界。</li></ul><p>老板此时笑了，他拿起货架上一瓶水喝了一口继续开始</p><ul><li>老板：我说小伙子啊，你是真的书呆子。你读再多的书也没有我开小超市赚的钱多，读书的意义是给家里人好生活，你说的什么知识有什么用，你看看你跑到我们福建来工作，家里人都见不到，有知识的意义在哪里。</li><li>我：（此时不知怎么说）</li><li>老板：小伙子啊，年轻人就要多赚钱才能养家，书读太多了也不好，过多知道你本不应该知道的东西太多，会影响你的心态，当个普通人也好。</li></ul><hr><p>对话没有再继续，我买完东西就走了，我一路上在想：读书的意义在哪？我认为是获得了知识和万物之理能让人精神变得充裕，老板说的是要有钱给人以物质充裕。我久久思考不得解。夜晚我翻来覆去忽然明白：前者是以自我价值为中心，后者是自我附带价值，一个于公，一个于私，孰对孰错又是一个很难难的判定。</p><p><strong>到现在我突然觉得，还是赚钱好，一个人知道太多但是匹配不上驾驭这些知识能力的时候，他就会很痛苦，倒不如钱能给人直接带来快乐</strong></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和一个老同学的饭局</title>
    <link href="/2023/06/30/clpqt1ivt007y4cueg3x4fafi.html"/>
    <url>/2023/06/30/clpqt1ivt007y4cueg3x4fafi.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：和一个老同学的饭局。</p><span id="more"></span><div style="font-size:150%; color: blue;"><p>一个从2014年至今很久不见的同学叫我一起吃个饭，她是我复读那年的同桌，朝夕相处了一年，是同学也是战友。确实难得在离家2800公里之外的深圳能遇到同桌。</p><p>饭桌上聊得开心的时候她突然打断，问我叫啥名。</p><p>一瞬间气氛有点尴尬。</p><p>饭局结束后我就把她微信删了，估计也是当年的同学缘分到尽头了吧。</p></div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的大学：青少年时代经历</title>
    <link href="/2023/06/21/clpqt1ivw008d4cuechivd8yh.html"/>
    <url>/2023/06/21/clpqt1ivw008d4cuechivd8yh.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：大学期间的一些记录文整理.</p><span id="more"></span><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>文章用PDF而作, 本页面如果没有开启PDF阅读器，需要用电脑浏览器才能访问。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><object data="/pdf/daxueshidai.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期写的一些底层技术文章</title>
    <link href="/2023/05/24/clpqt1iun003p4cue5dxi0x16.html"/>
    <url>/2023/05/24/clpqt1iun003p4cue5dxi0x16.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 近期写的一些底层技术的文章。</p><span id="more"></span><hr><p><img src="/uploads/ai1/ai1.jpeg" alt="ai1"></p><h2 id="系列简介"><a href="#系列简介" class="headerlink" title="系列简介"></a>系列简介</h2><p>这里记录一些这段时间整理的AI学习过程，其中有几篇文章属于是小众领域的研究，希望能帮得上各位。本人不擅长搞AI，甚至可以认为是个完全不懂AI技术的人，文章都是些比较简单的基础操作。</p><p>关于AI那部分，我连个民科都算不上，仅仅是理解了一点点使用技巧而已。下面的文章主要围绕一些Matlab相关的使用，因此建议首先了解下Matlab。</p><h2 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h2><ul><li><p>Matlab工程化实践研究(一)<br><a href="https://p.kdocs.cn/s/PS7HGBAAHU">https://p.kdocs.cn/s/PS7HGBAAHU</a></p></li><li><p>Matlab工程化实践研究(二)<br><a href="https://p.kdocs.cn/s/MC7HGBAAHU">https://p.kdocs.cn/s/MC7HGBAAHU</a></p></li><li><p>针对软件工程师的人工智能入门导论（一）<br><a href="https://p.kdocs.cn/s/MM2IWBAAZY">https://p.kdocs.cn/s/MM2IWBAAZY</a></p></li><li><p>针对软件工程师的人工智能入门导论（二）<br><a href="https://p.kdocs.cn/s/OU2IWBAA5Y">https://p.kdocs.cn/s/OU2IWBAA5Y</a></p></li><li><p>AI生成文本，然后渲染画面<br><a href="https://p.kdocs.cn/s/PKJHIBAA2E">https://p.kdocs.cn/s/PKJHIBAA2E</a></p></li><li><p>在Windows上编译gocv<br><a href="https://p.kdocs.cn/s/SHGXWBAA3U">https://p.kdocs.cn/s/SHGXWBAA3U</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI初探</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI初探</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你多久没回家了</title>
    <link href="/2023/04/01/clpqt1ivt00814cue4poy3ic8.html"/>
    <url>/2023/04/01/clpqt1ivt00814cue4poy3ic8.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：你多久没回家了。</p><span id="more"></span><hr><div style="text-align:center;font-size:150%; color: blue;"><p>你多久没回家了？<br>我在外已经进入第十个年头了。</p><div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一支兰州</title>
    <link href="/2023/04/01/clpqt1ivv00864cue023j6jau.html"/>
    <url>/2023/04/01/clpqt1ivv00864cue023j6jau.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我终于理解我爸了，我终于理解我爸了。</p><span id="more"></span><h2 id="我终于理解我爸了。"><a href="#我终于理解我爸了。" class="headerlink" title="我终于理解我爸了。"></a>我终于理解我爸了。</h2><p><img src="/uploads/lanzhou/2.jpg" alt="兰州烟"></p><div style="text-align:center;font-size:150%; color: blue;">    记忆中从小到大，我爸都是个老烟枪    <br>    有时候和妈妈吵架是一包烟    <br>    有时候我考试不行了也是一包    <br>    有时候他一个人什么都不做    <br>    坐着一会儿一根也能抽一包烟    <br>    为此我埋怨了他二十多年    <br>    二十多年后我也为人父为人夫    <br>    直到今天我拿起兰州的时候    <br>    一瞬间就理解了我爸    <br>    爸爸今年53岁了，我再不会埋怨他    <br>    今年回家给他带两条好的    <br>    我今年29岁了才理解我爸。    <br></div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mosquitto 二次开发 (三)：Mosquitto Broker部分源码解析</title>
    <link href="/2023/03/25/clpqt1iul003k4cuea58r5tk3.html"/>
    <url>/2023/03/25/clpqt1iul003k4cuea58r5tk3.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wwhai] # 概要：本文主要讲解一下 Eclipse Mosquitto Broker 的插件开发技巧。</p><span id="more"></span><blockquote><p>今天是2023年3月25日，深圳下起了瓢泼大雨，每当在这种潮湿的雨天，我的心态就开始低落起来。为了避免无限陷入这种精神折磨，挣扎着从沙发上起来，写一篇文章来转移一下注意力。</p></blockquote><h2 id="Mosquitto-二次开发-三-：Mosquitto-Broker部分源码解析"><a href="#Mosquitto-二次开发-三-：Mosquitto-Broker部分源码解析" class="headerlink" title="Mosquitto 二次开发 (三)：Mosquitto Broker部分源码解析"></a>Mosquitto 二次开发 (三)：Mosquitto Broker部分源码解析</h2><p>本文主要分析一下Mosquitto的导出头文件里面的关键字段。Mosquitto的导出头文件是给用户开发者使用的，因此掌握关键数据结构还是很有必要。<br>Mosquitto包含了针对客户端开发的头文件<code>mosquitto.h</code>和针对服务端开发<code>mosquitto_broker.h</code>的头文件，前者一般用来开发本地客户端，后者用来开发服务器插件。我们常用的客户端源代码大多来自<code>mosquitto.h</code>。该源码可移植性强，甚至你能在嵌入式设备看到这个头文件,与之有同样功能的库是paho-mqtt:<a href="https://github.com/eclipse/paho.mqtt.c">https://github.com/eclipse/paho.mqtt.c</a>，可能后者用的更多点。在本文中不做全面解析，仅仅对用户角度而言常用的有些结构做个简要介绍。</p><h3 id="mosquitto-h-头文件"><a href="#mosquitto-h-头文件" class="headerlink" title="mosquitto.h 头文件"></a>mosquitto.h 头文件</h3><p>头文件源文件可以参考此处：<a href="https://github.com/wwhai/mosquitto/blob/master/include/mosquitto.h">https://github.com/wwhai/mosquitto/blob/master/include/mosquitto.h</a>。</p><p>我们首先来看看MQTT消息体结构体：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_message</span>&#123;</span><span class="hljs-keyword">int</span> mid;<span class="hljs-keyword">char</span> *topic;<span class="hljs-keyword">void</span> *payload;<span class="hljs-keyword">int</span> payloadlen;<span class="hljs-keyword">int</span> qos;<span class="hljs-keyword">bool</span> retain;&#125;;</code></pre><p>mosquitto_message 结构体是MQTT消息的结构化封装，包含了基本的MQTT属性，这些对于熟悉MQTT消息的人来说应该很熟悉，值得特别关注的是，<code>mid</code> 字段实际上是消息ID，这个ID在MQTT报文QOS为1和2的时候有效，0的时候无效，可以参考一下MQTT规范: <a href="http://stanford-clark.com/MQTT/#msg-id">http://stanford-clark.com/MQTT/#msg-id</a>。其他的字段就是比较常用的，不做赘述。</p><p>接下来分析客户端编程接口。我们在用Mosquitto库开发客户端的时候，会涉及到创建客户端，设置认证信息，订阅发布等，下面用一个官方案例<a href="https://github.com/wwhai/mosquitto/blob/master/examples/subscribe/basic-1.c">https://github.com/wwhai/mosquitto/blob/master/examples/subscribe/basic-1.c</a> 来分析一下客户端开发接口函数。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mosquitto.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">on_connect</span><span class="hljs-params">(struct mosquitto *mosq, <span class="hljs-keyword">void</span> *obj, <span class="hljs-keyword">int</span> reason_code)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> rc;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;on_connect: %s\n&quot;</span>, mosquitto_connack_string(reason_code));<span class="hljs-keyword">if</span>(reason_code != <span class="hljs-number">0</span>)&#123;mosquitto_disconnect(mosq);&#125;rc = mosquitto_subscribe(mosq, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;example/temperature&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span>(rc != MOSQ_ERR_SUCCESS)&#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error subscribing: %s\n&quot;</span>, mosquitto_strerror(rc));mosquitto_disconnect(mosq);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">on_subscribe</span><span class="hljs-params">(struct mosquitto *mosq, <span class="hljs-keyword">void</span> *obj, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> qos_count, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *granted_qos)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">bool</span> have_subscription = <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;qos_count; i++)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;on_subscribe: %d:granted qos = %d\n&quot;</span>, i, granted_qos[i]);<span class="hljs-keyword">if</span>(granted_qos[i] &lt;= <span class="hljs-number">2</span>)&#123;have_subscription = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">if</span>(have_subscription == <span class="hljs-literal">false</span>)&#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: All subscriptions rejected.\n&quot;</span>);mosquitto_disconnect(mosq);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">on_message</span><span class="hljs-params">(struct mosquitto *mosq, <span class="hljs-keyword">void</span> *obj, <span class="hljs-keyword">const</span> struct mosquitto_message *msg)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d %s\n&quot;</span>, msg-&gt;topic, msg-&gt;qos, (<span class="hljs-keyword">char</span> *)msg-&gt;payload);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto</span> *<span class="hljs-title">mosq</span>;</span><span class="hljs-keyword">int</span> rc;mosquitto_lib_init();mosq = mosquitto_new(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">if</span>(mosq == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: Out of memory.\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;mosquitto_connect_callback_set(mosq, on_connect);mosquitto_subscribe_callback_set(mosq, on_subscribe);mosquitto_message_callback_set(mosq, on_message);rc = mosquitto_connect(mosq, <span class="hljs-string">&quot;test.mosquitto.org&quot;</span>, <span class="hljs-number">1883</span>, <span class="hljs-number">60</span>);<span class="hljs-keyword">if</span>(rc != MOSQ_ERR_SUCCESS)&#123;mosquitto_destroy(mosq);<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error: %s\n&quot;</span>, mosquitto_strerror(rc));<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;mosquitto_loop_forever(mosq, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);mosquitto_lib_cleanup();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>首先就是<code>#include &lt;mosquitto.h&gt;</code>, 我们前面提到的客户端开发必须要包含该头文件。我们先从main开始看起，<code>mosquitto_lib_init()</code>是用来初始化Mosquitto的环境，这个是必须调用的。<code>mosquitto_new</code> 函数是用来生成一个客户端实例，需要注意一点：其返回值是一个指针。而    <code>mosquitto_connect_callback_set</code>、<code>mosquitto_subscribe_callback_set</code>、<code>mosquitto_message_callback_set</code> 三个函数就比较好识别，主要用来设置连接回调、订阅回调、消息到达回调。<code>mosquitto_connect</code> 函数用来和服务器建立连接，同时会用连接结果来回调 <code>mosquitto_connect_callback_set</code> 指定的函数，上面的案例中回调函数是<code>on_connect</code>。为了防止客户端退出，Mosquitto给出一个挂起函数 <code>mosquitto_loop_forever</code>，表示将进程挂起，防止退出。<br><code>mosquitto_destroy</code> 用来释放 mosquitto 客户端实例，<code>mosquitto_lib_cleanup</code> 用来释放系统库资源，其二者虽然都是释放资源，但是作用对象不同。</p><p>其他省下的回调函数理解起来就比较简单了,订阅某个Topic的时候会回调 <code>on_subscribe</code> , 第一个参数 <code>struct mosquitto *mosq</code> 便是客户端实例指针。</p><div class="note note-success">            <p>实际上对于上面的示例能理解，基本上就可以玩转 mosquitto客户端了，更多的细节可以参考其官方示例。</p>          </div><h3 id="mosquitto-plugin-h-头文件"><a href="#mosquitto-plugin-h-头文件" class="headerlink" title="mosquitto_plugin.h 头文件"></a>mosquitto_plugin.h 头文件</h3><p>mosquitto_plugin.h 头文件定义了插件的用户侧开发接口。在此之前我们说倒mosquitto支持两个版本的插件，但是目前我们只关注V5，因此此节只分析V5的插件接口。<br>一个插件有3个基本函数回调：</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> mosquitto_plugin_version<span class="hljs-keyword">int</span> mosquitto_plugin_init<span class="hljs-keyword">int</span> mosquitto_plugin_cleanup</code></pre><p>在第二节我们已经给出了其使用流程，再次不赘述，接下来我们关注回调如何注册。mosquitto 使用 <code>mosquitto_callback_register</code> 来注册回调，例如我们注册一个消息到达处理函数可以这么做：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">callback_message</span><span class="hljs-params">(<span class="hljs-keyword">int</span> event, <span class="hljs-keyword">void</span> *event_data, <span class="hljs-keyword">void</span> *userdata)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_evt_message</span> *<span class="hljs-title">ed</span> =</span> event_data;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_init</span><span class="hljs-params">(<span class="hljs-keyword">mosquitto_plugin_id_t</span> *identifier, <span class="hljs-keyword">void</span> **user_data, struct mosquitto_opt *opts, <span class="hljs-keyword">int</span> opt_count)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> mosquitto_callback_register(mosq_pid, MOSQ_EVT_MESSAGE, callback_message, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>当注册成功后，mosquitto收到消息会直接调用 <code>callback_message</code> 函数，我们可以在里面做一些操作，比如打印出来、或者保存到Mysql等。<br>函数原型可以参考此处：<a href="https://mosquitto.org/api/files/mosquitto_broker-h.html#mosquitto_callback_register">https://mosquitto.org/api/files/mosquitto_broker-h.html#mosquitto_callback_register</a>;<br>与之对应的卸载回调用 <code>mosquitto_callback_unregister</code> 函数，函数原型可以参考此处：<a href="https://mosquitto.org/api/files/mosquitto_broker-h.html#mosquitto_callback_unregister">https://mosquitto.org/api/files/mosquitto_broker-h.html#mosquitto_callback_register</a>。</p><h3 id="mosquitto-broker-h-头文件"><a href="#mosquitto-broker-h-头文件" class="headerlink" title="mosquitto_broker.h 头文件"></a>mosquitto_broker.h 头文件</h3><p>上面的 mosquitto.h 是给客户端使用的，与此相反 mosquitto_plugin.h 、mosquitto_broker.h 是 mosquitto 的内部接口，提供了 mosquitto broker 的一些核心结构，<strong>这些接口都不是给客户端使用的，而是为了开发服务端插件</strong>。 该头文件内部定义了用户可操作的范畴，也就是说用户能进行二次开发的建议修改接口，其他的不建议去修改，比如 src 目录下的源码等。不过也有特例就是一些集群组件是要深度定制。<br>我们注册函数回调以后，发现其回调数据是一个void指针（如果学过go，这里可以理解为interface{}，虽然完全不是一回事），这个指针到底是什么含义？Mosquitto用了一系列结构体族来表示,其格式如下所示：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mosquitto_evt_</span>* &#123;</span>    <span class="hljs-comment">// 一些字段</span>&#125;;</code></pre><p>上面的这个结构体实际上就是插件回调带进来的数据，比如你想针对客户端的publish消息做个处理，那么就需注册一个回调到 mosquitto 里面，当有消息来时，mosquitto会给你的接口传一个参数，这个参数就是 <code>mosquitto_evt_message</code> 结构体，以此类推，头文件里面那些结构体都实际上是回调数据。<br>mosquitto_broker.h 最核心的就是这些结构体族，剩下的都是一些辅助函数，比如申请内存，释放内存，获取客户端的一些属性等，可以通过查看其文档来熟练其操作。</p><div class="note note-warning">            <p>在开发过程中建议多参考其源码注释和官方文档：<a href="https://mosquitto.org/api/files/mosquitto-h.html">https://mosquitto.org/api/files/mosquitto-h.html</a>，其实注释已经很完善了。</p>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对插件的一些关键数据做了个引导指南，方便开发者快速上手。需要注意几个关键点：</p><ul><li>mosquitto.h 是专门针对客户端的接口</li><li>mosquitto_plugin.h mosquitto_broker.h 是专门针对插件开发的接口</li><li>mosquitto_plugin.h 是插件开发过程中用户侧的约束</li><li>mosquitto_broker.h 是插件开发过程中Broker侧的约束</li><li>mosquitto_evt_* 结构体族用来区分不同的回调消息体</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mosquitto二次开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mosquitto二次开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mosquitto 二次开发 (二)：Mosquitto Broker插件机制</title>
    <link href="/2023/03/25/clpqt1iuk003g4cuecdpl6dxk.html"/>
    <url>/2023/03/25/clpqt1iuk003g4cuecdpl6dxk.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wwhai] # 概要：本文主要讲解一下 Eclipse Mosquitto Broker 的插件开发技巧。</p><span id="more"></span><blockquote><p>今天是2023年3月25日，深圳下起了瓢泼大雨，每当在这种潮湿的雨天，我的心态就开始低落起来。为了避免无限陷入这种精神折磨，挣扎着从沙发上起来，写一篇文章来转移一下注意力。</p></blockquote><h2 id="Mosquitto-二次开发-二-：Mosquitto-Broker插件机制"><a href="#Mosquitto-二次开发-二-：Mosquitto-Broker插件机制" class="headerlink" title="Mosquitto 二次开发 (二)：Mosquitto Broker插件机制"></a>Mosquitto 二次开发 (二)：Mosquitto Broker插件机制</h2><p>Mosquitto提供了扩展机制，它原生支持用C语言来实现一些自己的插件，然后动态加载进Mosquitto运行时，极大的丰富了Mosquitto的功能，可以让我门在不改变Mosquitto本身的情况下实现自己的扩展功能。</p><h3 id="Eclipse-Mosquitto-Broker-插件机制概述"><a href="#Eclipse-Mosquitto-Broker-插件机制概述" class="headerlink" title="Eclipse Mosquitto Broker 插件机制概述"></a>Eclipse Mosquitto Broker 插件机制概述</h3><p>Mosquitto的插件本质上是个C语言的动态链接库（或者说就是个兼容POSIX规范的链接库），如果你熟悉C语言可以用 C语言来实现插件，同样你也可以用其他语言比如C++或者Pascal【<a href="https://macpgmr.github.io/MacXPlatform/PascalDynLibs.html">https://macpgmr.github.io/MacXPlatform/PascalDynLibs.html</a>】之类的编程语言。实现他的特定函数即可，Mosquitto的插件本身不是太难。</p><p>值得一提的是，因为Mosquitto支持两个版本的插件，导致目前互联网上很多教程很杂乱，因为很多教程写的比较早，绝大部分讲的是 V4 版本的插件开发，但是在Mosquitto 2.0时代，V4插件因为设计上比较复杂已经不建议使用了，截止目前为止（2023年3月25日）Mosquitto的插件版本推荐使用 V5。下面是 <code>mosquitto_plugin.h</code>里面的原话：</p><pre><code class="hljs txt">This interface is available from v2.0 onwards.</code></pre><p>因此本文主要研究 V5 版本的插件，后面提到的所有“插件”默认都是V5版本。关于V4版本插件知识，可通过网络检索，不过作者认为已经没有研究的意义。</p><h3 id="Eclipse-Mosquitto-Broker-插件生命周期"><a href="#Eclipse-Mosquitto-Broker-插件生命周期" class="headerlink" title="Eclipse Mosquitto Broker 插件生命周期"></a>Eclipse Mosquitto Broker 插件生命周期</h3><p>Mosquitto插件只有2个生命周期回调：</p><ol><li><p>mosquitto_plugin_init<br> mosquitto_plugin_init 回调是插件加载的时候调用的，其函数定义如下：</p> <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_init</span><span class="hljs-params">(<span class="hljs-keyword">mosquitto_plugin_id_t</span> *identifier,</span></span><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">void</span> **userdata,</span></span><span class="hljs-params"><span class="hljs-function">                          struct mosquitto_opt *options,</span></span><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> option_count)</span></span></code></pre><ul><li><code>identifier</code> 是插件的ID，Mosquitto内部用的，其代表了当前插件的一个句柄，用来注册回调使用</li><li><code>user_data</code> 原本貌似是代表用户数据，但是这个设计有问题，因为用户数据一般是用户在业务代码里面传入的，而不是Mosquitto传入，因此这里一直是NULL，而且在Mosquitto的源码里面也是直接给了个NULL值，因此这个参数可能是Mosquitto团队留下的扩展功能</li><li><code>options</code> 外部配置信息，也就是 mosquitto.conf 里面的那些K-V对，但是这个比较坑的一点是，他会把所有的配置传进来，因此你需要遍历这个指针数组</li><li><code>opt_count</code> 外部配置信息的数目，配合 options 遍历使用</li></ul></li><li><p>mosquitto_plugin_cleanup<br> mosquitto_plugin_cleanup 回调是插件卸载的时候调用的，其函数定义如下：</p> <pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata,</span></span><span class="hljs-params"><span class="hljs-function">                           struct mosquitto_opt *options,</span></span><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">int</span> option_count)</span></span></code></pre><ul><li><code>userdata</code> 此处的 userdata 就是你在插件里面传入的真实值了 和 mosquitto_plugin_init 不是一个含义</li><li><code>options</code> 外部配置信息，也就是 mosquitto.conf 里面的那些K-V对，但是这个比较坑的一点是，他会把所有的配置传进来，因此你需要遍历这个指针数组</li><li><code>opt_count</code> 外部配置信息的数目，配合 options 遍历使用</li></ul></li></ol><p>除了生命周期回调，还有一个用来兼容V4版本插件的一个回调：mosquitto_plugin_version，因为Mosquitto有混乱的插件体系，需要一个回调确定一个版本，因此这个函数在V5插件里面是个固定写法。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_version</span><span class="hljs-params">(<span class="hljs-keyword">int</span> supported_version_count, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *supported_versions)</span></span></code></pre><p>其两个参数没有用，因此无需关注。在实际插件中，只需要简单粗暴直接返回<code>5</code>即可：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_version</span><span class="hljs-params">(<span class="hljs-keyword">int</span> supported_version_count, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *supported_versions)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;&#125;</code></pre><h3 id="Eclipse-Mosquitto-Broker-插件开发实战"><a href="#Eclipse-Mosquitto-Broker-插件开发实战" class="headerlink" title="Eclipse Mosquitto Broker 插件开发实战"></a>Eclipse Mosquitto Broker 插件开发实战</h3><p>经过上面的分析，实际上我们已经掌握了插件的一个框架，下面我们来实战一下，首先新建一个文件，名称为: mosquitto_plugin_demo.c</p><pre><code class="hljs c"><span class="hljs-comment">// 加载插件</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_init</span><span class="hljs-params">(<span class="hljs-keyword">mosquitto_plugin_id_t</span> *identifier,</span></span><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">void</span> **userdata,</span></span><span class="hljs-params"><span class="hljs-function">                        struct mosquitto_opt *options,</span></span><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">int</span> option_count)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mosquitto_plugin_init\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 卸载插件</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata,</span></span><span class="hljs-params"><span class="hljs-function">                                struct mosquitto_opt *options,</span></span><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-keyword">int</span> option_count)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mosquitto_plugin_cleanup\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 版本</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mosquitto_plugin_version</span><span class="hljs-params">(<span class="hljs-keyword">int</span> supported_version_count,</span></span><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *supported_versions)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mosquitto_plugin_version\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;&#125;</code></pre><p>上述示例就是一个最简单的插件，通过编译以后，当启动mosquitto的时候会在每个周期输出对应的字符串。下面给一个编译Makefile：</p><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> ../../config.mk.PHONY : all binary check clean reallyclean test install uninstallPLUGIN_NAME=mosquitto_plugin_demoDEPS=-lmosquittoall : binarybinary : $&#123;PLUGIN_NAME&#125;.so$&#123;PLUGIN_NAME&#125;.so : $&#123;PLUGIN_NAME&#125;.c<span class="hljs-variable">$(CROSS_COMPILE)</span><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(PLUGIN_CPPFLAGS)</span> <span class="hljs-variable">$(PLUGIN_CFLAGS)</span> <span class="hljs-variable">$(PLUGIN_LDFLAGS)</span> -fPIC -shared <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> $&#123;DEPS&#125;reallyclean : clean<span class="hljs-section">clean:</span>-rm -f *.o $&#123;PLUGIN_NAME&#125;.so *.gcda *.gcno<span class="hljs-section">check: test</span><span class="hljs-section">test:</span><span class="hljs-section">install: $&#123;PLUGIN_NAME&#125;.so</span><span class="hljs-comment"># Don&#x27;t install, these are examples only.</span><span class="hljs-comment">#$(INSTALL) -d &quot;$&#123;DESTDIR&#125;$(libdir)&quot;</span><span class="hljs-comment">#$(INSTALL) $&#123;STRIP_OPTS&#125; $&#123;PLUGIN_NAME&#125;.so &quot;$&#123;DESTDIR&#125;$&#123;libdir&#125;/$&#123;PLUGIN_NAME&#125;.so&quot;</span>uninstall :-rm -f <span class="hljs-string">&quot;$&#123;DESTDIR&#125;$&#123;libdir&#125;/$&#123;PLUGIN_NAME&#125;.so&quot;</span></code></pre><p>在根目录下执行:</p><pre><code class="hljs ebnf"><span class="hljs-attribute">make</span></code></pre><p>如果没有错误，就会在目录下生成一个 mosquitto_plugin_demo.so 的动态库，这个就是最终的插件，将其加入到Mosquitto配置文件中, 我们新建一个 test.conf 文件：</p><pre><code class="hljs conf">listener 1883allow_anonymous trueplugin  ../plugins/mosquitto_plugin_demo/mosquitto_plugin_demo.so</code></pre><p>然后启动Mosquitto：<code>mosquitto -c test.conf</code>，就可以运行上面的插件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们展示了一个最基本的插件结构，实际上所有的插件都是经过上述模板来扩展功能的，可将其保存为一个代码模板，每次新开发插件的时候直接先生成一个模板，然后逐渐扩展即可。</p>]]></content>
    
    
    <categories>
      
      <category>Mosquitto二次开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mosquitto二次开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mosquitto 二次开发 (一)：认识 Eclipse Mosquitto Broker</title>
    <link href="/2023/03/25/clpqt1iuk003c4cue1gzydtnt.html"/>
    <url>/2023/03/25/clpqt1iuk003c4cue1gzydtnt.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wwhai] # 概要：本文主要讲解一下 Eclipse Mosquitto Broker 的插件开发技巧。</p><span id="more"></span><blockquote><p>今天是2023年3月25日，深圳下起了瓢泼大雨，每当在这种潮湿的雨天，我的心态就开始低落起来。为了避免无限陷入这种精神折磨，挣扎着从沙发上起来，写一篇文章来转移一下注意力。</p></blockquote><h2 id="Mosquitto-二次开发-一-：认识-Eclipse-Mosquitto-Broker"><a href="#Mosquitto-二次开发-一-：认识-Eclipse-Mosquitto-Broker" class="headerlink" title="Mosquitto 二次开发 (一)：认识 Eclipse Mosquitto Broker"></a>Mosquitto 二次开发 (一)：认识 Eclipse Mosquitto Broker</h2><h3 id="Eclipse-Mosquitto-Broker-下载"><a href="#Eclipse-Mosquitto-Broker-下载" class="headerlink" title="Eclipse Mosquitto Broker 下载"></a>Eclipse Mosquitto Broker 下载</h3><p>Eclipse Mosquitto Broker 是一个很强大的 Mqtt Broker，得益于C语言的优越性能，很适合我们用在一些资源紧张的硬件设备上面。关于Eclipse Mosquitto Broker 的更多细节，可上网搜索相关资料，在本系列文章中只介绍实践经验。</p><h4 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h4><p>Eclipse Mosquitto Broker 官网提供了很多下载包，包含了主流平台常见架构。直接访问：<a href="https://mosquitto.org/download">https://mosquitto.org/download</a>，选择自己的安装包即可。</p><h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p>除了预编译好的二进制包，mosquitto还提供了所有源码，可以使用源码的形式自助编译，源码访问此处可获得: <a href="https://github.com/eclipse/mosquitto">https://github.com/eclipse/mosquitto</a>。下面给个简单的编译指令：</p><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/eclipse/mosquitto.gitmake</code></pre><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>本人用的系统是Ubuntu22.04，给出Ubuntu22.04下的依赖安装指令：</p><pre><code class="hljs sh">sudo apt-get install -y \    libssl-dev \    libcjson1 \    libjson-c-dev \    libmosquitto-dev</code></pre><p><strong>注意</strong>：可能需要安装一些别的依赖，常见的依赖问题可通过上网解决，相对其他一些大项目来说其实很简单。不过如果你是为了学习mosquitto的技术原理，建议用Linux来实践。在这里本人用的系统是Ubuntu22.04作为开发机。</p><h3 id="Eclipse-Mosquitto-Broker-配置"><a href="#Eclipse-Mosquitto-Broker-配置" class="headerlink" title="Eclipse Mosquitto Broker 配置"></a>Eclipse Mosquitto Broker 配置</h3><p>Mosquitto配置比较多，先辈们早早做了研究，此处就不赘述了，大家可以上网检索，下面这个博客讲得比较基础：<a href="https://cloudbool.com/archive/mosquitto-basic-config.html">https://cloudbool.com/archive/mosquitto-basic-config.html</a>。<br>除了上面讲的比较基础的那些配置，此处补充点细节：</p><ol><li>Mosquitto默认只能本地连接<br>如果没有经过任何配置，直接启动 Mosquitto ，你会发现在局域网里面连接不到，原因是 Mosquitto 默认只支持本地连接，需要配置一个 listener参数：<pre><code class="hljs apache"><span class="hljs-attribute">listener</span> <span class="hljs-number">1883</span></code></pre></li><li>Mosquitto默认允许任意客户端连接<br>因为允许任意客户端连接，所以当你部署到设备上以后不安全，所以建议在部署环境下配置好匿名客户端处理：<pre><code class="hljs nginx"><span class="hljs-attribute">allow_anonymous</span> <span class="hljs-literal">false</span></code></pre><h3 id="Eclipse-Mosquitto-Broker-部署"><a href="#Eclipse-Mosquitto-Broker-部署" class="headerlink" title="Eclipse Mosquitto Broker 部署"></a>Eclipse Mosquitto Broker 部署</h3>Mosquitto 和别的应用一样，都是通过service的形式来部署的，下面给出在 systemctl 下的配置：<pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><span class="hljs-attr">Description</span>=Mosquitto MQTT Broker<span class="hljs-attr">Documentation</span>=man:mosquitto.conf(<span class="hljs-number">5</span>) man:mosquitto(<span class="hljs-number">8</span>)<span class="hljs-attr">After</span>=network.target<span class="hljs-attr">Wants</span>=network.target<span class="hljs-section">[Service]</span><span class="hljs-attr">ExecStart</span>=/usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf<span class="hljs-attr">ExecReload</span>=/bin/kill -HUP <span class="hljs-variable">$MAINPID</span><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<span class="hljs-attr">ExecStartPre</span>=/bin/mkdir -m <span class="hljs-number">740</span> -p /var/log/mosquitto<span class="hljs-attr">ExecStartPre</span>=/bin/chown mosquitto:mosquitto /var/log/mosquitto<span class="hljs-attr">ExecStartPre</span>=/bin/mkdir -m <span class="hljs-number">740</span> -p /run/mosquitto<span class="hljs-attr">ExecStartPre</span>=/bin/chown mosquitto:mosquitto /run/mosquitto<span class="hljs-section">[Install]</span><span class="hljs-attr">WantedBy</span>=multi-user.target</code></pre></li></ol><p>上面的 service 脚本仅支持使用 systemctl 管理工具的系统，比如 debian、ubuntu等，其他的服务脚本大家可以自行探索。在 mosquitto源码里面提供了一些别的平台的脚本，可作为参考:<a href="https://github.com/eclipse/mosquitto/tree/master/service">https://github.com/eclipse/mosquitto/tree/master/service</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文一个概述，相信大家对mosquitto已经有了一个初步认识，重点在于掌握mosquitto的常见操作。后续文章我们继续探索mosquitto的一些内部机制和二次开发技巧。</p>]]></content>
    
    
    <categories>
      
      <category>Mosquitto二次开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mosquitto二次开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[目录] Eclipse Mosquitto Broker 二次开发</title>
    <link href="/2023/03/25/clpqt1ium003m4cue6m4n7m5b.html"/>
    <url>/2023/03/25/clpqt1ium003m4cue6m4n7m5b.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wwhai] # 概要：本文主要讲解一下 Eclipse Mosquitto Broker 的插件开发技巧。</p><span id="more"></span><blockquote><p>今天是2023年3月25日，深圳下起了瓢泼大雨，每当在这种潮湿的雨天，我的心态就开始低落起来，一想起来各种糟心事，就痛苦的想嚎啕大哭一场。为了避免无限陷入这种精神折磨，挣扎着从沙发上起来，写点文章来转移一下注意力。<br>这一系列文章是我近期研究 Eclipse Mosquitto Broker 的一些总结，希望对物联网开发的朋友们有所帮助。</p></blockquote><h1 id="Eclipse-Mosquitto-Broker-二次开发"><a href="#Eclipse-Mosquitto-Broker-二次开发" class="headerlink" title="Eclipse Mosquitto Broker 二次开发"></a>Eclipse Mosquitto Broker 二次开发</h1><h2 id="一-：认识-Eclipse-Mosquitto-Broker"><a href="#一-：认识-Eclipse-Mosquitto-Broker" class="headerlink" title="(一)：认识 Eclipse Mosquitto Broker"></a>(一)：认识 Eclipse Mosquitto Broker</h2><h3 id="Eclipse-Mosquitto-Broker-下载"><a href="#Eclipse-Mosquitto-Broker-下载" class="headerlink" title="Eclipse Mosquitto Broker 下载"></a>Eclipse Mosquitto Broker 下载</h3><h3 id="Eclipse-Mosquitto-Broker-配置"><a href="#Eclipse-Mosquitto-Broker-配置" class="headerlink" title="Eclipse Mosquitto Broker 配置"></a>Eclipse Mosquitto Broker 配置</h3><h3 id="Eclipse-Mosquitto-Broker-部署"><a href="#Eclipse-Mosquitto-Broker-部署" class="headerlink" title="Eclipse Mosquitto Broker 部署"></a>Eclipse Mosquitto Broker 部署</h3><h2 id="二-：Mosquitto-Broker插件机制"><a href="#二-：Mosquitto-Broker插件机制" class="headerlink" title="(二)：Mosquitto Broker插件机制"></a>(二)：Mosquitto Broker插件机制</h2><h3 id="Eclipse-Mosquitto-Broker-插件机制概述"><a href="#Eclipse-Mosquitto-Broker-插件机制概述" class="headerlink" title="Eclipse Mosquitto Broker 插件机制概述"></a>Eclipse Mosquitto Broker 插件机制概述</h3><h3 id="Eclipse-Mosquitto-Broker-插件生命周期"><a href="#Eclipse-Mosquitto-Broker-插件生命周期" class="headerlink" title="Eclipse Mosquitto Broker 插件生命周期"></a>Eclipse Mosquitto Broker 插件生命周期</h3><h3 id="Eclipse-Mosquitto-Broker-插件开发实战"><a href="#Eclipse-Mosquitto-Broker-插件开发实战" class="headerlink" title="Eclipse Mosquitto Broker 插件开发实战"></a>Eclipse Mosquitto Broker 插件开发实战</h3><h2 id="三-：Mosquitto-Broker部分源码解析"><a href="#三-：Mosquitto-Broker部分源码解析" class="headerlink" title="(三)：Mosquitto Broker部分源码解析"></a>(三)：Mosquitto Broker部分源码解析</h2><h3 id="mosquitto-h-头文件"><a href="#mosquitto-h-头文件" class="headerlink" title="mosquitto.h 头文件"></a>mosquitto.h 头文件</h3><h3 id="mosquitto-broker-h-头文件"><a href="#mosquitto-broker-h-头文件" class="headerlink" title="mosquitto_broker.h 头文件"></a>mosquitto_broker.h 头文件</h3><h3 id="mosquitto-plugin-h-头文件"><a href="#mosquitto-plugin-h-头文件" class="headerlink" title="mosquitto_plugin.h 头文件"></a>mosquitto_plugin.h 头文件</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes">批注<div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>【官方文档1】<a href="https://mosquitto.org/documentation">https://mosquitto.org/documentation</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>【官方文档2】<a href="https://mosquitto.org/api/files/mosquitto-h.html">https://mosquitto.org/api/files/mosquitto-h.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>【Mqtt示例】<a href="https://cumulocity.com/guides/device-sdk/mqtt-examples">https://cumulocity.com/guides/device-sdk/mqtt-examples</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>【Mqtt3.1协议规范】<a href="http://stanford-clark.com/MQTT">http://stanford-clark.com/MQTT</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Mosquitto二次开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mosquitto二次开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年隔离时候的一篇日志</title>
    <link href="/2023/01/12/clpqt1ivv008a4cuehv4c4fax.html"/>
    <url>/2023/01/12/clpqt1ivv008a4cuehv4c4fax.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2022年隔离时候的一篇日志。</p><span id="more"></span><h2 id="2022年隔离时候的一篇日志，刚才翻出来了。"><a href="#2022年隔离时候的一篇日志，刚才翻出来了。" class="headerlink" title="2022年隔离时候的一篇日志，刚才翻出来了。"></a>2022年隔离时候的一篇日志，刚才翻出来了。</h2><p><img src="/uploads/2022-0000/riji.png" alt="2022"></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2022</title>
    <link href="/2023/01/11/clpqt1ivo007g4cue9246ap9s.html"/>
    <url>/2023/01/11/clpqt1ivo007g4cue9246ap9s.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我的2022</p><span id="more"></span><p><img src="/uploads/2022-0000/my2022.png" alt="2022"></p><h1 id="2022总结"><a href="#2022总结" class="headerlink" title="2022总结"></a>2022总结</h1><div style="font-size:120%; color: blue;"><p><strong><em>2022年是我彻底告别过去开始新生的元年。</em></strong></p><h2 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h2><p>2022年和我妻子分别了整整一年时间，因为她怀孕，加上当时疫情有夸大的成分，导致我们恐惧深圳的病毒，所以为了安全就呆在千里之外的家里。而我整个2022年就回了一次家。</p><p>每个人都在为了未来的生活付出。致敬我们这些不息的人！</p><h2 id="当父亲"><a href="#当父亲" class="headerlink" title="当父亲"></a>当父亲</h2><p><img src="/uploads/2022-0000/zhijun.png" alt="2022"><br><img src="/uploads/2022-0000/lanhua.jfif" alt="2022"><br>2022年4月我的小宝宝出生了，她是一个很可爱的小家伙，我给她起了个名字：芷君，芷乃小兰花，我希望她将来能像兰花一样清新而不落俗套。我在28岁的时候当了父亲，意味着多了一份责任。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>从2018年毕业开始开始我搞了2年java，后来2020年跑杭州去搞了1年Erlang。2021年7月到深圳搞了半年业务。但是在深圳下半年开始（2021年下半年），逐渐感觉到了一种危机感：上层简单应用类、框架类软件开发已经趋于饱和，以前会某个框架（如java世界的那些）某个数据库就很抢手，但是如今框架多如牛毛，打开学习网站到处都是教你怎么写一个SpringBoot框架的教程，那时候意识到未来的竞争力已经不在前端和业务端了，必须想办法拉自己回来。</p><h2 id="转行"><a href="#转行" class="headerlink" title="转行"></a>转行</h2><p><img src="/uploads/2022-0000/danpianji.png" alt="2022"><br>于是在2022年过完年回来后，果断的抛弃了CURD路线和WEB软件开发的技能，这对任何人来说都是个挑战，相当于自废多年武功。但是当时是下定决心了，从2022年2月开始就全力投入到了系统级开发和物联网中间件领域。从CURD到系统级开发，中间还是很考研人的毅力，虽然说我大学是电子类专业出身，但是4年没摸过硬件以至于连C语言基础否忘了，看个硬件连接图都费劲。上半年狠心买了大学的数字电路和模拟电路又开始看了起来，看了大半年才找回来感觉，勉强才能看懂开发板的原理图。所以2022年是相当卷的一年，不是在写代码就是在下班路上，以至于到今天（2023年1月11日）我还是把90%的业余时间用在看书上。不过幸运的一点是，貌似转行成功了。有一段时间（大概5月）在公司我还亲自在嘉立创EDA上画了个PCB，拿电烙铁焊接了个ESP32的开发板，虽然画的屎一样，焊接出来不堪入目，但是那时候就是为了逼着自己在学习这些完全陌生的东西。<br><img src="/uploads/2022-0000/PCB1.png" alt="2022"></p><h2 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h2><p>想起来2018年大学刚毕业的时候，我们在福州找不到物联网相关的工作，很多电子信息专业的同学都转行了，有人去干了销售，有人回老家。包括我自己也转行做了业务。时光荏苒一不小心又捡起来当年的梦想，真的是属于不忘初心回到原点。</p><p>我经常跟别人说如果当年就直接到了深圳今天会怎样？</p><h2 id="学习经历"><a href="#学习经历" class="headerlink" title="学习经历"></a>学习经历</h2><p>下面这些就是个人真实学习经历：</p><ol><li>学习了LUA的源码以及其设计理念：《LUA设计与实现》，尤其LUA的基础数据结构那部分</li><li>尝试自己用Flex、Bison写了个计算器，了解了如何处理简单DSL</li><li>3月被隔离31天期间，阅读了两篇论文：《Bitcask》和《Raft》，并且实现了个Bitcask的demo，Raft太复杂了，看起来费劲</li><li>设计了一套工业&amp;物联网应用软件体系：AIIM，从云端到中间件，到硬件终端，基本上全部摸了一遍，并且实现了一些数据交互，并且成功在工作中进行了落地实践</li><li>对Linux兴趣增加，长时间研究Linux开发，期间看了《C接口与实现》、《Linux驱动开发》、《Linux0.12源码分析》。自己尝试写了几个驱动，顺便研究了一下数字电路、模拟电路，对Linux和嵌入式开发的能力加强了不少。</li><li>重构了RULEX框架，顺便探索出来Golang在嵌入式Linux软件开发中的一个比较好的实践思路。经过一年多的调研&amp;实践&amp;落地项目，发现Golang开发嵌入式软件还是比较有优势。</li><li>维护了一大批和golang有关的物联网协议包，看了下一年涉及到的仓库居然多达160多个（pr、issue等）。</li><li>加深了对边缘网关的认识，现在几乎能达到不假思索开发出来各类工业、物联网、楼宇类网关设备，一套理论吃遍天下，成功的向朋友，同事宣传了一套概念，大家评价都还可以，以至于我越来越崇拜基础知识</li><li>1月玩了一段时间单片机，想不到我大学的时候不会玩，现在拿起来看看资料就能开发出一些东西来了，真的是证明了一句话：基础知识是万物之本。今年花了大量时间研究计算机科学相关的东西，想不到单片机竟然是意外收获。前段时间尝试搞了个基于ATMEGA328P的Task系统，近期又搞了个STC89C52的Task系统，完全是基础知识促进了我的学习进程。</li></ol><h2 id="2023-计划"><a href="#2023-计划" class="headerlink" title="2023 计划"></a>2023 计划</h2><p>上面基本就是2022年所有的经历了，回想起来今年对自己真狠。下面看看2023年的计划。</p><ol><li>继续研究Linux开发，今年侧重于高性能服务器</li><li>继续研究操作系统相关的高级知识，侧重于任务的调度</li><li>研究下新一代的网络技术、无线技术等</li><li>开发一款物理硬件网关，一款DTU，一款开发板</div></li></ol><div style="font-size:120%; color: RED;"><h2 id="学习推荐"><a href="#学习推荐" class="headerlink" title="学习推荐"></a>学习推荐</h2><ul><li>《深入理解计算机系统》（机械工业出版社），强烈推荐，不论你是做纯粹的业务类软件的，还是做嵌入式系统开发的，这本书应该作为圣经摆在右手边！</li><li>《深入理解Linux内核》（封面大气泡那本）</li><li>《Linux\Unix 系统编程》（Man7）</li><li>《高性能Linux服务器开发》（游双）</li><li>《C++并发编程》（安东尼）</li><li>《模拟电子基础》（童诗白）</li><li>《数字电路基础》（阎石）</li><li>《图解网络硬件》（小日子那本）</li><li>《C语言核心技术》（封面是牛头）</li><li>《C接口与实现》（人民邮电出版社）</li><li>《C++11 Primer》（第四版）</div></li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul><li>因为个人喜好导致了对数据库、前端技术完全是盲区，2023年应该了解些关于这方面的知识。</li><li>至今脾气还是收不住容易发飙，但是相比2年前，已经有进步了，未来努力做一个有涵养的人。</li></ul><hr><p>上面的仅仅是个大致计划，其他的看具体时间安排。不过我确实和一开始的路渐行渐远了。</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>住在城中村的顺口溜</title>
    <link href="/2022/12/26/clpqt1ivp007k4cue78ae16gc.html"/>
    <url>/2022/12/26/clpqt1ivp007k4cue78ae16gc.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] 概要：写了个抒发感情的顺口溜。</p><span id="more"></span><p><img src="/uploads/2022-public/1671860827495.png" alt="1671860827495"></p><p>2022年我一个人住在深圳的城中村【塘晏村】。这个楼层里有好几对情侣，每天晚上准时开始此起彼伏响起来不同的男女的呐喊声，小公寓也很精致但是隔音效果很差，以至于隔了两道墙还是甚至能听见肉体撞击的声音。我一个人躺在床上看书（通信原理），一阵一阵涌入我的听觉让我心烦意乱。于是即兴写了个抒发感情的顺口溜。</p><hr><div style="text-align:center;"><p><strong>楼道里嗯嗯啊啊的声音又响起</strong><br><strong>回荡在这这聒噪的夜晚</strong><br><strong>释放着生物的本能气息</strong><br><strong>我这书是死活读不下去</strong><br><strong>好想回到大学的晚自习教室</strong><br><strong>傅立叶正变换逆变换即使没有兴趣</strong><br><strong>我还在耿耿于怀失去的知识</strong><br><strong>我好想问问阿杜我的未来在哪里</strong></p></div><hr><p>想想也是荒唐又哭笑不得，不过倒是激发了我的创作灵感，hiahiahia。</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年参加的一场IoT会议</title>
    <link href="/2022/12/12/clpqt1iw8009u4cue7u4h66bj.html"/>
    <url>/2022/12/12/clpqt1iw8009u4cue7u4h66bj.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2022年参加的一场IoT会议,留个纪念。</p><span id="more"></span><h2 id="参会照片"><a href="#参会照片" class="headerlink" title="参会照片"></a>参会照片</h2><p>主要都在推网关和国产芯片类，估计2023年能火一下，或者说相关基金又能涨。<br>中间C位的女强人是个大老板，做新闻媒体的，也是本次会议的主要组织方。不得不说确实有气质。</p><p><img src="/uploads/20221212IOT%E5%B3%B0%E4%BC%9A/1670817329626.png" alt="20221212IOT峰会"></p><p>对我而言，肉眼可见的双下巴，看起来更油腻了吧。</p><h2 id="原始链接"><a href="#原始链接" class="headerlink" title="原始链接"></a>原始链接</h2><p><a href="https://live.photoplus.cn/live/77662190?accessFrom=qrcode#/live">https://live.photoplus.cn/live/77662190?accessFrom=qrcode#/live</a></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一瓶维生素B2</title>
    <link href="/2022/12/01/clpqt1iw7009q4cuehe0l4ckq.html"/>
    <url>/2022/12/01/clpqt1iw7009q4cuehe0l4ckq.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：一瓶维生素B2</p><span id="more"></span><p><img src="/uploads/20221201%E4%B8%80%E7%93%B6%E7%BB%B4%E7%94%9F%E7%B4%A0B2/1669873423396.png" alt="1669873423396"></p><div style="font-size:150%; color: blue;"><p>今天是2022年12月1日，我翻东西的时候翻出来一瓶药。这一瓶维生素是2年前她唇炎的时候买的。一直压在箱子里，今天翻出来发现已经过期了。两年前的时光仿佛就在眼前。这两年我们走了福建、浙江、深圳，如今又分开一年了，都是为了生活啊。</p></div>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇作文的题目</title>
    <link href="/2022/11/13/clpqt1iw6009m4cue2iefebqo.html"/>
    <url>/2022/11/13/clpqt1iw6009m4cue2iefebqo.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：一个朋友写的文章。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>这篇文章是我一个朋友写的</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div style="font-size:150%; color: blue;">在十余年前，我曾经用过类似的标题作文，叫作“一篇作文的题目”，然后就挨了批评。莫名的想起过往的一些事。最初的记忆是在托儿所，不大的小房间里面有一些小孩分坐在两边。我低头拿着自己的鞋不断摆弄，然后一个大人过来抓起鞋就扔到了讲台下面。我抬起头看了看，默然无言。然后是在一个小山村里。大人们拿着各种家伙什，爬坡上坎，挽着裤腿插秧，背着背篓种菜。田间地坎，炊烟袅袅，市井街镇，赤脚走夫。我望了望对面，对面是山，这边也是山。<p>每天早上出门，先走山路，再上公路，到了镇里，进学校大门，再进一道小门。一楼待了一段时间，又到二楼去念书。学过什么我是一点都记不起来，只知道某天中午我干了五碗饭，然后到厕所吐了一地。放学回来，我总是喜欢摆弄那台岁数比自己大的老电视机，用天线的那种，白天可以看一个频道，晚上有俩。能看的节目不多，播放各种经典港片的电影栏目，是我每天傍晚都坚守电视机前的理由。夕阳西下，斜射的日光拉出长长的影子。后来开始接触互联网的时候，已经是中学，从网络小说开始的。那是一个阳光明媚的下午，朋友对着一个小小的屏幕看个不停，强烈的好奇心让我加入了他，从此一发不可收拾。</p><p>在那段时间里，网文在我的生活中占据了绝对的位置。从早晨的第一抹余光开始，到入睡前前的最后一瞥，如梦似幻，难以割舍。狭小的屏幕，短小的一页， 一天近百万字的记录，模糊的视野伴随我度过了大半中学时光。可即便如此，我看过的网文也不算多，因为大多注水严重，可谓阅后即焚，了无印迹。相比之下，出版书籍普遍显的简短而明快。在经过郭敬明那悲伤逆流成河式的青春疼痛文学洗礼之后，我变的十分热衷于韩寒的文章。那种明亮、锐利，而又有力的文字，很是牵动一个少年多愁善感的心绪。这促使我翻阅了韩寒的大部分作品，时评，小说，杂文，乃至博客。随之来而来的是，是对世界认知的剧烈抖动，以及莫名的难以名状的情绪。现在来讲，这种现象被称之为中二病。幻想的世界光怪陆离，无限美好，让我一度有过写作的想法。我写过散文，也写过小说，写出过几篇短篇给周围的人看，不过反响都不怎么热烈。</p><p>那时我常常会想，上学对我来说意味着什么？上学这件事对我而言并不快乐，当然也没有多痛苦，只是不是很喜欢。我自己并不是什么做题家，同学里面也基本也没有，甚至有相当于一部分没有参加升学考试。我记得的老师不多，高中班主任算一个。在他嘴里，我常常“不是个好东西”，是值得被拉出来当众批判的对象。<br>后来，我去了另外一座江边小城，念了一所普通的学校。走在校园里面，路过扎堆招新的各种学生组织，在一个路边小摊上拾起了一本杂志，顺手捎了一张报名表回去。我有心展示一下自己对作文的热爱，在报名表上写到“博文也，姓张，万县人氏…”。</p><p>从那之后，我再也没提笔写过文字。</p></div>]]></content>
    
    
    <categories>
      
      <category>文集-原创散文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-原创散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我做过的一些荒诞的梦</title>
    <link href="/2022/10/05/clpqt1ivm00784cuecsqeaieo.html"/>
    <url>/2022/10/05/clpqt1ivm00784cuecsqeaieo.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我老是做一些奇奇怪怪的梦。</p><span id="more"></span><p><strong>在杭州那段时间我老是做一些奇奇怪怪的梦。有时候甚至会做噩梦，从梦中吓醒，大喊大叫。到现在基本上很少做了，所以我老是在想那段时间是不是被PUA压力太大，导致我的精神出现了紧张。</strong></p><p><img src="/uploads/2022-0000/1.jpg" alt="1570850340262"></p><hr><h2 id="2020年12月18日"><a href="#2020年12月18日" class="headerlink" title="2020年12月18日"></a>2020年12月18日</h2><h3 id="谍战"><a href="#谍战" class="headerlink" title="谍战"></a>谍战</h3><p>这个梦是一个电影情节。我梦见自己被关到了一个监狱里面。以第一人称视角再看一个故事的发生。首先这个主角是个女的。然后同时监狱里面有7个来自中国的犯人。然后大家掌握了一个贩毒集团的秘密。大家策划从这个监狱里面逃跑。一路上遇到了各种困难。走到半路发现这个女人是敌人派来的间谍。然后被套路最终暴露。然后杀死这个女的。其他人全部逃生。</p><h2 id="2020年12月19日"><a href="#2020年12月19日" class="headerlink" title="2020年12月19日"></a>2020年12月19日</h2><h3 id="道士跟修女"><a href="#道士跟修女" class="headerlink" title="道士跟修女"></a>道士跟修女</h3><p>有一个道士，他下山后在社会上面闯荡。结果社会非常黑暗，他经历了各种磨难，最后遇到了一个信仰基督教的修女。在这个修女的感化下他最终信了基督教。（话说这个梦就真的有点奇葩了）。</p><h2 id="2021年7月2日凌晨3-25"><a href="#2021年7月2日凌晨3-25" class="headerlink" title="2021年7月2日凌晨3:25"></a>2021年7月2日凌晨3:25</h2><h3 id="一个怪诞的梦"><a href="#一个怪诞的梦" class="headerlink" title="一个怪诞的梦"></a>一个怪诞的梦</h3><p>晚上，一条路，好像是我们村去陈庄的。我骑着摩托车走在路上，突然有个人超车了，他的尾灯特别亮，亮到如同白昼，看不清前面的路，然后我的车就骑进了沟里，等我看清楚的时候，是在一条河边，老远我居然看到了表弟大宝，他和我们儿时的小伙伴一起在玩，奇怪的是他没有叫我文宝哥。我跟大宝说刚才有个傻子骑车亮尾灯把我带沟里了，帮我教训一顿，结果大宝带我去的路上，看到了那个人，他突然用一个网子把我抓了，然后把我逮到了一个地方，这个地方很神奇，里面有我很多亲人，还有村里的人，居然还有我二十多年在村里几乎没打过招呼的八队那边的几个老汉。有我爷爷奶奶，还有我姑姑，但是他们的样子都很奇怪，表情木然，把我名字叫错的，还有我姑姑说我是徐寨人，要送我去徐寨，爷爷的头发是卷的，他们和我说的话每一句都对不上号。我认真看奶奶居然有四只脚。但是在人群里貌似看到一个人，他不断暗示我要赶紧跑。我知道此时已经进了幻境，里面的奇怪的人不让我出去，一直跟我说话，此时奶奶的四只脚突然抓住我的右脚，一群人要带着我下一个很高的楼梯，这个楼梯看起来有几百层。我一想凉了，我要被困在幻境了，满脑子在想如何逃出去，此时仿佛我意识到自己在梦里，然后被困住了，潜意识告诉我你要赶紧醒来，不然你要去可怕的地方。我努力挣脱，但是被这一群人围住了，跑不出去，突然我的耳边想起了刚才偷偷暗示我那个人的一句话：你不是要赶紧醒来吗。在这一瞬间我就醒了。脑子无比清醒，一点困意都没有，外面空调的声音，还有旁边老婆的呼吸声告诉我回到现实了。但是我的心跳加速，砰砰砰的，房间不冷但是我冷的发抖。现在想起来这个梦背后一阵凉。</p><h2 id="2020年11月5日凌晨5-00"><a href="#2020年11月5日凌晨5-00" class="headerlink" title="2020年11月5日凌晨5:00"></a>2020年11月5日凌晨5:00</h2><blockquote><p>连续做了两个梦。</p></blockquote><h3 id="三个夫人复仇记"><a href="#三个夫人复仇记" class="headerlink" title="三个夫人复仇记"></a>三个夫人复仇记</h3><p>大户人家官老爷经常纳妾但是一直都不见夫人，原来他玩腻了就杀害，这些夫人的魂魄在第三个 还是第几个来着的夫人带领下。最后在道士的帮助下复仇。</p><h3 id="梦里的梦和一只小猫"><a href="#梦里的梦和一只小猫" class="headerlink" title="梦里的梦和一只小猫"></a>梦里的梦和一只小猫</h3><p>梦里有个人，在某个地方抛弃了一只小猫，这只小猫很可怜，大家都想领养，但是最后死了，愤怒的人们开始寻找那个人，结果牵车扯出来一个动物贩卖黑社会，这个黑社会专门用小动物做一些违法犯罪的事情，虐待或者是杀死。于是我带领一群人开始反抗这个黑社会，查出问题的时候。黑社会集团和我带的人开始打架，大家打的很激烈的时候，一切都消失了，一下子就剩下我一个人，原来我在做梦。我在一个大厅里睡着了，我看到梦里出现的人们都在忙碌工作或者做别的，场景一下子切换了，我很疑惑的问：你们怎么不打了，他们说你是不是神经病？打什么？原来一切都在另一个梦里，梦里那只小猫就在地下乱跑。而桌子上有两个小孩子正在玩一个游戏，游戏的角色是一只小猫。</p><h2 id="2021年7月13日"><a href="#2021年7月13日" class="headerlink" title="2021年7月13日"></a>2021年7月13日</h2><h3 id="宇宙航行"><a href="#宇宙航行" class="headerlink" title="宇宙航行"></a>宇宙航行</h3><p>我坐着宇宙飞船飞到了某个星球上空，然后从里面跳下来，然后不断的进行自由落体。在这个过程中感觉到呼吸困难，胸口很闷，感觉头快要炸了，然后就在一瞬间被惊醒，发现以后我的右手放在胸口，这个感觉应该是我的手的压迫感。</p><h2 id="2021年7月20日"><a href="#2021年7月20日" class="headerlink" title="2021年7月20日"></a>2021年7月20日</h2><blockquote><p>连续做了三个梦。</p></blockquote><h3 id="送外卖"><a href="#送外卖" class="headerlink" title="送外卖"></a>送外卖</h3><p>梦见我是一个外卖小哥。然后给一个房间里面送外卖。这个房间里面有很多铁架子床。床上挤满了人。</p><h3 id="中世纪"><a href="#中世纪" class="headerlink" title="中世纪"></a>中世纪</h3><p>故事发生在中世纪。我看到了一个城堡，城堡里面有个黑箱子，里面有一把剑。有旁白告诉我，这把剑是为了镇压吸血鬼。于是我就把这把剑拿走了，一路上我看到了很多老家熟悉的场景。老家村里面的场景，还有有些人家的院子。</p><h3 id="战争"><a href="#战争" class="headerlink" title="战争"></a>战争</h3><p>做梦参加了一场战争。我们这边打赢了，然后对面接受投降。他们双手举着枪。排队从一个山坡上面下来。</p><h2 id="2021年11月21日"><a href="#2021年11月21日" class="headerlink" title="2021年11月21日"></a>2021年11月21日</h2><h3 id="被拐卖"><a href="#被拐卖" class="headerlink" title="被拐卖"></a>被拐卖</h3><p>梦见我被别人拐到了中东地区，然后历经千难万险，终于回到了中国，最后追查这件事情的时候，发现当年把我卖到中东的人是一个卖保险的。</p><h2 id="Man-food"><a href="#Man-food" class="headerlink" title="Man food"></a>Man food</h2><p>女朋友做了一个梦，说给自己开了个店，这个店主要的面向群体是男人，里面主要销售男人喜欢的食品，所以说他给这个店起了个名字叫 <strong>Man Food</strong>.</p><h2 id="2022年2月10日"><a href="#2022年2月10日" class="headerlink" title="2022年2月10日"></a>2022年2月10日</h2><h3 id="世界末日"><a href="#世界末日" class="headerlink" title="世界末日"></a>世界末日</h3><p>故事发生的背景是世界末日,当时发生了一件事情，海平面上升,我们开着车来逃跑,一路上经过了一个中国式的古建筑,看到建筑物在倒塌。</p><h2 id="2022年01月01日-凌晨3-00"><a href="#2022年01月01日-凌晨3-00" class="headerlink" title="2022年01月01日(凌晨3.00)"></a>2022年01月01日(凌晨3.00)</h2><h3 id="心灵控制"><a href="#心灵控制" class="headerlink" title="心灵控制"></a>心灵控制</h3><p>故事发生在一个类似于咖啡馆的地方。有一些人可以控制人的心灵,你被控制以后就会服从他们的管控,他们伪装自己 开咖啡店物色人 一旦发现就会控制他们,让他们变得胆怯而不反抗,有很多人被控制。<br>我也被控制了，见到他们以后吓得浑身发抖，但是我心里是清楚的，我看到很多人被控制后麻木的坐着面无表情，于是我想把他们救出来。<br>潜意识里告诉我，我自己在梦里，只需要醒来就可以，于是我尝试叫醒自己，我想努力挣脱控制以后 把别人也拉出来。<br>梦里有人告诉我 只需要赶快醒来。</p><p>就在两点五十的时候我大声喊了一嗓子，然后整个世界消失。瞬间就清醒了。醒了以后吓得浑身出冷汗瑟瑟发抖，不知道这是一个什么梦。</p><h2 id="2022年06月06日"><a href="#2022年06月06日" class="headerlink" title="2022年06月06日"></a>2022年06月06日</h2><h3 id="和网红打架"><a href="#和网红打架" class="headerlink" title="和网红打架"></a>和网红打架</h3><p>这是个爽文 有点歪嘴龙王的味道。我是个公司职员，到某个地方出差去了，结果被因为某一事和本地网红产生了矛盾，网红带着他的兄弟把我打了一顿，把我打的都叫他们爷爷了（梦里被打了）。 最后忍辱负重跑了出来。一个电话表弟（二舅儿子）带着公司同事们穿着西装出来 几十个人开车到这个网红的村里。表弟问打多久？我说一分钟。然后一群人上去把这个网红打了一分钟，最后网红还给我赔了钱。然后我带着一群西装暴徒就走了。</p><h2 id="2022年06月15日"><a href="#2022年06月15日" class="headerlink" title="2022年06月15日"></a>2022年06月15日</h2><h3 id="抗日战争时期卧底"><a href="#抗日战争时期卧底" class="headerlink" title="抗日战争时期卧底"></a>抗日战争时期卧底</h3><p>我是个地下党员，偷偷卧底到日本人里面获取情报。场景和看到的抗日神剧有点像，一队又一队的日本兵走来走去的。</p><h2 id="2022年06月27日"><a href="#2022年06月27日" class="headerlink" title="2022年06月27日"></a>2022年06月27日</h2><h3 id="去美国"><a href="#去美国" class="headerlink" title="去美国"></a>去美国</h3><p>当时比较混乱，每个人都在乱跑。我跟着一辆车跑到了美国曼哈顿（梦里这个城市就叫曼哈顿)，之后在一个叫第五（Fifth）的珠宝店打工，后来开了一批人让我扫码，统计偷渡的人口。我趁机跑了，然后看到路边的高楼大厦，路边一群人给我推荐外卖，我看到他们有人手里还拿着盒饭。</p><blockquote><p>做核酸后遗症吧。</p></blockquote><h2 id="2022年08月29日"><a href="#2022年08月29日" class="headerlink" title="2022年08月29日"></a>2022年08月29日</h2><h3 id="一群孤寡老人骗子"><a href="#一群孤寡老人骗子" class="headerlink" title="一群孤寡老人骗子"></a>一群孤寡老人骗子</h3><p>遇到一群孤寡老人，他们生活很艰难，很可怜，到处游走乞讨。当大家都伸出援助的手以后，剧情反转了：警察说这些老人是诈骗集团，全国各地骗钱。</p><h2 id="2022年09月2日"><a href="#2022年09月2日" class="headerlink" title="2022年09月2日"></a>2022年09月2日</h2><h3 id="穿越"><a href="#穿越" class="headerlink" title="穿越"></a>穿越</h3><p>和别人打游戏突然就晕倒了， 醒来后一群人围着我， 一丝不挂躺在大庭广众之下， 周边的人都在笑 ，结果被别人抓起来， 路上看到了火车站是福州 ，乱七八糟的人跟我说我5年前从深圳消失不见了， 怎么突然出现在福州。原来我被外星人带走去做人体研究 ，在宇宙中只过了几个小时而已，地球上已经过了5年。然后我发现自己居然能从手心喷出火了。还有好像破解了电磁波？？？(背景：近期在学通信原理基础课一下通信原理)</p><h2 id="2022年09月27日"><a href="#2022年09月27日" class="headerlink" title="2022年09月27日"></a>2022年09月27日</h2><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>路过一个地方，有很多人，于是拿起手机（或者是相机）拍了很多照片。回到家里打开查看，结果发现照片里面全部是死人，瞬间一阵恐惧感涌上来，然后被吓醒。</p><h2 id="2022年11月10日"><a href="#2022年11月10日" class="headerlink" title="2022年11月10日"></a>2022年11月10日</h2><h3 id="寒假作业"><a href="#寒假作业" class="headerlink" title="寒假作业"></a>寒假作业</h3><p>梦回高中时期，开学了作业没写完，作业的内容是：记录假期吃的饭。为了补作业，让饭店老板狂做36份不一样的菜拍照。有个烫很好喝，名字叫芹菜牛肉末汤。</p><h2 id="2022年11月13日"><a href="#2022年11月13日" class="headerlink" title="2022年11月13日"></a>2022年11月13日</h2><h3 id="人生选择"><a href="#人生选择" class="headerlink" title="人生选择"></a>人生选择</h3><p>梦里有人告诉我，人一生会有很多选择，但是每个选择他是有一定的数学模型的。每个人的选择就是一个事物的发展曲线，曲线必然有高点，低点，拐点等特性，多个曲线还有焦点。人生的得意时刻莫过于在高点而落魄时刻在低点。</p><blockquote><p>这个神奇的梦让我豁然开朗：人生不就是这样吗？举个例子为了在大城市过上期望的生活实际上在城市里成了流浪人口。我在的这个地方深圳有多少男人怀揣梦想，最后落魄；又有多少女人盼望获得超越阶级的爱情而遍体情伤。这已经背离了初衷，就是所谓的“入不敷出”，玄学叫“万事皆有度”，为了一套房子破了这个”度”就得承受不该有的痛苦，30年房贷如万斤巨石，一辈子何来的快乐？犹记得少年时代说的“以后要去大城市生活”。</p></blockquote><h2 id="2022年11月30日"><a href="#2022年11月30日" class="headerlink" title="2022年11月30日"></a>2022年11月30日</h2><p>十一月最后一天，做了个武侠梦：一群人追杀2个人，被追到一个院子里，当他们被围起来的时候 ，周边一群人轮番拿刀砍他们，结果好一会儿发现不对劲，是自己人在互相打，原来这两个人不知什么时候突然易容变成了围他们的人的样子，他们最后趁机易容逃跑了。</p><h2 id="2022年12月8日"><a href="#2022年12月8日" class="headerlink" title="2022年12月8日"></a>2022年12月8日</h2><p>这是个盗墓类的。梦中我和几个人去盗墓，明明看到别人在前面走，但是一回头看到他从后面闪过。一下子就把我吓醒了。</p><h2 id="2023年3-10日"><a href="#2023年3-10日" class="headerlink" title="2023年3.10日"></a>2023年3.10日</h2><p>梦见和小学的一些同学玩耍，结果被某个人一下子推进一个很黑的小房间，这个房间是个大牢，想要解脱的办法就是骗人进来替换你。</p><p>。。。我想到了传销。</p><h2 id="2023年4-27日（凌晨3：30分）"><a href="#2023年4-27日（凌晨3：30分）" class="headerlink" title="2023年4.27日（凌晨3：30分）"></a>2023年4.27日（凌晨3：30分）</h2><p>梦里和别热讨论数学，讨论到一个“弯曲矩阵”，这个矩阵的定义是：</p><blockquote><p>当一个矩阵的每一个元素都分布到一个曲线上面，我们就称之为“弯曲矩阵”。</p></blockquote><p>。。。这个梦境太离谱了，学术都能在梦里讨论。</p><h2 id="2023年6-16日"><a href="#2023年6-16日" class="headerlink" title="2023年6.16日"></a>2023年6.16日</h2><h3 id="消毒"><a href="#消毒" class="headerlink" title="消毒"></a>消毒</h3><p>世界末日到了，外面充满了毒气，人们躲在一个大楼里，搁着玻璃看外面的巨大宇宙飞船在喷杀毒剂。</p><h2 id="2023年6-22日"><a href="#2023年6-22日" class="headerlink" title="2023年6.22日"></a>2023年6.22日</h2><h3 id="红色警戒"><a href="#红色警戒" class="headerlink" title="红色警戒"></a>红色警戒</h3><p>背景是一个打仗的时代，鲍里斯是我的战斗伙伴，我们一起执行任务的时候鲍里斯牺牲了，闭眼之前他留下了自己的AK47，他交给我。然后我就成了鲍里斯，不过我有两把枪，一把AK4,一把狙。</p><h2 id="2023年6-24日"><a href="#2023年6-24日" class="headerlink" title="2023年6.24日"></a>2023年6.24日</h2><h3 id="大蜘蛛"><a href="#大蜘蛛" class="headerlink" title="大蜘蛛"></a>大蜘蛛</h3><p>家里的老院子后院有一棵树，树上不断的往下淋水，和下雨一样；看到一只黑色大蜘蛛乱跑。还有两只猫。</p><hr><p>上面写的这些是我梦中惊醒以后用手机记下来的。实际上还有很多没有记下来的，明明梦里很清晰，但是睁眼一瞬间就忘记了，也许冥冥之中真有什么在阻止我们回忆。</p><p>几乎每天晚上都会有一些比较奇葩的梦境，大部分都是一些鬼怪，还有一些怪诞梦。在我看来这些梦境全是电影情节。如果经过作家的扩展。很有可能是一个非常不错的科幻小说或者是玄幻小说。</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>皮裤</title>
    <link href="/2022/07/24/clpqt1iw3009b4cue26c0daqs.html"/>
    <url>/2022/07/24/clpqt1iw3009b4cue26c0daqs.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我一看到穿皮裤的女人就想家。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>这篇文章是我大学的时候写的，当年准备投读者，但是不知道怎么回事鸽了，现在考古出来发现确实也是好文，hiahia</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div style="font-size:150%; color: blue;"><p>我一看到穿皮裤的女人就想家。</p><p>我所在的城里的女人喜欢穿皮裤，是那种闪闪发光的。穿上皮裤，再加上一件紧紧裹在身上的上衣，涂上小红嘴，走路胯要摆动的有节奏，走在繁华热闹的步行街，男人们纷纷回头观看：啧啧，这个女人真漂亮。我一个女性朋友也喜欢穿，她是一个网络红人，身材优美，长相白净端正。”穿皮裤很漂亮啊，明星都穿。你看范冰冰都穿。” 她一边拿着手机自拍一边跟我说。</p><p>我家在遥远的大西北甘肃省某一个角落里，可能是手机普及率高了，又或者是隔壁小老太说的：”现在家家都有歪饭 (WIFI)，上网能买衣服。” 亦或是玩微信快手的人多了。这几年村里的女人也流行穿皮裤。</p><p>皮裤是我们村的女人们最喜欢穿的，每年回家总能看到村里王大妈和我三婶子穿着明晃晃的皮裤，再加上收腹的紧身羊毛衫，虽然腰上的肉使劲往外挤，但是我那些大妈婶子们却是非常自信。穿着高跟鞋，极不协调的扭着步伐走在村里正中央那条大路上。仿佛穿了皮裤就是王的女人，穿上紧身羊毛衫就是范冰冰，走在那条路上仿佛就是维密天使。在大西北零下十度的冷天下，倾斜 45 度的太阳光照射在皮裤上反射出浓浓的乡村气息。路过的二大爷忍不住回头啧啧说到：现在的婆姨们，骚的很。随后三大伯，还有旁边大狗子他爸都发出豪爽的笑声。</p><p>我妈不穿，她一直说，不敢穿，穿上两个屁股蛋子明晃晃的，柴 (羞) 滴很。</p><p>农村的男人女人们，在新疆或者青海西藏打了十个月的工，过年回来了，或许只有这会儿才是最欢乐的，短短的两个多月没有压力，村里充满欢乐的氛围。三婶子家有两个大学生，三婶子和我妈一样，最大的希望就是，好好打工赚钱，供儿子上大学，出来了找个 “坐办公室的工作”。村里的男人们也只有这个时候才能穿上那件舍不得穿的羽绒服，站在向阳的伤痕开始聊天。或者和那些婆姨娘们打情骂俏一番。</p><p>或许那是村里最快乐的时刻了吧。女人们就是觉得皮裤好看。”你也买一件，明星都穿，你看范冰冰。” 小老太 (我们那里叫比自己大 3 辈的女长辈) 跟我妈说。女人们最大的渴望就是好好买一条皮裤，买一件羽绒服，再加一双马靴。可以穿着过年，享受一下两个月的安逸。</p><p>我妈看着我说：”我们这些婆姨就不穿了，将来存钱让儿子的媳妇子穿上才好看。我们老了。” 小老太的儿子也刚毕业。我和小老太的儿子什么话都没说，低头玩手机。但是我真想赚钱了给我妈也买一条。</p><p>现在出来几年了，所以我一看到穿皮裤的女人就想起家乡那个小村庄。</p></div>]]></content>
    
    
    <categories>
      
      <category>文集-原创散文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-原创散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>羊倌</title>
    <link href="/2022/07/24/clpqt1iw4009e4cue8az255s6.html"/>
    <url>/2022/07/24/clpqt1iw4009e4cue8az255s6.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：羊倌。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>这篇文章是我大学的时候写的，纪念我们家隔壁那个放了一辈子羊的老人</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div style="font-size:150%; color: blue;">羊倌是我们领居家的老人，我从小玩到大的小伙伴阿龙的爷爷，因为老人放了一辈子羊，最喜欢的除了孙子就是羊。所以久而久之，村里人都背后称他 "羊倌"【注：甘肃方言不叫羊倌，叫放羊佬，这里为了让读者看得懂，特意写成羊倌的】。<p>羊倌是看着我长大的，他的身材高大，身高一米八左右，走路也是显得很利落，在同村那些瘦小老头子里面显得很矫健。而岁月在老人脸上留下的痕迹，越发让我觉得他和以前我看过的一部电视剧里面的老人很像但是又记不起来了。那个主人公是一个没落的将军流落民间，最终烟消云散。</p><p>羊倌对他的羊可是疼爱有加。我记得小时候陪他的所以阿龙去放羊的时候，一只羊没有回来，他爷爷差点把他吃了【意思是比较生气】，跑遍了我们家后面那几百亩地才找到，仿佛羊就是他的命。阿龙很不服气：我要是丢了爷爷肯定不会这么着急。</p><p>在我还在家的时候，羊倌每天都和我见面，他经常拿着一条鞭子，手里提着一壶水，吆喝着他的羊，从村里哪条路上过去，几乎我记事起，就没变过。哪里的草好，羊怎么吃上膘，他讲起来滔滔不绝。可是除了羊，羊倌总是沉默不语，一个人坐在小马扎上，两眼炯炯有神的看着远处不知想什么。</p><p>但是去年回家的时候，没有看到羊倌放羊了。我问我爸：最近怎么没有羊了？我爸说羊倌今年老了，走不动了，在家待着看门呢。</p><p>想起来整整有一年没有见过这个老汉了，恍然一算，羊倌都快八十了啊。自然是走不动路了。被儿子媳妇留在家里看门。</p><p>傍晚便隔着墙听到羊倌的儿子媳妇训斥：羊都喂不好，你活着干什么。</p><p>我震惊，前几年羊倌可是非常健壮的，一个人扛起一个羊都很轻松。不过路过的时候，看到羊倌什么也不说，静静坐在带了几乎一辈子的小凳子上看着外面，任凭儿子媳妇埋怨。</p><p>二十多年了，羊倌的孙女也出嫁了，孙子阿龙也大学毕业工作了，都是靠着羊倌一辈子放的那些羊。老人静静坐在院子里，瘦骨嶙峋，就好像我们西北的大土疙瘩一样，风一吹就要散架。</p><p>我在家呆了十天，临走的那天，羊倌刚好在门口，笑眯眯的跟我说：娃子要走了啊？我回应：是，晚上的火车。不同的是，羊倌这次手里撑着拐杖。</p><p>我带着行李出门，走在家门口那条路上，突然万分难过，这个村子也好像羊倌一样慢慢的老了。</p><p>羊倌站在门口看着我，我回过头看到他后面一排排的白杨树，羊倌越来越像一座雕塑，被埋没在草丛树丛中的雕塑，就和复活节岛上的那些石头人一样。正在慢慢的成为历史。</p><p>家乡越来越远，我不知道我的家乡小村庄也是否正在老去，就如羊倌一样，逐渐消失在现代繁华中。</p></div><h2 id="后补"><a href="#后补" class="headerlink" title="后补"></a>后补</h2><p>2022年7月24日，这篇文被我考古出来了，截止今天羊倌已经去世4年多了，而我也离开村子8年，但是我还是能记起来这个看着我长大的老人。</p>]]></content>
    
    
    <categories>
      
      <category>文集-原创散文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-原创散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南方的秋天</title>
    <link href="/2022/07/24/clpqt1iw5009j4cue5oht254k.html"/>
    <url>/2022/07/24/clpqt1iw5009j4cue5oht254k.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：大学的秋天。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>这篇文章是我大学的时候写的，当年准备投读者，但是不知道怎么回事鸽了，现在考古出来发现确实也是好文，hiahia</strong></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><div style="font-size:150%; color: blue;"><p>又是一个秋天。</p><p>一个人走在这条石板路上，石板缝隙间的青草好像是刚发芽，夹杂着花香的气味，椰子树也愈发显得青翠起来。太阳刚下山，在山头另一面，阳光映红了半边天，我站在河边迎面吹来的风，是带有温暖感觉的那种。令人神往。</p><p>不错，这便是南方的秋天。</p><p>隐约记得，若干年前，我还在西北那个乡下中学的时候，某一节语文课，老师要我们写关于秋天的文章。记得那时候真是绞尽脑汁想啊：我们的秋天有什么可以写的到处是光秃秃的一片，丝毫看不到生机可言，始终体会不到 “自古逢秋悲寂寥，我言秋日胜春朝 ” 的洒脱，倒是感觉的到 “悲寂寥”。没错啊，秋天就是很伤感的季节，古代的诗人们，都写的很凄凉，“枯藤老树昏鸦，到西风瘦马” 大概他们看到的和我看到的一样罢。自然我的作文始终写的不好，因为，压根就感觉不到秋天除了悲凉，还能给我带来什么不一样的感觉。</p><p>直到今天，我到了南方，才深刻感觉到了不一样的秋天，原来秋天还可以赏花散步，也可以不用穿秋衣秋裤。曾几何时，秋天将我折磨的咬牙切齿，家乡的秋天，温差很大，早晚温差要 20 度左右，早上不穿棉袄是没有勇气出门的。那一阵阵清晨的秋风，总是得我不由得打寒战，紧紧地裹紧衣服。</p><p>南方的秋天确实是不一样的，沐浴在南方温暖的阳光下，享受的同时，记忆也瞬间回到了西北那深邃而又高冷的天空底下我大概已经猜得出来了，这个季节，家乡的人们已经开始嘻里哈啦了（我们那边的一种说法，形容人冷的时候呼气取暖的动作） 。现在的我，貌似是早就忘记了西北的寒风，在阳光下穿着夏装略带兴奋。不由得联想到，古代的文人墨客，但凡是文章写得很好的，基本都来自南方，“触景生情” 并非没有道理，青山绿水见的多了，阳光暖的昏昏欲睡的时候，自然能写出优美的诗句 “日出江花红胜火，春来江水绿如蓝”，好像用在这个季节也没有不恰当，改一下 “秋来江水绿如蓝” 也是很好的。</p><p>一转眼，面前已经过去了一个穿着长裙的姑娘，我慢慢的走在后面，看着她的背影竟然不由得走过了路口，我停下来，看着她慢慢走远，直到消失在拐角的路灯下。暮然，我记起来，是否有这样一个穿着长裙的姑娘在我的记忆里留下了印记，却也只是灵光一现，始终无法考证了，回忆的是什么？</p><p>回来的路很安静，居然越来越感觉到了闷热，鼻尖好像是出了汗，走了几步，我便把外套脱了。</p></div>]]></content>
    
    
    <categories>
      
      <category>文集-原创散文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-原创散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>书生的苦闷</title>
    <link href="/2022/07/24/clpqt1iw200974cue9w9g7ytv.html"/>
    <url>/2022/07/24/clpqt1iw200974cue9w9g7ytv.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：今天是我的28岁生日，写了个顺口，纪念一下吧。</p><span id="more"></span><h1 id="书生的苦闷"><a href="#书生的苦闷" class="headerlink" title="书生的苦闷"></a>书生的苦闷</h1><p>今天是我的28岁生日，写了个顺口，纪念一下吧。</p><div style="text-align:center;"><p><strong>书生满腹经纶才华横溢能文能武</strong><br><strong>寒窗二十载只为一览翰林之书</strong><br><strong>路人说你不如去县衙谋取出路</strong><br><strong>也不蹉跎你那一身书卷武功</strong><br><strong>县衙的门神是无数人的精神</strong><br><strong>书生意气风发为了状元赶路</strong><br><strong>可高贵的文他只参透那七股</strong><br><strong>差人说你上不了榜不如当个候补</strong><br><strong>书生走在回乡的路，书生他很闷苦</strong><br><strong>书生走在回乡的路，书生他很闷苦</strong></p></div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用C模拟golang的defer</title>
    <link href="/2022/06/07/clpqt1iva005v4cue85s17711.html"/>
    <url>/2022/06/07/clpqt1iva005v4cue85s17711.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：用C模拟golang的defer-&gt;<br> <span id="more"></span></p><h1 id="用C模拟golang的defer"><a href="#用C模拟golang的defer" class="headerlink" title="用C模拟golang的defer"></a>用C模拟golang的defer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知，Golang有个defer语法，用来在<strong><em>计算之后, 返回之前</em></strong>干一些事情，很适合我们释放资源和善后处理等，比如下面这个文件操作：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    f,err := os.Open(<span class="hljs-string">&quot;demo.log&quot;</span>)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-built_in">panic</span>(err)    &#125;    <span class="hljs-keyword">defer</span> f.Close()&#125;</code></pre><p>这让我们写代码的时候非常方便。但是C没有这个特性怎么办呢？其实可以用一定的手段来实现。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="Sejmp"><a href="#Sejmp" class="headerlink" title="Sejmp"></a>Sejmp</h2><p>C 库宏 int setjmp(jmp_buf environment) ：创建本地的jmp_buf缓冲区并且初始化，用于将来跳转回此处。这个子程序保存程序的调用环境于env参数所指的缓冲区，env将被longjmp使用。如果是从setjmp直接调用返回，setjmp返回值为0。如果是从longjmp恢复的程序调用环境返回，setjmp返回非零值。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;setjmp.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *err)</span></span>;<span class="hljs-keyword">static</span> jmp_buf G_ENV;<span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> G_ERR[<span class="hljs-number">20</span>];<span class="hljs-comment">//--------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *err)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">strcpy</span>(G_ERR, err);    longjmp(G_ENV, <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">defer</span><span class="hljs-params">(process *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (setjmp(G_ENV) &gt; <span class="hljs-number">0</span>)    &#123;        p(G_ERR);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">http_post1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">throw</span>(<span class="hljs-string">&quot;302: Host not found&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">http_post2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;200: ok\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">defer_func</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *err)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Catched Exceptions: %s\n&quot;</span>, err);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// 模拟实现 defer</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    defer(defer_func);    http_post1(); <span class="hljs-comment">// 模拟异常</span>    http_post2(); <span class="hljs-comment">// 模拟正常</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>我们很巧妙的使用setjmp来实现了模拟defer。其实setjmp有更多高级玩法，有待大家去发现，这里就不多赘述了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://man7.org/linux/man-pages/man3/setjmp.3.html">https://man7.org/linux/man-pages/man3/setjmp.3.html</a></li><li><a href="https://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html">https://www.cnblogs.com/hazir/p/c_setjmp_longjmp.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CS基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言片段</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个年轻人坠入消费主义陷阱的过程</title>
    <link href="/2022/06/01/clpqt1iw1008z4cue33uy0thv.html"/>
    <url>/2022/06/01/clpqt1iw1008z4cue33uy0thv.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：一个年轻人坠入消费主义陷阱的过程</p><span id="more"></span><h1 id="一个年轻人坠入消费主义陷阱的过程"><a href="#一个年轻人坠入消费主义陷阱的过程" class="headerlink" title="一个年轻人坠入消费主义陷阱的过程"></a>一个年轻人坠入消费主义陷阱的过程</h1><p>我和大家说一种最最可怕的，它的可怕之处，就在于它不是摧残你的身体，而是攻击你的精神。</p><p>它会逐渐麻痹人的神经，让人慢慢陷进去。</p><p>你还在沾沾自喜的时候，其实已经被它洗了脑。</p><p>我接下来说的这三步，就是一个年轻人坠入消费主义陷阱的过程，可谓层层递进，步步深入，答应我，一定要看到最后。</p><p>第一步，超出能力范围的物质享受。</p><p>大家有没有考虑过这么一件事：</p><p>现在的电视剧，大多都是在表演北上广深的生活状态；</p><p>但是更多的中国人，其实都是乡村爱情的状态。</p><p>你喜欢看得是那些有着俊朗外形的演员，开着豪车，带着名表，在高端写字楼里出入。</p><p>就连剧组想演绎他们困难的场景时，演员们也穿着你买不起的名牌服饰，用着最新款的手机，喝着昂贵的红酒，用最高端的纸巾擦眼泪。</p><p>打开抖音，满屏幕都是让人惊叹的跑车和别墅。</p><p>打开知乎，动辄告诉你月入一万的人生活有多么艰难。</p><p>打开微博，推荐给你的都是几千块的包和化妆品。</p><p>社交媒体上，你会看到那些无比精致的年轻人，住着精装的loft，开着自己的“代步车”，用着电动牙刷、机械键盘、HiFi耳机，穿着国外的“品控”极好的简约服饰，踩着马拉松级别的跑鞋。</p><p>久而久之，你就会觉得这些消费水平是很普遍的。</p><p>消费主义，就是这样在你不知不觉之间侵入了你的意识，你慢慢地开始认同这种消费观念，购买超出你经济能力的东西。</p><p>你认同他们所说的体验感和高级感，感觉他们演绎的就是当代年轻人的样子，以为他们推荐的东西都是当代年轻人支付的起的。</p><p>于是，月薪三千的你，穿上了名牌服饰，用上了昂贵的化妆品，开始玩起了单反、钢笔、名表、键盘、耳机，成为了“精致”的自己。</p><p>但是你想过么，他们向你展示的一切，是中国人的平均水平么？</p><p>与你的生活状态匹配么？</p><p>他们向你推荐的东西，你都能享受的起么？</p><p>你在犯花痴的时候似乎忘了一件事——他们传递的信息本不属于你。</p><p>抖音记录的，其实只是有钱人的生活。</p><p>知乎分享的，只是中上层社会的见解。</p><p>微博热搜上，也只是中等以上家庭所关心的热点。</p><p>他们用这些演绎出来的生活状态吸引你，然后利用你的羡慕，继续赚你的钱。</p><p>第二步，超出能力范围的经济收入。</p><p>有了第一步之后，很多人就把自己的消费水平提升到了一个高段位，有的已经到了自己无法支付的地步，于是他们就开始想方设法的“赚钱”。</p><p>但是问题就在于，任何一个人，都很难赚到超出你认知范围和能力范围的钱。</p><p>赚钱的道路大多是漫长而曲折的，需要时间的积累，技术的提升，经验的增加。这些翻山越岭才能得到的“远水”，显然无法解他们的“近渴”。</p><p>于是，他们开始找寻更容易的路子。</p><p>很多女生开始赚一些不可示人的钱。</p><p>这钱赚的快，却会把一个人的自尊、自爱、自信全部踩在地上狠狠地碾压摩擦。</p><p>直至你两眼呆滞，像机器一样继续做那些不堪入目的事情。</p><p>男生更多的是去研究数字货币、p2p、股票之类的，关键是年轻人真的能研究明白这里面的逻辑么？这些东西对于他们来说基本就跟赌博无异。</p><p>但是这种钱赚起来快到你不敢相信。可能跟你说着话，十几万就入账了；可能刚刚计划好花这笔钱，又全都没了。</p><p>这种大开大合的收入，或者两腿开合的收入，会很快摧毁你在学校教育中建立起来的价值观。</p><p>技术、能力、努力这些赚钱的要素通通被一下推翻，你出卖色相的可能是他们的几十倍，你手机一点可能赚到他们的几百倍。</p><p>你会更加巩固第一步形成的消费观，花钱越来越大手大脚。</p><p>直到某天，女的老了。</p><p>直到某天，男的孤注一掷，输到负债累累。</p><p>那时候，你才发现，你没有钱了，也没有赚钱的资本了，你有的只是大手大脚花钱的本事。</p><p>第三步，超出偿还能力的借贷。</p><p>说到借贷，我总是会不自觉的想到这其中最阴暗最恶毒的一种——裸贷。</p><p>不是因为我下流，而是因为这种借贷对女生伤害实在是太大了，毫不夸张的说，相当于杀死她的所有信仰和希望。</p><p>你们想过么？那些女生为什么会去做这些事——只为借几千块钱，还要支付很高的利息。</p><p>我一开始以为她们肯定是因为深陷债务危机、经济拮据、走投无路，所以才会铤而走险。</p><p>可事实刚好相反。</p><p>这部分人一开始选择裸贷的时候几乎都没有债务危机。</p><p>她们裸贷的目的，很多就是为了换手机，或者去整容，更有甚者只是想买一个贵一点的包。</p><p>我一开始也特别不理解，至于么？</p><p>但是你想想，那种消费主义的观念，早就已经侵蚀了她们的理智。那种使用昂贵物质的享受，那种被完全洗脑之后的疯狂，广告营造出的那种奢华、高贵、让别人敬仰的感觉，会让她们欲罢不能。</p><p>8年前，iphone4S刚开始卖的时候，甚至有人卖掉一个肾去买它，现在8年过去，他身体暴瘦，大小便不能自理。</p><p>你能理解他的行为么？</p><p>你怎么可能用理智的思维去理解他们已经被颠覆的三观？</p><p>结束</p><p>消费主义对年轻人思想的侵蚀是悄无声息的，如果我们沉浸在那些艺人拍摄的广告中，沉浸在网红推荐的各种消费品当中，不假思索的接受他们灌输的一切，就会慢慢地被物质和别人的眼光所绑架，最终失去自我。</p><p>与其去看那些人给你们推荐的消费品，听他们说那些贵的离谱的东西的体验感，不如沉下心来多看点书，多看看书里关于人性、关于社会、关于未来的探讨。</p><p>你读的书越多，你的偏见就越少，你就越能够认清自己的价值，你就会慢慢想清楚：</p><p>中国年轻人的平均水平到底是什么样子的？</p><p>中国人最应该接受的文化熏陶是什么样子的？</p><p>中国最广大人民群众的文化娱乐方式应该是怎样的？</p><p>我们按照社交媒体和网络上传递给我们的价值取向在生活，却忘记了，除去北上广深之外的地方，才是最真实的中国。</p><p>我们去购买他们推荐的东西，却忘记了，我们根本就不具备和他们一样的经济实力。</p><p>这种配不上的消费和享受，会慢慢的侵蚀一个人的价值观，甚至把你废掉。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一件心痛的事情</title>
    <link href="/2022/06/01/clpqt1iw200934cue6yqbhuxb.html"/>
    <url>/2022/06/01/clpqt1iw200934cue6yqbhuxb.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：老婆怀孕后被老家强制要求打疫苗。。。。。</p><span id="more"></span><h1 id="记录一件心痛的事情"><a href="#记录一件心痛的事情" class="headerlink" title="记录一件心痛的事情"></a>记录一件心痛的事情</h1><p><strong><em>甘肃老家政府的公务员们为了自己的帽子，竟然给家里老人施压让远在千里之外的深圳的我们打疫苗!</em></strong></p><p>老婆去打了科兴。但是不知道的是已经怀孕两周！未知怀孕后打了新冠疫苗。知道这事后我觉得后果很严重，有可能带来3个家庭的毁灭和一个悲惨的人生，当时我发动所有人脉资源来解决这个问题发现他们解决不了，甚至钟南山 ，卫健委，都不能给我明确建议（全部说不确定），当时我们很绝望，一度认为孩子不能要了，真的感觉很痛苦，我们的首胎就这么不幸。但是我那天晚上想了一下，仿佛不对劲：所有给我建议的人说的都是：“如果是我，我就XXX”，或者是：“我觉得XXX”，当时觉得这种回答很不靠谱。于是我自己查资料（常见药品原理），看论文（世卫组织），看案例（辉瑞直接建议孕妇接种，因此看到了希望），看统计数据很久，做出了留下的决定。而且我们一家人对我这个决定很赞同我老婆也很开心,终于有了希望。</p><h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><ul><li>第一时间发动人脉解决,事情发生后我没有盲目听取任何人的个人主观 建议</li><li>主动了解科学知识和药理，以及我国几种疫苗之间的区别</li><li>了解了一下常见药品的毒性和对胎儿的伤害（青霉素，头孢）</li><li>对比灭活疫苗后得出结论：疫苗伤害胎儿的概率几乎比头孢、青霉素低</li><li>看了卫健委的发文，以及辉瑞的数据</li></ul><h2 id="附-新冠病毒疫苗接种技术指南（第一版）："><a href="#附-新冠病毒疫苗接种技术指南（第一版）：" class="headerlink" title="附 新冠病毒疫苗接种技术指南（第一版）："></a>附 新冠病毒疫苗接种技术指南（第一版）：</h2><hr><p>如果在接种后怀孕或在未知怀孕的情况下接种了疫苗，基于对上述疫苗安全性的理解，不推荐仅因接种新冠病毒疫苗而采取特别医学措施（如终止妊娠），建议做好孕期检查和随访。对于有备孕计划的女性，不必仅因接种新冠病毒疫苗而延迟怀孕计划。<br>虽然目前尚无哺乳期女性接种新冠病毒疫苗对哺乳婴幼儿有影响的临床研究数据，但基于对疫苗安全性的理解，建议对新冠病毒感染高风险的哺乳期女性（如医务人员等）接种疫苗。考虑到母乳喂养对婴幼儿营养和健康的重要性，参考国际上通行做法，哺乳期女性接种新冠病毒疫苗后，建议继续母乳喂养。</p><hr><h2 id="附-辉瑞统计数据"><a href="#附-辉瑞统计数据" class="headerlink" title="附 辉瑞统计数据"></a>附 辉瑞统计数据</h2><p><a href="https://covid.cdc.gov/covid-data-tracker/#pregnant-population">https://covid.cdc.gov/covid-data-tracker/#pregnant-population</a><br><a href="https://www.cdc.gov/coronavirus/2019-ncov/covid-data/investigations-discovery/assessing-risk-factors.html">https://www.cdc.gov/coronavirus/2019-ncov/covid-data/investigations-discovery/assessing-risk-factors.html</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>今天是2022年6.1号儿童节，我们的小家伙已经出生一个月半了，很健康也很可爱。我们感谢上天赐予我们的这个小宝宝。她像一个小天使一样来到我的世界。当初我的选择是对的，如果失去这个小家伙我可能会后悔一辈子!</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个非常简单的HASH函数</title>
    <link href="/2022/06/01/clpqt1iv7005h4cue6uq14tum.html"/>
    <url>/2022/06/01/clpqt1iv7005h4cue6uq14tum.html</url>
    
    <content type="html"><![CDATA[<h1 id="一个非常简单的HASH函数"><a href="#一个非常简单的HASH函数" class="headerlink" title="一个非常简单的HASH函数"></a>一个非常简单的HASH函数</h1><pre><code class="hljs c"><span class="hljs-comment">// 参考：https://zhuanlan.zhihu.com/p/54017133</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEW_LONG() (unsigned long *)malloc(sizeof(unsigned long))</span><span class="hljs-comment">//ASCII HASH 函数：把字符串的ASCII码的二进制拿出来拼一个整数</span><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">ASCII_HASH</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">char</span> str[], <span class="hljs-keyword">int</span> len)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *v = NEW_LONG();    <span class="hljs-comment">// 内存转换，实际上是吧字符串的值直接给干到long那边去</span>    <span class="hljs-comment">// 假设字符串是 &quot;012&quot; 则对应的内存为:48,49,50,转到long那边去</span>    <span class="hljs-comment">// 其实就是：48 49 50 00 。。。。</span>    <span class="hljs-comment">// 如果字符串是确定的，则long一定是唯一的一个数</span>    <span class="hljs-comment">// 不好的一点是，当字符串的值多于32个（unsigned long）的时候就会溢出，增加碰撞的几率</span>    <span class="hljs-built_in">memcpy</span>(v, str, len);    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> hash_value = ((*v) % size);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[LOG] HASH(&#x27;%s&#x27;) ==&gt; %lu, at entry[%lu]\n&quot;</span>, str, *v, hash_value);    <span class="hljs-keyword">return</span> hash_value;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;b2&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;c3&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;d4&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;e5&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;f6&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;g7&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;h8&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;i9&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test === Hash:%lu\n&quot;</span>, ASCII_HASH(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;j0&quot;</span>, <span class="hljs-number">2</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C 编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个非常简单的解释器</title>
    <link href="/2022/06/01/clpqt1iv8005l4cue9sw20st1.html"/>
    <url>/2022/06/01/clpqt1iv8005l4cue9sw20st1.html</url>
    
    <content type="html"><![CDATA[<h1 id="一个非常简单的解释器-BrainFuck"><a href="#一个非常简单的解释器-BrainFuck" class="headerlink" title="一个非常简单的解释器:BrainFuck"></a>一个非常简单的解释器:BrainFuck</h1><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-comment">//</span><span class="hljs-comment">// 此处的是Brainfuck源码，从文件里面读</span><span class="hljs-comment">//</span><span class="hljs-keyword">char</span> program[] = <span class="hljs-string">&quot;++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.&quot;</span>;<span class="hljs-comment">// 内存大小默认4k</span><span class="hljs-keyword">int</span> data[<span class="hljs-number">1024</span> * <span class="hljs-number">4</span>];<span class="hljs-keyword">int</span> pc = <span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> token = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> current_pos = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> <span class="hljs-built_in">stack</span> = <span class="hljs-number">0</span>;<span class="hljs-comment">//-----------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *v[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> ((token = program[pc]))    &#123;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;&gt;&#x27;</span>)        &#123;            current_pos++;        &#125;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;&lt;&#x27;</span>)        &#123;            current_pos--;        &#125;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;+&#x27;</span>)        &#123;            data[current_pos]++;        &#125;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;-&#x27;</span>)        &#123;            data[current_pos]--;        &#125;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;.&#x27;</span>)        &#123;            putc(data[current_pos],                 <span class="hljs-built_in">stdout</span>);        &#125;        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">&#x27;,&#x27;</span>)        &#123;            data[current_pos] = getc(<span class="hljs-built_in">stdin</span>);        &#125;        <span class="hljs-keyword">while</span> (token == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; !data[current_pos])        &#123;            <span class="hljs-keyword">if</span> (program[pc] == <span class="hljs-string">&#x27;[&#x27;</span>)            &#123;                <span class="hljs-built_in">stack</span>++;            &#125;            <span class="hljs-keyword">if</span> (program[pc] == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; <span class="hljs-built_in">stack</span>-- == <span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">break</span>;            &#125;            pc++;        &#125;        <span class="hljs-keyword">while</span> (token == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; data[current_pos])        &#123;            <span class="hljs-keyword">if</span> (program[pc] == <span class="hljs-string">&#x27;]&#x27;</span>)            &#123;                <span class="hljs-built_in">stack</span>++;            &#125;            <span class="hljs-keyword">if</span> (program[pc] == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; <span class="hljs-built_in">stack</span>-- == <span class="hljs-number">1</span>)                <span class="hljs-keyword">break</span>;            pc--;        &#125;        pc++;    &#125;&#125;</code></pre><p>可玩玩这个：<a href="https://ashupk.github.io/Brainfuck/brainfuck-visualizer-master/index.html">https://ashupk.github.io/Brainfuck/brainfuck-visualizer-master/index.html</a><br>图形化演示，比较有助于理解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C 编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell编程之-常见性能指标获取</title>
    <link href="/2022/06/01/clpqt1iv9005o4cuebihj4bk7.html"/>
    <url>/2022/06/01/clpqt1iv9005o4cuebihj4bk7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Shell编程之-常见性能指标获取"><a href="#Shell编程之-常见性能指标获取" class="headerlink" title="Shell编程之-常见性能指标获取"></a>Shell编程之-常见性能指标获取</h1><pre><code class="hljs bash">IP: hostname -IHostname: hostname -a磁盘: df -Bmroot用量: df -Bm | awk <span class="hljs-string">&#x27;NR==2 &#123;print $1, $4 , $5&#125;&#x27;</span>内存: cat /proc/meminfo特定程序的内存:CPU : awk <span class="hljs-string">&#x27;&#123;u=$2+$4; t=$2+$4+$5; if (NR==1)&#123;u1=u; t1=t;&#125; else print ($2+$4-u1) * 100 / (t-t1) &quot;%&quot;; &#125;&#x27;</span> &lt;(grep <span class="hljs-string">&#x27;cpu &#x27;</span> /proc/<span class="hljs-built_in">stat</span>) &lt;(sleep 0.5;grep <span class="hljs-string">&#x27;cpu &#x27;</span> /proc/<span class="hljs-built_in">stat</span>)RAM: free -m | awk <span class="hljs-string">&#x27;NR==2&#123;printf &quot;%.2f%%\n&quot;, $3*100/$2 &#125;&#x27;</span>磁盘 : df -h | awk <span class="hljs-string">&#x27;$NF==&quot;/&quot;&#123;printf &quot;%s\n&quot;, $5&#125;&#x27;</span>CPU % used : top -bn1 | grep load | awk <span class="hljs-string">&#x27;&#123;printf &quot;%.2f%%\n&quot;, $(NF-2)&#125;&#x27;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Shell编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我和代码的起始</title>
    <link href="/2022/06/01/clpqt1ivp007m4cue1oagcva2.html"/>
    <url>/2022/06/01/clpqt1ivp007m4cue1oagcva2.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：我是怎么开始技术之路的。</p><span id="more"></span><ul><li>2010-2013年开始玩VB，做了些小游戏，比如像素小鸟，赛车，飞机等</li><li>2013年我高考名落孙山，当时很绝望，选择了复读</li><li>2014年第二次高考我还是上了个末尾本科，坐T308离开老家去福建上大学，读的专业叫“电子信息工程”</li><li>2014年外面的朋友给我说比特币的时候，我完全不懂</li><li>2014年我认识了个老乡学姐，经常骚扰她</li><li>2015年沉迷安卓开发，我甚至还做了个黄色网站浏览器类APP</li><li>2016年接触到了火币网的时候，他还被我们吐槽是骗子网站</li><li>2016年我和喜欢的学姐在一起了</li><li>2017年开始玩物联网，自己做平台，试图想替代yealink，但是他倒闭了</li><li>2017年几乎做了国内第一个比较明确的物联网平台：easylinker，但是烂尾了，不过值得骄傲的是当年的架构设计今天很多公司还在玩，甚至还成了标准，当时接触EMQ的时候他才2.0版本，今天都5.0了</li><li>2018年大学毕业做了半年嵌入式，在第一个公司做的产品今天还没变</li><li>2018年我还在一个福建黑社会分子的公司干了2个月</li><li>2018年我还在一个福建传销公司干了2个月</li><li>2019年在中科院继续做物联网平台，此时对物联网平台已经基本玩的很透彻了，完全可以从零开始设计一套iothub产品</li><li>2020年转向做基础设施，开始玩物联网消息中间件和底层技术，这段时间我的计算机理论基础进步很快，得益于《深入理解操作系统原理》</li><li>2021年情人节我和学姐结婚了</li><li>2021年转边缘和微服务方向，开始研究边缘网关技术，期间做了些嵌入式系统软件，2021年到深圳后我的行业认识有了很大提升。现阶段对物联网行业有了新的认识，完全可以从云、边、端一体设计物联网类产品。</li></ul>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个大胆的想法</title>
    <link href="/2022/06/01/clpqt1iw0008w4cue79dq95vl.html"/>
    <url>/2022/06/01/clpqt1iw0008w4cue79dq95vl.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：一个大胆的想法。。。。。。</p><span id="more"></span><h1 id="一个大胆的想法"><a href="#一个大胆的想法" class="headerlink" title="一个大胆的想法"></a>一个大胆的想法</h1><div style="font-size:150%; color: blue;"><p>按照现在这个劣币驱逐良币的趋势，绝大多数失败者涌入教师和公务员群体中，尤其以后的中小学教师群体可能是整个知识分子中最没有信仰和知识的群体。我想以后何不搞个教育类的互助平台：家长自己组团辅导子女。高层次家长的技能一般来说都是很强的，所以每个领域内的强者可以负责教一个部分，比如我可以教数学、英语等。</p></div>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业至今住过的地方</title>
    <link href="/2022/06/01/clpqt1ivq007q4cue5rip6fay.html"/>
    <url>/2022/06/01/clpqt1ivq007q4cue5rip6fay.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：记录一下毕业至今住过的地方。</p><span id="more"></span><h2 id="毕业至今住过的地方"><a href="#毕业至今住过的地方" class="headerlink" title="毕业至今住过的地方"></a>毕业至今住过的地方</h2><h3 id="2017-福建省福州晋安区软件园丞相坊"><a href="#2017-福建省福州晋安区软件园丞相坊" class="headerlink" title="2017 福建省福州晋安区软件园丞相坊"></a>2017 福建省福州晋安区软件园丞相坊</h3><p>  大学实习的第一个公司在这里，住在隔断房</p><h3 id="2017-福建省福州晋安区软件五凤家园"><a href="#2017-福建省福州晋安区软件五凤家园" class="headerlink" title="2017 福建省福州晋安区软件五凤家园"></a>2017 福建省福州晋安区软件五凤家园</h3><p>  女朋友工作在这里，住在一个条件很差的隔断房</p><h3 id="2017-福建省福州台江区江夏小区"><a href="#2017-福建省福州台江区江夏小区" class="headerlink" title="2017 福建省福州台江区江夏小区"></a>2017 福建省福州台江区江夏小区</h3><p>  女朋友工作在这里，住在隔断房，同时我在厦门集美</p><h3 id="2018-福建省厦门集美区华侨大学后街"><a href="#2018-福建省厦门集美区华侨大学后街" class="headerlink" title="2018 福建省厦门集美区华侨大学后街"></a>2018 福建省厦门集美区华侨大学后街</h3><p>  人生第一个工作公司在厦门集美软件园，在村里，能闻到鸡屎味</p><h3 id="2018-福建省马尾区东方名城"><a href="#2018-福建省马尾区东方名城" class="headerlink" title="2018 福建省马尾区东方名城"></a>2018 福建省马尾区东方名城</h3><p>  人生黑暗时刻，被骗子骗了，几个月了全身上下只有1000元</p><h3 id="2019-福建省福州苍山万达后面的那个悦榕公馆"><a href="#2019-福建省福州苍山万达后面的那个悦榕公馆" class="headerlink" title="2019 福建省福州苍山万达后面的那个悦榕公馆"></a>2019 福建省福州苍山万达后面的那个悦榕公馆</h3><p>  女朋友在仓山万达上班，住在个小隔断房</p><h3 id="2019-福建省福州闽侯县中海寰宇天下"><a href="#2019-福建省福州闽侯县中海寰宇天下" class="headerlink" title="2019 福建省福州闽侯县中海寰宇天下"></a>2019 福建省福州闽侯县中海寰宇天下</h3><p>  我们两个都去闽侯工作了，当时我在中科院呆了一年，我们住在小SOHO公寓</p><h3 id="2020-杭州余杭区未来科技城申鼎大厦亿捷公寓"><a href="#2020-杭州余杭区未来科技城申鼎大厦亿捷公寓" class="headerlink" title="2020 杭州余杭区未来科技城申鼎大厦亿捷公寓"></a>2020 杭州余杭区未来科技城申鼎大厦亿捷公寓</h3><p>  初到杭州在酒店呆了2月，最孤单的时候，那时候我还生病躺了半月</p><h3 id="2020-浙江省杭州余杭区仓溢绿苑"><a href="#2020-浙江省杭州余杭区仓溢绿苑" class="headerlink" title="2020 浙江省杭州余杭区仓溢绿苑"></a>2020 浙江省杭州余杭区仓溢绿苑</h3><p>  从酒店出来后到一个小区里面住进隔断房，是我最压抑最不开心的一年</p><h3 id="2020-浙江省杭州下沙区松合时代广场"><a href="#2020-浙江省杭州下沙区松合时代广场" class="headerlink" title="2020 浙江省杭州下沙区松合时代广场"></a>2020 浙江省杭州下沙区松合时代广场</h3><p>  女朋友在杭州工作地附近，但是她工作的不开心，后来就撤了</p><h3 id="2021-广东省深圳保安坪洲轻铁花园"><a href="#2021-广东省深圳保安坪洲轻铁花园" class="headerlink" title="2021 广东省深圳保安坪洲轻铁花园"></a>2021 广东省深圳保安坪洲轻铁花园</h3><p>  被目前公司的傻子 Hr 坑到深圳宝安区住了一个月</p><h3 id="2021-广东省深圳福田上沙塘晏村"><a href="#2021-广东省深圳福田上沙塘晏村" class="headerlink" title="2021 广东省深圳福田上沙塘晏村"></a>2021 广东省深圳福田上沙塘晏村</h3><p>  城中村小公寓，这个村还挺不错的，房东比较坑</p><h3 id="2021-广东省深圳福田上沙沙尾西村"><a href="#2021-广东省深圳福田上沙沙尾西村" class="headerlink" title="2021 广东省深圳福田上沙沙尾西村"></a>2021 广东省深圳福田上沙沙尾西村</h3><p>  目前住址，城中村小公寓，这个村还挺不错的，2700元，一房一厅，就是外面环境脏乱差</p><hr><p><strong><em>记录一下吧，这些底层的磨难让人刻骨铭心。想起来当年走弯路的时候真的难，好在都熬过来了。</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速搭建开发环境</title>
    <link href="/2022/06/01/clpqt1iva005t4cue1dn64oy3.html"/>
    <url>/2022/06/01/clpqt1iva005t4cue1dn64oy3.html</url>
    
    <content type="html"><![CDATA[<h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><blockquote><p>所有有密码的账户：root，密码：public</p></blockquote><h2 id="cassradb"><a href="#cassradb" class="headerlink" title="cassradb"></a>cassradb</h2><pre><code class="hljs shell">docker run --rm -p 9042:9042 --name test-cassandra -d cassandra</code></pre><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><pre><code class="hljs shell">docker run --rm -p 3306:3306 --name test-mysql8 -d -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=test_db mysql --default-authentication-plugin=mysql_native_password</code></pre><h2 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h2><pre><code class="hljs shell">docker run --rm -p 8123:8123 -p 9009:9009 -p 9000:9000 -d --name=test-clickhouse --ulimit nofile=262144:262144 yandex/clickhouse-serverdocker run -d --rm -e CLICKHOUSE_DB=my_database -e CLICKHOUSE_USER=root -e CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT=1 -e CLICKHOUSE_PASSWORD=root -p 9000:9000/tcp yandex/clickhouse-server</code></pre><h2 id="timescale"><a href="#timescale" class="headerlink" title="timescale"></a>timescale</h2><pre><code class="hljs shell">docker run --rm -p 5432:5432 --name test-timescaledb -d -e POSTGRES_USER=root -e POSTGRES_PASSWORD=public -e POSTGRES_DB=test timescale/timescaledb</code></pre><h2 id="pgsql"><a href="#pgsql" class="headerlink" title="pgsql"></a>pgsql</h2><pre><code class="hljs shell">docker run --rm -p 5433:5432 --name test-postgres -d -e POSTGRES_USER=root -e POSTGRES_PASSWORD=public -e POSTGRES_DB=test postgres</code></pre><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><pre><code class="hljs shell">docker run --rm -p 6379:6379 --name test-redis6 -d redis</code></pre><h2 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h2><pre><code class="hljs shell">docker run --rm -p 8086:8086 --name test-infulx -d -e INFLUXDB_USER=root -e INFLUXDB_PASSWORD=public influxdb</code></pre><h2 id="TD"><a href="#TD" class="headerlink" title="TD"></a>TD</h2><pre><code class="hljs shell">docker run --rm -p 6030:6030 -p 6035:6035 -p 6041:6041 -p 6030-6040:6030-6040/udp -d --name test-tdengine tdengine/tdengine</code></pre><h2 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h2><pre><code class="hljs shell">docker run --rm -p 27017:27017 --name test-mongo -d -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=public mongo</code></pre><h2 id="一次性脚本"><a href="#一次性脚本" class="headerlink" title="一次性脚本"></a>一次性脚本</h2><pre><code class="hljs shell">docker run --rm -p 9042:9042 --name test-cassandra -d cassandradocker run --rm -p 3306:3306 --name test-mysql8 -d -e MYSQL_ROOT_PASSWORD=public -e MYSQL_DATABASE=mqtt mysql --default-authentication-plugin=mysql_native_passworddocker run --rm -p 8123:8123 -p 9009:9009 -p 9000:9000 -d --name=test-clickhouse --ulimit nofile=262144:262144 yandex/clickhouse-serverdocker run --rm -p 5432:5432 --name test-timescaledb -d -e POSTGRES_USER=root -e POSTGRES_PASSWORD=public -e POSTGRES_DB=test timescale/timescaledbdocker run --rm -p 5433:5432 --name test-postgres -d -e POSTGRES_USER=root -e POSTGRES_PASSWORD=public -e POSTGRES_DB=test postgresdocker run --rm -p 6379:6379 --name test-redis6 -d redisdocker run --rm -p 8086:8086 --name test-infulx -d -e INFLUXDB_USER=root -e INFLUXDB_PASSWORD=public influxdbdocker run --rm -p 6030:6030 -p 6035:6035 -p 6041:6041 -p 6030-6040:6030-6040/udp -d --name test-tdengine tdengine/tdenginedocker run --rm -p 27017:27017 --name test-mongo -d -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=public mongo</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雨夜他乡遇故知</title>
    <link href="/2022/05/26/clpqt1ivn007a4cue2hhe4dwr.html"/>
    <url>/2022/05/26/clpqt1ivn007a4cue2hhe4dwr.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：雨夜他乡遇故知。</p><span id="more"></span><p>这两天深圳是真的冷，我的脚趾头都懂得发疼。昨天下午，同村的小伙伴鹏来找我玩，我走在路上都瑟瑟发抖。<br>我们同是1994年的90后，是从小玩到大，经历了小学，初中，高中，一个村里知根知底的伙伴，如今一不小心，就快奔三步入中年了。让我感慨的是，我们这几年在村里都难得见一面，却在将近3000公里以外的深圳见到了。<br>鹏和我一样，这几年也在外面跑，去过广州，深圳，兰州，去年又回到了深圳，而我也是去年从杭州折到深圳的，同样外面跑了这几年，聊着这些年在外的生活都是能心照不宣。感慨我们都不容易。喝点茶聊聊以前的时光，聊起了小时候一群小孩子玩土，聊起了当年在乡下集体中学吃的大锅饭，还聊起了小学班主任，数学老师，一瞬间我突然感觉我们仿佛回到了20年前的村里。那时候没有手机，没有网络，有的就是一群将近20个农村土孩子的欢笑声。<br>鹏说自己发福了，我也苦笑着说今年体重都150斤了，发际线也后移了一点，看来我们很快就能进入中年男人的行列了。<br>晚上提议去网吧玩游戏，突然想起来我们都好几年没有一起网吧连坐了，想起来十年前的时候，几个人连坐打CF和逆战，如今大家都各奔东西。村里的网吧味道很大，烟味，臭味，以及阵阵冷风，比起县城里的小网吧，我觉得还是差太远了。玩CF的时候打不过玩家，选了个人机模式，连电脑也打不过，最后只能玩个最简单的人机对战，我跟他说也许我们的水平这辈子都停留在两道杠[ 》》]了。<br>晚上玩到两点才回来，鹏在我的沙发上将就了一晚上，一直到今天中午才走。我听着外面的雨声，翻来覆去睡不着，想着大家以后就要为人父，养家糊口，不由得慌乱起来。</p><hr><p><strong>希望我们现在，未来，都好。</strong></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梦开始的地方</title>
    <link href="/2022/03/14/clpqt1ivz008t4cue49p4fj2j.html"/>
    <url>/2022/03/14/clpqt1ivz008t4cue49p4fj2j.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：不小心翻出来大学的时候写的代码。</p><span id="more"></span><p><strong><em>不小心在码云上翻出来大学的时候写的代码，感慨万千，那时候 2017 年才大二（2017年初）下学期（写文章的时间是2022年3月14日），想搞个物联网平台，所以写了个demo，这个demo可能是国内第一个公开的物联网平台。这些东西奠定了我今天的职业生涯以及研究方向。看着那个时候写的项目简介，和我当年的初衷，满满的回忆</em></strong>：</p><hr><blockquote><p>本人是电子信息工程理工科男一枚，标准技术宅。本应该去研究CPU架构和汇编语言的我，却迷上了WEB互联网开发。加上平时喜欢折腾一些极客玩具，渐渐的对硬件也来了兴趣。平日里酷爱折腾一些极客玩具的我，再加上本人身处硬件相关专业，平时接触到了很多不一样的问题。问题总是围绕在身边。比如，某同学在做STM32单片机的时候抱怨：“我要是把拿到的数据用软件存储起来就好了，到时候直接拿出来观察结果数据。”再者还有：“要是能把单片机的数据传输到网络里面就好了，可以随便查看。”这些都是来自硬件工程师的抱怨和难处：硬件不负责数据的可视化呈现，他们更喜欢用各种仪器去查看。我想：能否解决这个问题？让这些硬件工程师随时可以查看数据，用手机，用浏览器，APP，都可以观测结果，即打造一个“通用的平台，用来让硬件把数据传递到互联网。于是自己着手试了一下，在很长的时间里，尝试了很多方法，也解决了一部分问题，但是总是不完美，期间用了Python在树莓派上实现一个数据呈现平台，但是不理想，折腾许久，最终决定用Java来实现这个平台。这就是这个项目的来源，含义就是：让一切联网变得更加容易！</p></blockquote><hr><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><!-- more --><p><img src="/uploads/dream_start/1.png" alt="=="><br><img src="/uploads/dream_start/2.png" alt="=="><br><img src="/uploads/dream_start/3.png" alt="=="><br><img src="/uploads/dream_start/4.png" alt="=="><br><img src="/uploads/dream_start/5.png" alt="=="></p><p>当年这个项目是用Springboot框架做的，前端貌似是java的模板引擎，甚至为此还学了Activemq二次开发, 下面是那个时候写的个插件：</p><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.wwh.iot.easylinker.activemqplugin;<span class="hljs-keyword">import</span> org.apache.activemq.broker.<span class="hljs-type">Broker</span>;<span class="hljs-keyword">import</span> org.apache.activemq.broker.<span class="hljs-type">BrokerFilter</span>;<span class="hljs-keyword">import</span> org.apache.activemq.broker.<span class="hljs-type">ProducerBrokerExchange</span>;<span class="hljs-keyword">import</span> org.apache.activemq.command.<span class="hljs-type">ActiveMQTextMessage</span>;<span class="hljs-keyword">import</span> org.apache.activemq.command.<span class="hljs-type">Message</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by wwhai on 2017/9/1.</span><span class="hljs-comment"> */</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthBroker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BrokerFilter</span> </span>&#123;    public <span class="hljs-type">AuthBroker</span>(<span class="hljs-type">Broker</span> next) &#123;        <span class="hljs-keyword">super</span>(next);    &#125;    <span class="hljs-meta">@Override</span>    public void send(<span class="hljs-type">ProducerBrokerExchange</span> producerExchange, <span class="hljs-type">Message</span> messageSend) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        <span class="hljs-type">ActiveMQTextMessage</span> receivedMessage = (<span class="hljs-type">ActiveMQTextMessage</span>) messageSend;        <span class="hljs-type">String</span> dest=receivedMessage.getDestination().toString();        <span class="hljs-keyword">if</span> (dest.equals(<span class="hljs-string">&quot;topic://DISCONNECTED&quot;</span>)) &#123;            removeConnection(getAdminConnectionContext(), receivedMessage.getConnection().getConnectionInfo(), <span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">&quot;error&quot;</span>));            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;remove connection :&quot;</span>+receivedMessage.getProducerId());        &#125;    &#125;&#125;</code></pre><blockquote><p>时光过得很快，我直到今天都没有把自己想要的物联网平台做出来，但是那个时候它却是我梦想的起点，支撑我坚持到了今天。</p></blockquote><p><strong>但愿我们不忘初心，还能找回当初写的代码，共同纪念我们这代人那逝去的青春！！！</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gitee.com/wwhai/easylinker">https://gitee.com/wwhai/easylinker</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>口水歌歌词</title>
    <link href="/2022/02/26/clpqt1ivl00744cue32tg70ao.html"/>
    <url>/2022/02/26/clpqt1ivl00744cue32tg70ao.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：口水歌歌词。</p><span id="more"></span><h2 id="我刚到深圳的时候特别无聊。没事没事干，写了个歌词，如果有会作曲的可以试一下。不过前提是你要有对深圳的感触，才能谱出比较不错的曲。"><a href="#我刚到深圳的时候特别无聊。没事没事干，写了个歌词，如果有会作曲的可以试一下。不过前提是你要有对深圳的感触，才能谱出比较不错的曲。" class="headerlink" title="我刚到深圳的时候特别无聊。没事没事干，写了个歌词，如果有会作曲的可以试一下。不过前提是你要有对深圳的感触，才能谱出比较不错的曲。"></a>我刚到深圳的时候特别无聊。没事没事干，写了个歌词，如果有会作曲的可以试一下。不过前提是你要有对深圳的感触，才能谱出比较不错的曲。</h2><div style="text-align:center;"><p><strong>听人说起南方有个城市叫深圳</strong><br><strong>遍地黄金充满机会适合底层人</strong><br><strong>恍恍惚惚我热血沸腾开始心动</strong><br><strong>彻夜未眠兴奋的我预订了航班</strong><br><strong>飞过浙江福建终于落地到宝安</strong><br><strong>眼见这深圳的楼很高人也很多</strong><br><strong>听说大家都没房那他们住在哪</strong><br><strong>深圳的天很热但是也很蓝</strong><br><strong>要是没有空调大家都完蛋</strong><br><strong>深圳这座城很伟大是China No.1</strong><br><strong>华强北的老板抱怨今年没有单</strong><br><strong>踌躇满志我一路来到了深圳湾</strong><br><strong>“来了都是深圳人”对我很灿烂</strong><br><strong>让一部分人富起来可是太羡慕啦</strong><br><strong>原来这些精英都在深圳的地铁站</strong><br><strong>排长队进车站抢座位只为去上班</strong><br><strong>深圳的街道很热闹都是年轻人啊</strong><br><strong>我说我是外地人他说他家在武汉</strong><br><strong>我在这深圳要做啥当然来打工哈</strong><br><strong>他说他的朋友在腾讯年薪上百万啊</strong><br><strong>多少人为了理想来到了深圳</strong><br><strong>多少人输给现实离开了深圳</strong><br><strong>你从什么地方来深圳他又刚离开啊</strong></p></div>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2021年</title>
    <link href="/2022/02/26/clpqt1ivl00734cuedrynajgi.html"/>
    <url>/2022/02/26/clpqt1ivl00734cuedrynajgi.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：在杭州那段时间我老是做一些奇奇怪怪的梦。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>2021年，新型冠状肺炎的第二年，我们已经习惯了戴上口罩，看不到大家的脸。</strong></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我到杭州的第一个冬天和之前在福建的时候有所不同。杭州的冬天比显得比福州的冬天要冷的很多。尤其到了1月愈发的冷。坐在座位上敲键盘的手都感觉伸不直了。但是杭州是一个没有暖气的城市。所以每天到了这个时候，应该是杭州人最难熬的时候吧。虽然说杭州在我的印象中是江南地区，但是杭州的这个冬天打破了我对江南地区的美好幻想。</p><h2 id="迪士尼"><a href="#迪士尼" class="headerlink" title="迪士尼"></a>迪士尼</h2><p>不过也有令人感到开心的时候。公司组织了一个团建活动。带我们去上海迪士尼玩了一天。也是我这辈子第一次去上海的娱乐场所。记得那天天很冷。我和女朋友一起去的。但是那天的人很少。可能是跟天气有关吧。所以平时人满为患的迪士尼乐园那天几乎没有多少人。里面的每一个项目我们都体验了一遍。印象比较深刻的应该是那个过山车，当时第一次坐过山车。即使他他的速度增加到80的时候。整个人都感觉慌了。不过体验也是非常棒的。中途还玩了一些其他的项目。迪士尼里面。还是有很多有意思的东西，对于我这个乡下来的我算是见了世面。</p><h2 id="结婚了"><a href="#结婚了" class="headerlink" title="结婚了"></a>结婚了</h2><p>2021年的春节期间。我见到了好几个多年未见的老友。还见到了我两个高中的同学。他们现在都在新疆。有的当老师，有的当协警。大家的生活仿佛都进入了一个新的阶段。<br>对于我来说，也是一个很值得纪念的月，因为在2021年的情人节。我和她结束了五年的恋爱，步入了婚姻。我们两个的婚礼是在老家的小院子里面举办的，没有跟其他人一样搞得很气派。相反显得非常的简单而又朴素。因为我们两个人心里面都已经达成了共识：低调做事。从这个情人节开始。我也开始了我的新的人生，也有了新的角色：老公。</p><h2 id="东方明珠"><a href="#东方明珠" class="headerlink" title="东方明珠"></a>东方明珠</h2><p>婚礼结束以后，我们又回到了杭州。继续开始工作。期间又去了一趟上海。参加了SAP这个公司举办的活动，这是我人生第一次进了外企，也是第一次见识到了外企里面的样子，总是感觉他们好像过得很轻松，准时准点下班。这一次去上海。我还见到了一个小学同学。我跟他已经多年未见。他好像从五六年前开始就来到上海，在一家软件公司里面做销售。他带我在南京东路走了一圈。当时我看着黄浦江对面的东方明珠。低头看着那些银行的大楼，突然就觉得非常感慨：我来自最穷的地方。脚上穿着最便宜的鞋。站在了中国最富庶的地方。</p><h2 id="疲倦了"><a href="#疲倦了" class="headerlink" title="疲倦了"></a>疲倦了</h2><p>接下来的工作跟生活都是波澜不惊。但是这段时间。公司里面发生了一些莫名其妙的事情。个别同事也跟我的关系突然变得有点微妙。所以从3月份开始，我逐渐的厌倦了工作。当时我想重新换一个环境。直到有一天发生了一件事情。令我非常的难过。于是就下定决心要离职。<br>到了5月底的时候，也就是刚满一年的时候。人力的同事，跟我说起续签合同的事情。我突然想起来，我已经不想在这个公司里面工作了。于是我就提出了离职。辞职后的那段时间，我觉得整个人的心情都变得畅快起来了。突然想起了在这一年到杭州生活，我仿佛一直顶着压力。<br>以后我准备去面试涂鸦这个公司。有意思的是，同样这个公司作为杭州的一个网红互联网公司。他们的人力资源部门，非常的不专业。这也是促使我离开杭州的一个主要原因。</p><h2 id="新体验"><a href="#新体验" class="headerlink" title="新体验"></a>新体验</h2><p>大概两周以后，我离开了A公司。入职了一家新的B公司。B公司是做智慧楼宇的。里面的同事都很不错。虽然我短短的待了两周时间。但是我走的时候还是和大家吃了个饭。虽然有些同事的名字我可能都不记得了。想起来我A公司整整一年了，都没有跟公司里面的几个招式相处的同事吃过一顿饭。不免有一些感慨。</p><h2 id="深圳行"><a href="#深圳行" class="headerlink" title="深圳行"></a>深圳行</h2><p>刚好在这个时候。事情发生了转变。我有一个网上认识的朋友。很多年了，他之前在广州，也是2021年到了深圳。他跟我说他接触到了一个公司，做物联网相关的。但是他自己却不喜欢物联网，所以他就把我推荐到了这个公司里面。他跟我说，反正现在也没有工作，不如来深圳玩一趟吧。于是我想了一下，好像也是，已经一年了，就当是自己旅游。于是没有多思考，就直接坐着飞机过来，他带我去玩了一趟华强北。见识了一下那个深圳湾公园。也就是有“来了都是深圳”人几个字的公园。深圳这个城市，我觉得非常有意思。首先最让我感到惊讶的是，深圳的楼竟然这么密集。楼跟楼之间的间距1~2m之间得人做什么事情都可以看到，一清二楚。后来我才知道深圳作为中国最大的打工城市，这些房子就是专门给这些打工的人准备的。在深圳玩了两天，感觉还是非常喜欢这个城市，确实看起来很年轻。自己体验了一遍深圳后决定离开杭州。<br>回到杭州后我就提了离职。离开了这个我只待了两周的B公司。临走的时候，B公司的Hr姐姐还跟我说：深圳那边的压力很大。要不要考虑继续在杭州发展？但是当时我心意已决。于是果断的收拾行李直接到了深圳。</p><h2 id="在深圳"><a href="#在深圳" class="headerlink" title="在深圳"></a>在深圳</h2><p>事实证明，我到深圳以后的选择是对的。在这边的新公司。刚好做的就是工业物联网刚好就是我擅长的领域。我对工业物联网也有非常大的兴趣。到了新公司以后，全身心的投入到了研发工业物联网相关软件系统的工作中。这半年我学到了很多东西。从零开始开发了一套消息中间件。所以整体上对我的技术提高是非常关键的。现阶段我切换了新的方向，从原来的中间件转向做工业物联网。这个领域做深耕与探索。工业互联网是未来产业改革的关键。所以说这一块可以研究的方向还是挺多的。</p><h2 id="城中村"><a href="#城中村" class="headerlink" title="城中村"></a>城中村</h2><p>来了以后我住在深圳的城中村，这个地方是深圳最大的打工者聚集地，来自全国的打工仔都在这个地方，出去以后外面密密麻麻全部是人。我住的这个村里面，最多的应该就是江西人，然后湖北河南的比较多，绝大多数人都来自于社会底层，或者是像我们一样，读书上大学。然后来到深圳，大家都是为了生活或者是为了理想。也有人问我为什么跑去深圳那么累，家里面随便找个班上不行吗？我也不知道怎么跟人家说。我心里想想到其实他们不懂：他们上的是班，但是我们这些底层人在改变命运。<br>深圳真的是一个特殊的城市，他的特殊点就在于他给了我们这些底层上来的人一个窗户。你在这边可以做很多你想做的事情。而且相对来讲氛围比较自由。或者说你到这边来目标就很明确。就是当一个打工人。所以说到深圳以后，以前的好多比较烦人的问题。突然之间我就感觉有了答案。进行了以前老是跟家里面的人说起来买房这个事情，总是会产生矛盾，但是自从到了深圳以后。彻底断了买房子念头，老老实实的打工挣钱。</p><h2 id="格局"><a href="#格局" class="headerlink" title="格局"></a>格局</h2><p>在这半年我学到了很多，尤其是对于工业的认识。见到了从来没见到的一些工业设备。比如说西门子工控。还有法那克机械臂。这些都是我以前从来没有见过的东西。也是很大程度上扩展了我的视野。<br>同时还有一件特殊的事情。就是我快要当爸爸了。这对于我来说喜忧参半。开心的是我终于又能看到一个跟我小时候一样的小宝宝，担忧的事，我不知道我能不能担任起一个父亲的角色。我想这些事情迟早有一天每个人都会面对，或者说绝大多数人都会面对。现在这个事情终于来了，与其担心，不如坦荡荡的去接受，反而会好一些。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>到这里基本上作文就结束了。我不知道未来的路是怎么样的。但是有一点最起码是非常明确的：那就是写程序。我们每个人都是迷茫的。有时候跟人规划太长太远了不行，反而会增加人的心里负担。让你过得很累。不如长期坚持干好一件简单的事情。别说从去年到深圳以后，就坚持写一个项目写到今天。他让我看到了希望。看到了一个人也可以写出比较牛逼的软件来。尤其是我们这些离家在外的人，时间久了难免会陷入空虚迷茫，找一件事情每天去做一做，转移一下注意力，可能情况会好一点。</p><hr><p><strong>你我都有光明的未来</strong></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LoraWan网关设计思路</title>
    <link href="/2021/12/06/clpqt1itf00014cue7c790yp1.html"/>
    <url>/2021/12/06/clpqt1itf00014cue7c790yp1.html</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="LoraWAN-设计思路"><a href="#LoraWAN-设计思路" class="headerlink" title="LoraWAN 设计思路"></a>LoraWAN 设计思路</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>该功能可以通过EMQX来对Lora无线通信网络进行管理和配置，控制等等，同时可以整合功能到EMQX，从而实现Lora网络透传到多种上层协议。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>该插件本质是一个挂载在EMQX上的串口驱动，EMQX通过和串口通信来驱动外部挂载的设备，因此需要配合Lora相关硬件设备来使用。</p><h2 id="3-设计思路"><a href="#3-设计思路" class="headerlink" title="3.设计思路"></a>3.设计思路</h2><p>在设计之初，参考了有人的Lora模块，同时了解了有人的Lora网关的一些基本操作，受到了启发，我们可以将常见的功能集成到EMQX上来，方便一些做网关的用户使用。</p><p>设计之初主要考虑到了以下几个点：</p><ol><li><p>驱动形式</p><p>鉴于大部分Lora模块都是基于串口驱动的，在对比了好几种硬件之间通信协议以后，发现串口最简单，最经济实用，而且支持的平台众多，很适合做基础驱动，所以选择了串口作为驱动通信协议；</p></li><li><p>管理网络</p><p>Lora网络需要管理，比如网络状态，节点信息查看等等，所以需要设计一个精简的管理系统来集成到EMQX里面；</p></li><li><p>授权鉴权</p><p>节点的入网，发送消息，都需要鉴权，此处可以整合到EMQX的ACL机制里面。</p></li></ol><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ol><li>该功能需要配合相关硬件来使用，目前只支持串口；</li><li>该功能只能在Linux上运行，不支持Windows。</li></ol><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h2><pre><code class="hljs shell">RT028DS_R3000-LG产品规格书_v.1.1.1.pdfLPWAN-review.pdf                             RT028UG_R3000_LG用户手册_v.1.0.7.pdfLow-cost-LoRa-Collar.pdf                     USR-LG210-L_AT_V1.0.0.pdfLow-cost-LoRa-GW-leaflet.pdf                 WAZIUP-Deployment-guidelines.pdfLow-cost-LoRa-GW-outdoor.pdf                 WAZIUP_IoT-dev-guide.pdfLow-cost-LoRa-GW-step-by-step.pdf            WH-L102-L-C_说明书V1.0.0.pdfLow-cost-LoRa-GW-web-admin.pdf               WH-L102-L-P_V0.0.5.hexLow-cost-LoRa-Ghana-iSpace-public-event.pdf  WH-L102-L-P_basic.pdfLow-cost-LoRa-ImageIoT-step-by-step.pdf      demo-slides.pdfLow-cost-LoRa-IoT-antennaCable.pdf           iot4all-intro-lr.pdfLow-cost-LoRa-IoT-outdoor-step-by-step.pdf   lorawan1.0.3.pdfLow-cost-LoRa-IoT-step-by-step.pdf           lora应用论文.pdfLow-cost-LoRa-IoT-supported-sensors.pdf      lora终端固件升级方法.pdfLow-cost-LoRa-IoT-using-demo-kit.pdf         low-cost-iot-hardware-parts.pdfLow-cost-LoRa-device-leaflet.pdf             smyle-deploying-low-cost-iot.pdftutorial-SWHW-LoRa-WAZIUP.pdfRESSACS16-Low-cost-LoRa-IoT-step-by-step.pdf</code></pre><h1 id="规范设计"><a href="#规范设计" class="headerlink" title="规范设计"></a>规范设计</h1><h2 id="1-驱动规范"><a href="#1-驱动规范" class="headerlink" title="1. 驱动规范"></a>1. 驱动规范</h2><p>规定 LoraWan Gateway 对模组的驱动方式为标准串口，其中串口参数可以自己适配，默认值如下：</p><table><thead><tr><th>项目</th><th>默认值</th></tr></thead><tbody><tr><td>波特率</td><td>115200</td></tr><tr><td>数据位</td><td>8</td></tr><tr><td>停止位</td><td>1</td></tr><tr><td>奇偶校验</td><td>None</td></tr></tbody></table><h2 id="2-MAC层规范"><a href="#2-MAC层规范" class="headerlink" title="2. MAC层规范"></a>2. MAC层规范</h2><h3 id="2-1-地址规范"><a href="#2-1-地址规范" class="headerlink" title="2.1 地址规范"></a>2.1 地址规范</h3><p>MAC层规定了能连接到 LoraWan Gateway 的终端一些规范：</p><ul><li><p>信道：标准 Lora 信道，值为1-127之间</p></li><li><p>节点ID：用户自定义节点ID，为16位整数</p></li><li><p>速率：Lora射频发射速率，单位为 dBm，此速率非传输信息大小即 KB/S 的速率</p></li></ul><p>设备唯一识别码 UUID 规范：<br>$$<br>UUID = CHANNEL::CID.1-CID.2-CID.3-CID.4::DR<br>$$</p><p><strong><em>一个案例：</em></strong>100::0001-0001-0001-0001.10</p><p>规定在  LoraWan Gateway 管理的网络中，<em>UUID</em>作为唯一识别码。</p><blockquote><p>UUID 可以看做是互联网中的IP地址，而 UUID 组成中的 CHANNEL 可以看成是网关地址，CID可以看成是子网IP，DR可以看成是子网掩码。</p></blockquote><h2 id="2-2-计算规范"><a href="#2-2-计算规范" class="headerlink" title="2.2 计算规范"></a>2.2 计算规范</h2><p>LoRa符号速率Rs可以通过以下公式计算：<br>$$<br>Rs=BW/(2^SF)<br>$$</p><p>LoRa数据速率DR可以通过以下公式计算：<br>$$<br>DR= SF<em>( BW/2^SF)</em>CR<br>$$<br>单位含义：</p><ul><li><p>BW: 带宽</p></li><li><p>Rs：符号速率</p></li><li><p>CR：编码率</p></li><li><p>SF：扩频因子</p></li></ul><blockquote><p>LoRaWAN 协议定义了一系列的数据传输速率，不同的芯片可供选择的速率范围不同，例如SX1272支持0.3-38.4kbps，SX1276支持0.018-38.4kbps的速率范围。目前能实现0.3-37.5kbps的传输速率。</p><p>使用LoRa设备发送或接收的数据长度有限制，理论来说SX127x系列芯片有256 Bytes的FIFO，发射或接收256Bytes都行。但是，并不是在任何传输速率下LoRa模块的负载长度都能为256 Bytes。在传输速率较低的情况下，一次传输256 Bytes需要花费的时间极长（可能需要花费几秒甚至更长），这不利于抗干扰和交互，因此在技术处理上一般建议用户将一条长数据分割成数条小数据来进行传输</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>物联网终端设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网终端设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网软件和物联网软件系统</title>
    <link href="/2021/10/15/clpqt1iwi00b34cue45ru1m57.html"/>
    <url>/2021/10/15/clpqt1iwi00b34cue45ru1m57.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：互联网软件和物联网软件系统。</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>个人这几年在物联网行业摸爬滚打，做过业务系统，也做过中间件和网关。经过这几年的沉淀，也算是对这个领域内稍微有点皮毛认知。加上陆陆续续经历了几家公司，也见了不少物联网相关的项目，但是发现大部分公司对于物联网认识不深刻，在技术架构方向一直在套用互联网领域的技术和设计，虽然说这样短期能实现功能，达到“能用”的程度，但是对于后期发展和业务扩大埋下了隐患，以至于最后因为技术崩盘而导致业务萎缩失败。因此这些年对于这些项目中出现的问题以及设计方面有些自己的想法和建议，希望能让一些纯粹的做软件级以及架构出身的开发者们对于物联网和互联网有个初步的认识和区分。</p><h2 id="详细文章"><a href="#详细文章" class="headerlink" title="详细文章"></a>详细文章</h2><object data="/pdf/iot-and-ps.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>物联网杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种统一联网架构思路</title>
    <link href="/2021/10/13/clpqt1iwg00as4cuecbeb8dbh.html"/>
    <url>/2021/10/13/clpqt1iwg00as4cuecbeb8dbh.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：一种统一联网架构思路。</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>当前主流物联网领域所用的技术本质上是基于互联网技术拓展而来，例如 MQTT，CoAP 等物联网生态，这些协议本身就是一个基于TCP或者 UDP 的应用层协议，其实现的连接技术本质上是基于英特网（Internet）技术的经典模式：客户端-服务器模型，通过桥接或者代理的形式来实现通信连接，由此看来并没有真正实现“物物直接相连”。所以目前严格来说物联网技术并没有如上个世纪科学家们预测的那样发展-即物联网技术的来源：实现万物互联。<br>本设计没有尝试推翻经典物联网（Internet of Things）模型，而是提出了一种尝试统一物联网技术领域的基础架构理论模型：对象联网通信模型（Network of Object）。</p><h2 id="详细文章"><a href="#详细文章" class="headerlink" title="详细文章"></a>详细文章</h2><object data="/pdf/IOO.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>奇思妙想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>奇思妙想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云边协同统一平台</title>
    <link href="/2021/10/13/clpqt1iwh00ax4cue8frbekgt.html"/>
    <url>/2021/10/13/clpqt1iwh00ax4cue8frbekgt.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：云边协同统一平台</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本问主要设计了一个云边协同平台。</p><h2 id="详细文章"><a href="#详细文章" class="headerlink" title="详细文章"></a>详细文章</h2><object data="/pdf/AtomicCloud.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>物联网系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于树莓派的Lora网关设计</title>
    <link href="/2021/10/13/clpqt1iwj00b44cue3mbqhgj9.html"/>
    <url>/2021/10/13/clpqt1iwj00b44cue3mbqhgj9.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：基于树莓派的Lora网关设计。</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>最近闲来无事想做个玩具，亦或者想试试能不能做套方案出来，配合Rulex实现整套物联网设备接入、控制以及数据采集方案.</p><h2 id="详细文章"><a href="#详细文章" class="headerlink" title="详细文章"></a>详细文章</h2><object data="/pdf/rpi-lora.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>奇思妙想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>奇思妙想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网基础平台设计</title>
    <link href="/2021/10/13/clpqt1iwk00b84cue7xsf54d8.html"/>
    <url>/2021/10/13/clpqt1iwk00b84cue7xsf54d8.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：物联网基础平台设计</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>2017 年在大学的时候设计了 EasyLinker 的第一个版本,当初写那个版本的原因是自己准 备做一个 yealink 替代品.第一个版本是一个非常基础的版本,仅仅包含了 MQTT 消息转发代 理. 后来经历了一系列事情,2018 年我大学毕业进入社会,再也没精力去维护了,勉勉强强做 了 EazyLinker 第二个版本,但是第二个版本太复杂了,于是在 2018 年年底也放弃维护. 2019 年,我找到了问题所在,主要是我们没有系统的设计过功能才导致流产,2019 年我和 其他开发者一起讨论研究了大半年需求,又重新设计了 EasyLinkerV3 版本. 但是问题还是存在的,V3 的设想实在是太大了,不适合个人小团队开发,最终还是流 产.2019 年夏天我和其他开发人员一起讨论了一次:要不就从 V3 设计理念提取出来一个版本, 专门做一个领域的产品?这个提议得到了通过,于是我们设计出来了 EasyLinker 的子版 本:EZlinker(因为 EasyLinker 已经是别人的品牌,我们换了同音字母 EZ). EZlinker 和其他物联网平台的不同之处在于我们关注于厂家批量生产设备的场景,提供 大量便捷的管理功能,还有物联网基础服务功能,方便厂家快速构建自己的流水线和产品.此 处的关注点是批量生产设备情况下带来的集中管理问题. 目前关注本项目的人也比较多,因此我们决定花精力和时间认真做一个版本发布出去.</p><h2 id="详细文章"><a href="#详细文章" class="headerlink" title="详细文章"></a>详细文章</h2><object data="/pdf/ezlinker.pdf" type="application/pdf" width="100%" height="877px">]]></content>
    
    
    <categories>
      
      <category>物联网系统设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网系统设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网领域软件工程师基础技能图谱</title>
    <link href="/2021/10/10/clpqt1iwk00bb4cue7jkefjkq.html"/>
    <url>/2021/10/10/clpqt1iwk00bb4cue7jkefjkq.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：总结了一下物联网领域软件工程师基础技能图谱</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>近期总结了一下物联网领域内需要的技术图谱，希望能对新人起到帮助</p><h2 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h2><p><img src="/uploads/iot/iot-1.png" width="100%"> </img></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大体上需要基础数学，计算机理论，网络，软件工程等这些基础学科，做物联网领域不同于互联网，很多地方要求基础知识比较扎实才行。另外相比架构设计，更多多关注电子以及通信领域的一些最佳实践。比如淘宝，腾讯的架构拿过来能解决互联网特定高级业务环境下的问题，但是处理不了物联网场景下的问题。这点需要很清楚的认识到。</p>]]></content>
    
    
    <categories>
      
      <category>物联网高级开发技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年6月面试记录</title>
    <link href="/2021/10/10/clpqt1ive00694cue3fgu66bl.html"/>
    <url>/2021/10/10/clpqt1ive00694cue3fgu66bl.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2021年6月面试记录</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>2021年从杭州某个网红公司离职后，面试了几个公司，现在把当时的问题整理一下。</p><h2 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h2><ul><li>说说spring, springmvc, springboot的区别</li><li>bean的生命周期</li><li>vm内存模型</li><li>什么时候GC</li><li>你写代码导致  OOM  过吗？</li><li>（并发基础）异步和同步的区别</li><li>简单口述如何打包一个java程序到docker镜像</li><li>谈谈你对 网络系统 的理解</li><li>Redis pipline</li><li>你谈谈物联网产业常见场景</li><li>谈谈对业务系统的认识</li><li>有过 tob（usiness）（税） 端物联网的经验没？</li><li>你们的 CI CD 怎么玩的</li><li>谈谈你的review流程</li><li>谈谈 java 这个语言的特色 </li><li>你的简历有Netty vertx 你讲讲</li><li>你说Netty是异步IO 那你说一下什么是异步</li><li>假设有边缘端设备需求？ 你认为最合适的编程语言和框架是什么，为什么？</li><li>go java有什么区别？</li><li>谈一下什么是操作系统</li><li>谈谈你对物联网领域产业的认识</li><li>物联网行业在中国目前有哪些优势和机遇</li><li>谈谈你对数据库 和缓存的认识</li><li>为什么需要redis</li><li>谈谈你知道的各种数据库之间的区别和关系</li><li>我看你简历上有机器人经历，谈谈机器人的整个业务流程以及技术提现在哪个环节</li></ul><h2 id="HR"><a href="#HR" class="headerlink" title="HR"></a>HR</h2><ul><li>离职原因</li><li>职业规划</li><li>对上个公司评价</li><li>为何不继续续签合同</li><li>薪资要求</li></ul><h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>当时去杭州某个物联网行业比较火的上市公司的时候（也许大家能猜出来），他们的Hr和面试官很不专业，面试的是Erlang岗位，面试官问我Java问题，最后给的回答是：不符合Erlang岗。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>当时拿到了3个Offer，一个27最高，一个25，一个23.5(五险一金加起来25)。其中23.5那个做的东西比较感兴趣，于是去了那家。不过后来又发生了别的事，最后跑到深圳去了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大家还是要加强基础知识学习，以及对自己要有信心。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐个树莓派机箱</title>
    <link href="/2021/10/09/clpqt1ivc00644cuecdh5g1qf.html"/>
    <url>/2021/10/09/clpqt1ivc00644cuecdh5g1qf.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：推荐个比较好玩的玩具</p><span id="more"></span><p>最近在油管上看到老外做的一个树莓派机箱，看起来挺漂亮的，直接把资源文件拿过来了，可以自助 3D 打印出来DIY。</p><h1 id="推荐个树莓派机箱"><a href="#推荐个树莓派机箱" class="headerlink" title="推荐个树莓派机箱"></a>推荐个树莓派机箱</h1><p>最近在油管上看到老外做的一个树莓派机箱，看起来挺漂亮的，直接把资源文件拿过来了，可以自助 3D 打印出来DIY：</p><p><img src="/uploads/rpi4-box/static/1.png" width="100%"></img></p><h2 id="文件下载地址"><a href="#文件下载地址" class="headerlink" title="文件下载地址"></a>文件下载地址</h2><p><a href = "https://pan.baidu.com/s/129Z1fvIt8k6V42EifQxwuw"> 【点击下载,提取码: v4d6 】 </a></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>极客玩具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lora 网关设计思路</title>
    <link href="/2021/10/06/clpqt1iti00034cue9ln19tvw.html"/>
    <url>/2021/10/06/clpqt1iti00034cue9ln19tvw.html</url>
    
    <content type="html"><![CDATA[<h1 id="EMQX-LoraWAN-设计思路"><a href="#EMQX-LoraWAN-设计思路" class="headerlink" title="EMQX LoraWAN 设计思路"></a>EMQX LoraWAN 设计思路</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>该功能可以通过EMQX来对Lora无线通信网络进行管理和配置，控制等等，同时可以整合功能到EMQX，从而实现Lora网络透传到多种上层协议。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>该插件本质是一个挂载在EMQX上的串口驱动，EMQX通过和串口通信来驱动外部挂载的设备，因此需要配合Lora相关硬件设备来使用。</p><h2 id="3-设计思路"><a href="#3-设计思路" class="headerlink" title="3.设计思路"></a>3.设计思路</h2><p>在设计之初，参考了有人的Lora模块，同时了解了有人的Lora网关的一些基本操作，受到了启发，我们可以将常见的功能集成到EMQX上来，方便一些做网关的用户使用。</p><p>设计之初主要考虑到了以下几个点：</p><ol><li><p>驱动形式</p><p>鉴于大部分Lora模块都是基于串口驱动的，在对比了好几种硬件之间通信协议以后，发现串口最简单，最经济实用，而且支持的平台众多，很适合做基础驱动，所以选择了串口作为驱动通信协议；</p></li><li><p>管理网络</p><p>Lora网络需要管理，比如网络状态，节点信息查看等等，所以需要设计一个精简的管理系统来集成到EMQX里面；</p></li><li><p>授权鉴权</p><p>节点的入网，发送消息，都需要鉴权，此处可以整合到EMQX的ACL机制里面。</p></li></ol><h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><ol><li>该功能需要配合相关硬件来使用，目前只支持串口；</li><li>该功能只能在Linux上运行，不支持Windows。</li></ol><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h2><pre><code class="hljs shell">RT028DS_R3000-LG产品规格书_v.1.1.1.pdfLPWAN-review.pdf                             RT028UG_R3000_LG用户手册_v.1.0.7.pdfLow-cost-LoRa-Collar.pdf                     USR-LG210-L_AT_V1.0.0.pdfLow-cost-LoRa-GW-leaflet.pdf                 WAZIUP-Deployment-guidelines.pdfLow-cost-LoRa-GW-outdoor.pdf                 WAZIUP_IoT-dev-guide.pdfLow-cost-LoRa-GW-step-by-step.pdf            WH-L102-L-C_说明书V1.0.0.pdfLow-cost-LoRa-GW-web-admin.pdf               WH-L102-L-P_V0.0.5.hexLow-cost-LoRa-Ghana-iSpace-public-event.pdf  WH-L102-L-P_basic.pdfLow-cost-LoRa-ImageIoT-step-by-step.pdf      demo-slides.pdfLow-cost-LoRa-IoT-antennaCable.pdf           iot4all-intro-lr.pdfLow-cost-LoRa-IoT-outdoor-step-by-step.pdf   lorawan1.0.3.pdfLow-cost-LoRa-IoT-step-by-step.pdf           lora应用论文.pdfLow-cost-LoRa-IoT-supported-sensors.pdf      lora终端固件升级方法.pdfLow-cost-LoRa-IoT-using-demo-kit.pdf         low-cost-iot-hardware-parts.pdfLow-cost-LoRa-device-leaflet.pdf             smyle-deploying-low-cost-iot.pdftutorial-SWHW-LoRa-WAZIUP.pdfRESSACS16-Low-cost-LoRa-IoT-step-by-step.pdf</code></pre><h1 id="规范设计"><a href="#规范设计" class="headerlink" title="规范设计"></a>规范设计</h1><h2 id="1-驱动规范"><a href="#1-驱动规范" class="headerlink" title="1. 驱动规范"></a>1. 驱动规范</h2><p>规定 LoraWan Gateway 对模组的驱动方式为标准串口，其中串口参数可以自己适配，默认值如下：</p><table><thead><tr><th>项目</th><th>默认值</th></tr></thead><tbody><tr><td>波特率</td><td>115200</td></tr><tr><td>数据位</td><td>8</td></tr><tr><td>停止位</td><td>1</td></tr><tr><td>奇偶校验</td><td>None</td></tr></tbody></table><h2 id="2-MAC层规范"><a href="#2-MAC层规范" class="headerlink" title="2. MAC层规范"></a>2. MAC层规范</h2><h3 id="2-1-地址规范"><a href="#2-1-地址规范" class="headerlink" title="2.1 地址规范"></a>2.1 地址规范</h3><p>MAC层规定了能连接到 LoraWan Gateway 的终端一些规范：</p><ul><li><p>信道：标准 Lora 信道，值为1-127之间</p></li><li><p>节点ID：用户自定义节点ID，为16位整数</p></li><li><p>速率：Lora射频发射速率，单位为 dBm，此速率非传输信息大小即 KB/S 的速率</p></li></ul><p>设备唯一识别码 UUID 规范：<br>$$<br>UUID = CHANNEL::CID.1-CID.2-CID.3-CID.4::DR<br>$$</p><p><strong><em>一个案例：</em></strong>100::0001-0001-0001-0001.10</p><p>规定在  LoraWan Gateway 管理的网络中，<em>UUID</em>作为唯一识别码。</p><blockquote><p>UUID 可以看做是互联网中的IP地址，而 UUID 组成中的 CHANNEL 可以看成是网关地址，CID可以看成是子网IP，DR可以看成是子网掩码。</p></blockquote><h2 id="2-2-计算规范"><a href="#2-2-计算规范" class="headerlink" title="2.2 计算规范"></a>2.2 计算规范</h2><p>LoRa符号速率Rs可以通过以下公式计算：<br>$$<br>Rs=BW/(2^SF)<br>$$</p><p>LoRa数据速率DR可以通过以下公式计算：<br>$$<br>DR= SF<em>( BW/2^SF)</em>CR<br>$$<br>单位含义：</p><ul><li><p>BW: 带宽</p></li><li><p>Rs：符号速率</p></li><li><p>CR：编码率</p></li><li><p>SF：扩频因子</p></li></ul><blockquote><p>LoRaWAN 协议定义了一系列的数据传输速率，不同的芯片可供选择的速率范围不同，例如SX1272支持0.3-38.4kbps，SX1276支持0.018-38.4kbps的速率范围。目前能实现0.3-37.5kbps的传输速率。</p><p>使用LoRa设备发送或接收的数据长度有限制，理论来说SX127x系列芯片有256 Bytes的FIFO，发射或接收256Bytes都行。但是，并不是在任何传输速率下LoRa模块的负载长度都能为256 Bytes。在传输速率较低的情况下，一次传输256 Bytes需要花费的时间极长（可能需要花费几秒甚至更长），这不利于抗干扰和交互，因此在技术处理上一般建议用户将一条长数据分割成数条小数据来进行传输</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OHVM 编程语言设计思路</title>
    <link href="/2021/10/06/clpqt1itl00074cue24dm6pqk.html"/>
    <url>/2021/10/06/clpqt1itl00074cue24dm6pqk.html</url>
    
    <content type="html"><![CDATA[<h2 id="关于-OHVM-Lang"><a href="#关于-OHVM-Lang" class="headerlink" title="关于 OHVM-Lang"></a>关于 OHVM-Lang</h2><p>这是我自己的另一个想法，前段时间写了个很简单的虚拟机（其实就是OHVM），但是没有一个高级语言作为APP开发工具，于是我绞尽脑汁在找一些脚本语言。其他的比如Lua，JS等都是成熟的语言，语法规则实在是太庞大了，我看到那些规范几乎亮眼黑，一点不利于新手学习。于是我找到了一个大佬写的博客，他这个是自己设计一个很简单的编程语言，很适合作为新手学习，于是我就给抄过来了。本项目主要目的是把高级程序 OHVM-Lang 编译成 OHVM 的字节码。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本人不懂编译技术，全靠谷歌，写出来的东西估计很垃圾，但是学习价值还是有。</p><h2 id="OHVM-Lang-设计规范"><a href="#OHVM-Lang-设计规范" class="headerlink" title="OHVM-Lang 设计规范"></a>OHVM-Lang 设计规范</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量赋值使用符号 <code>:=</code> , 例如我要定义一个变量存储一个数，程序应该如下写：</p><pre><code class="hljs BASIC">var0 := <span class="hljs-number">1</span>var1 := <span class="hljs-number">2</span>....</code></pre><ul><li>变量赋值不支持多行，一行一个，和 C 有区别！</li></ul><blockquote><p>也许你会好奇为何变量预定义？其实这是上古时代的编程语言通用的做法，因为本设计参考了 BASIC，所以也继承了这种非常简单的变量形式,这个变量的具体实现形式是个数组:</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>OHVM-Lang 使用 <code>##</code>注释，和 python，shell 不太一样，注意是两个<code>#</code>。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li><p>数学运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>+</td><td>数学加法</td><td>var0 := 1 + 1</td></tr><tr><td>-</td><td>数学减法</td><td>var0 := 1 - 1</td></tr><tr><td>*</td><td>数学乘法</td><td>var0 := 1 * 1</td></tr><tr><td>^</td><td>数学幂运算</td><td>var0 := 1 ^ 1</td></tr><tr><td>/</td><td>数学整除法</td><td>var0 := 1 / 1</td></tr><tr><td>%</td><td>数学模运算</td><td>var0 := 1 % 1</td></tr><tr><td>&lt;</td><td>数学大于</td><td>var0 := 1 &gt; 1 ,## 逻辑运算返回 0，表示false</td></tr><tr><td>&gt;</td><td>数学小于</td><td>var0 := 1 &lt; 1 ,## 逻辑运算返回 0，表示false</td></tr><tr><td>=</td><td>数学等于</td><td>var0 := 1 = 1 ,## 逻辑运算返回 1，表示true</td></tr><tr><td>&gt;:</td><td>IO输出</td><td>&gt;: 1 + 1</td></tr><tr><td>&lt;&lt;</td><td>IO输入</td><td>:&gt; var0</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>&amp;</td><td>AND</td><td>var0 := 1 &amp; 1</td></tr><tr><td>|</td><td>OR</td><td>var0 := 1 | 1</td></tr><tr><td>!</td><td>NOT</td><td>var0 := 1 ! 1</td></tr><tr><td>^</td><td>XOR</td><td>var0 := 1 ^ 1</td></tr></tbody></table></li><li><p>字符</p><p>字符用<code>&quot;</code>起来的串表示，如下示例:</p><pre><code class="hljs basic">var0 := <span class="hljs-string">&quot;hello world&quot;</span>&gt;: var0</code></pre><p>其中 <code>$</code>前置的单个字符值会被直接转成 ASCII 码:</p><pre><code class="hljs basic">var0 := $Avar1 := $<span class="hljs-number">1</span></code></pre><p>其中 var0 的值为 A 的 ASCII 码为 65；var1 的值为 49。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3></li></ul><p>条件语句的格式如下:</p><pre><code class="hljs c"><span class="hljs-keyword">if</span>(boolean)&#123;  ##&#125;<span class="hljs-keyword">else</span>&#123;  ##&#125;</code></pre><p>看起来是不是很简单，所以为了省事，目前只有这一种条件语句，来个 demo：</p><pre><code class="hljs c">var0 := <span class="hljs-number">1</span>var1 := <span class="hljs-number">2</span><span class="hljs-keyword">if</span>(var0 &gt; var1)&#123;    &gt;: var0&#125;<span class="hljs-keyword">else</span>&#123;    &gt;: var1&#125;</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环语句的格式如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">loop</span>(<span class="hljs-params">boolean</span>)</span>&#123;    ##    goout&#125;</code></pre><ul><li>跳出循环使用 <code>goout</code> , 这其实是汇编的 <code>POP</code> 命令。当到这里的时候，发生了退栈的行为。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数概念和任意一个其他编程语言的相同，其定义如下：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> [名称]<span class="hljs-params">(参数表)</span></span> -&gt;   函数体end</code></pre><p>例如定义一个计算两数之和的demo：</p><ul><li>有返回值<pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span></span> -&gt;    <span class="hljs-keyword">return</span> a + bend</code></pre></li><li>无返回值：<pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">echo</span><span class="hljs-params">(a)</span></span> -&gt;    &gt;: aend</code></pre></li></ul><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><ol><li><p>hello world</p><pre><code class="hljs makefile">var0 := <span class="hljs-string">&quot;hello ohvm&quot;</span><span class="hljs-section">&gt;: var0</span></code></pre></li><li><p>计算两个数之和</p><pre><code class="hljs makefile">var0 := 1var1 := 2<span class="hljs-section">&gt;: var0 + var1</span></code></pre></li><li><p>比较两个数大小</p><pre><code class="hljs stylus">var0 := <span class="hljs-number">1</span>var1 := <span class="hljs-number">2</span><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(var0 &gt; var1)</span></span>&#123;    &gt;: <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">else</span>&#123;    &gt;: <span class="hljs-number">0</span>&#125;</code></pre></li></ol><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>desining</p><h4 id="绘图函数"><a href="#绘图函数" class="headerlink" title="绘图函数"></a>绘图函数</h4><p>desining</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[Turing Complete Languages] [<a href="https://www.cs.drexel.edu/~kschmidt/CS360/Lectures/1.html]">https://www.cs.drexel.edu/~kschmidt/CS360/Lectures/1.html]</a></li><li>[ Writing an Interpreter ] [<a href="http://memphis.compilertools.net/interpreter.html]">http://memphis.compilertools.net/interpreter.html]</a></li><li>[ BASIC Interpreter ] [<a href="http://zzp.me/archive/basic%E8%A7%A3%E9%87%8A%E5%99%A8.html]">http://zzp.me/archive/basic%E8%A7%A3%E9%87%8A%E5%99%A8.html]</a></li><li>[ C8C ] [<a href="https://github.com/glouw/c8c.git]">https://github.com/glouw/c8c.git]</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种假设的基于万有引力的通信模型</title>
    <link href="/2021/10/06/clpqt1itn000b4cue8mhsbga8.html"/>
    <url>/2021/10/06/clpqt1itn000b4cue8mhsbga8.html</url>
    
    <content type="html"><![CDATA[<p>本文主要讲了一种假设的基于万有引力的通信模型</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之前突发奇想，想到了万有引力是否可以假设成一种通信模型？于是有了这个想法，该博客仅仅作为新奇娱乐，不喜勿喷。</p><h2 id="理论模型"><a href="#理论模型" class="headerlink" title="理论模型"></a>理论模型</h2><p>牛顿提出的万有引力计算公式为:<br>$$<br>F = G\frac{Mm}{r^2}<br>$$<br>其中F是引力（重力），G是引力常数，M和m分别是这个引力关系中两个物体的质量，r是这两个物体质心之间的距离。</p><p>通过以上理论我们可知万有引力和两个物体之间的质量和距离有关系，那么是否意味着，假设我们能精确控制物体的质量大小，就可以通过万有引力大小来传输信息？</p><h3 id="距离固定"><a href="#距离固定" class="headerlink" title="距离固定"></a>距离固定</h3><p>当距离固定的时候，分母为常量，即万有引力公式可以简化成：<br>$$<br>F = G\frac{Mm}{k}      ——–                       ①<br>$$</p><p>假设 k 的值是一个单位量，则公式再次被简化：<br>$$<br>F = G·M·m              ——–②<br>$$<br>我们知道 G 本身自己就是个常量，也可以将该公式再次精简到：<br>$$<br>F = M·m            ——–③<br>$$<br>此时万用引力在距离固定的情况下，他的值可以认为是两个物体之间质量的乘积。在这里提出我们的假设：</p><ul><li>我们如果能精确控制任何一个物体的质量，就可以控制通过物体的质量来传输编码信息实现通信。</li></ul><h3 id="距离不固定，物体质量固定"><a href="#距离不固定，物体质量固定" class="headerlink" title="距离不固定，物体质量固定"></a>距离不固定，物体质量固定</h3><p>由公式①②③的推导过程可知，按照同样的道理，我们可以推出当距离不固定，但是物体质量固定的情况下，万有引力的最终变形：<br>$$<br>F = \frac{k}{r^2} ——-④<br>$$<br>当 k 为一个单位量的时候，我们可以得到最精简形式：<br>$$<br>F = \frac{1}{r^2}   ——–  ⑤<br>$$<br>从改公式看出此时万有引力和距离成反比，我们同样可以通过控制距离来控制 F，到这里我们再次提出假设：</p><ul><li>当两个物体质量确定，但是距离不确定的时候，假设我们能精确控制距离，就可以产生万有引力变化，从而可以实现传输信号。</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本假设仅仅处于脑洞大开的一种猜测，不足以作为任何学术和理论依据，请当猎奇看待。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sina.com.cn/s/blog_63a266370100x65p.html">解开牛顿万有引力计算公式中隐藏的谜</a></p>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻量级规则引擎设计</title>
    <link href="/2021/10/06/clpqt1itq000i4cue42dm4q84.html"/>
    <url>/2021/10/06/clpqt1itq000i4cue42dm4q84.html</url>
    
    <content type="html"><![CDATA[<p>本文主要讲了轻量级规则引擎设计过程</p><span id="more"></span><h2 id="通用轻量级规则引擎：RulEngine"><a href="#通用轻量级规则引擎：RulEngine" class="headerlink" title="通用轻量级规则引擎：RulEngine"></a>通用轻量级规则引擎：RulEngine</h2><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>什么是规则引擎？本质上就是个数据选择器，每个规则只关心自己匹配到部分，来进行进一步的操作和处理，更像是一个管道操作，本质是上一次操作的输出作为下一次的输入，整个流程如图所示。</p><pre><code class="hljs sequence">Input -&gt; Rule1: Input dataNote over Rule1: RulEngine.Run(Rule1)Rule1 -&gt; Rule2 : next, NewInputNote over Rule2: RulEngine.Run(Rule2)Rule2 --&gt; Rule1 : stopRule2 -&gt; Rule3 : next, NewInputNote over Rule3: RulEngine.Run(Rule3)Rule3 -&gt; Rule2 : stopRule3 -&gt; RuleN : next, NewInputNote over RuleN: RulEngine.Run(RuleN)RuleN -&gt; Rule3 : stopRuleN -&gt; Output : Output</code></pre><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>规则引擎核心部件采用 golang 作为主要开发语言来实现，规则用 JavaScript 脚本来动态实现，本质上是 golang 启动一个 JavaScript解释器，然后执行规则定义代码。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>规则引擎生命周期如下所示：</p><pre><code class="hljs sequence">Start-&gt; InitInEnds: Initial Input ResourcesInitInEnds-&gt; InitOutEnds: Initial Output ResourcesInitOutEnds-&gt; LoadRules: Load RulesLoadRules -&gt; Working : WorkWorking -&gt; Working : Working StateWorking-&gt; Destory: Free ResourcesDestory-&gt; Stop: Stop Rule Engine</code></pre><h3 id="外部接口"><a href="#外部接口" class="headerlink" title="外部接口"></a>外部接口</h3><ul><li>Start() :  启动规则引擎，返回值是个 MAP，里面包含了一些配置信息或者环境变量；</li><li>InitInEnd() list.List: 初始化输入端的资源，通常指规则引擎需要监听的端；</li><li>InitOutEnd() list.List: 初始化数据流出的目的地，比如数据库或者是转发；</li><li>LoadRule() list.List: 加载规则，在这里指的是 JavaScript 脚本；</li><li>Work(): 准备就绪开始工作；</li><li>Destory(): 规则引擎停止之前的释放资源操作；</li><li>Stop(): 停止规则引擎。</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>RuleEngine 执行脚本过程：</p><pre><code class="hljs sas"><span class="hljs-keyword">data </span>= InEnd.<span class="hljs-meta">input</span>RuleEngine.work(inendId, data)    -&gt; RuleEngine.<span class="hljs-meta">call</span>(Js1, <span class="hljs-meta">Input</span>): next, NewInput | <span class="hljs-meta">stop</span>    -&gt; RuleEngine.<span class="hljs-meta">call</span>(Js2, <span class="hljs-meta">Input</span>): next, NewInput | <span class="hljs-meta">stop</span>    -&gt; .......    -&gt; RuleEngine.<span class="hljs-meta">call</span>(Jsn, <span class="hljs-meta">Input</span>): next, NewInput | <span class="hljs-meta">stop</span></code></pre><p>规则使用JavaScript来描述:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;demo rule1&quot;</span>;<span class="hljs-keyword">let</span> description = <span class="hljs-string">&quot;ok, let&#x27;s go&quot;</span>;<span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = [<span class="hljs-string">&quot;in_id1&quot;</span>, <span class="hljs-string">&quot;in_id2&quot;</span>];<span class="hljs-keyword">let</span> actions = [    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">params</span>) </span>&#123;        print(<span class="hljs-string">&quot;params1&quot;</span>, params)    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params">params</span>) </span>&#123;        print(<span class="hljs-string">&quot;params2&quot;</span>, params);    &#125;    <span class="hljs-comment">// …………</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">success</span>(<span class="hljs-params"></span>) </span>&#123;    print(<span class="hljs-string">&quot;success callback rule call success&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">failed</span>(<span class="hljs-params">error</span>) </span>&#123;    print(<span class="hljs-string">&quot;failed callback ,rule call error:&quot;</span>, error);&#125;</code></pre><p>字段解释：</p><ul><li>name: 规则的名字</li><li>description：描述信息</li><li>from：来自哪个输入端，这是个数组，值是输入端的ID</li><li>actions：规则过滤函数</li><li>success：规则执行成功后回调</li><li>failed：规则执行失败后回调</li></ul><p>JavaScript 规则脚本回调函数：</p><pre><code class="hljs js"><span class="hljs-comment">// 其中params表示输入的数据</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$</span></span>&#123;name)(params) &#123;   <span class="hljs-comment">// todo</span>    <span class="hljs-keyword">return</span> $&#123;RETURN&#125;;&#125;</code></pre><ul><li>回调函数不可以是匿名函数</li><li>回调函数必须是 1个参数</li><li>回调函数返回值必须是<code>&quot;stop&quot;</code> 或者 <code>[&quot;next&quot;, params]</code></li></ul><blockquote><p>注意：规则描述里面所有字段必须是必填的，缺一不可。</p></blockquote><h2 id="重要表结构"><a href="#重要表结构" class="headerlink" title="重要表结构"></a>重要表结构</h2><p>规则引擎为了加速和利用硬件性能，所有运行时数据全部存在某个内存表里面，因此需要合理设计几张内存表。</p><h3 id="输入端"><a href="#输入端" class="headerlink" title="输入端"></a>输入端</h3><table><thead><tr><th>字段名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>string</td><td>唯一ID，系统分配</td></tr><tr><td>type</td><td>string</td><td>类型</td></tr><tr><td>name</td><td>string</td><td>名称</td></tr><tr><td>description</td><td>string</td><td>描述文本</td></tr><tr><td>config</td><td>Map string</td><td>配置信息,包含了输入端的有些配置，比如可能是MQTT的鉴权，Topic等</td></tr><tr><td>cts</td><td>timestamp</td><td>创建时间</td></tr></tbody></table><p>输入端一般指的是外部数据产生方，比如来自HTTP的请求，或者MQTT消息等。当创建一个输入端以后，系统会启动一个进程来维护这个输入端。</p><blockquote><p>其中输入端业务必须实现接口：void RunEngine(data)，最后数据流转的时候，回调这个接口：</p><p>inend.RunEngine(data){</p><p>​    id : = 自己的唯一ID</p><p>   rulEngine.work(id, data)</p><p>}</p></blockquote><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><table><thead><tr><th>字段名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>string</td><td>唯一ID，系统分配</td></tr><tr><td>in_end</td><td>string</td><td>输入端的ID</td></tr><tr><td>type</td><td>string</td><td>类型</td></tr><tr><td>name</td><td>string</td><td>名称</td></tr><tr><td>script</td><td>string</td><td>规则脚本</td></tr><tr><td>description</td><td>string</td><td>描述文本</td></tr><tr><td>config</td><td>Map string</td><td>配置信息</td></tr><tr><td>cts</td><td>timestamp</td><td>创建时间</td></tr></tbody></table><p>规则表相对来说比较负责，除了基础字段，还包含了一个输入端ID。输入端ID主要用来标记该规则作用点，假设我们需要一个MQTT消息处理规则，则首先我们需要创建一个InEnd，然后创建一个规则，规则作用点为之前创建的InEnd。</p><h3 id="输出端"><a href="#输出端" class="headerlink" title="输出端"></a>输出端</h3><table><thead><tr><th>字段名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>string</td><td>唯一ID，系统分配</td></tr><tr><td>type</td><td>string</td><td>类型</td></tr><tr><td>name</td><td>string</td><td>名称</td></tr><tr><td>description</td><td>string</td><td>描述文本</td></tr><tr><td>config</td><td>Map string</td><td>配置信息</td></tr><tr><td>cts</td><td>timestamp</td><td>创建时间</td></tr></tbody></table><p>输出端和输入端结构保持一致，原理就是把数据最终吐出到某个地方。</p><h3 id="系统用户表"><a href="#系统用户表" class="headerlink" title="系统用户表"></a>系统用户表</h3><table><thead><tr><th>字段名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>username</td><td>string</td><td>用户名</td></tr><tr><td>password</td><td>string</td><td>密码</td></tr><tr><td>email</td><td>string</td><td>Email</td></tr><tr><td>phone</td><td>string</td><td>手机号码</td></tr><tr><td>extra_info</td><td>string</td><td>扩展信息</td></tr></tbody></table><p>因为用户管理不是本系统的主要功能，所以尽量做得简单，只做了个基础鉴权功能。如果觉得用户信息还需要扩展，那就在 extra 字段里面保存一些额外信息。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[otto ] (<a href="https://github.com/robertkrimen/otto"> A JavaScript interpreter in Go</a>)</p><p>[Rule engine] (<a href="https://openrules.com/ruleengine.htm">OpenRules Rule Engine</a>)</p>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计一个简单的虚拟机</title>
    <link href="/2021/10/06/clpqt1itt000q4cue3sr37htp.html"/>
    <url>/2021/10/06/clpqt1itt000q4cue3sr37htp.html</url>
    
    <content type="html"><![CDATA[<p>本文主要讲了如何设计一个简单的虚拟机</p><span id="more"></span><h1 id="OHVM-虚拟机设计规范"><a href="#OHVM-虚拟机设计规范" class="headerlink" title="OHVM 虚拟机设计规范"></a>OHVM 虚拟机设计规范</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是我为了学习虚拟机原理和计算机程序运行原理，写的一个很简单的虚拟机demo，可以运行简单的字节码，当然如果我有时间和精力写出来相对完整点的版本，说不定还能搞个小玩具。</p><blockquote><p>OHVM 的含义是 “Only for Happy VM”，就是作者纯粹没有任何其他目的为了开心的产物。该设计本质是为了学习计算机技术，其没有任何生产和使用价值。</p></blockquote><h2 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h2><h3 id="内存范围"><a href="#内存范围" class="headerlink" title="内存范围"></a>内存范围</h3><p>默认内存设定大小为 0-4KB，可以调整参数来扩大。</p><h3 id="寄存器分布"><a href="#寄存器分布" class="headerlink" title="寄存器分布"></a>寄存器分布</h3><p>一共有 293 个个寄存器.</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>一共有8层栈空间，每一层有32个寄存器。</p><h2 id="虚拟机模型"><a href="#虚拟机模型" class="headerlink" title="虚拟机模型"></a>虚拟机模型</h2><p><img src="res/model.png" alt=""></p><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><ol><li>程序地址：<br>程序从 0x0000H 开始。</li><li>入口地址：<br>程序入口地址默认是 0x0000H。</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><blockquote><p><strong><em>0x0H</em></strong> 是一个绝对地址, 真实地址是：<strong><em>1025</em></strong>.</p></blockquote><h3 id="寄存器分布-1"><a href="#寄存器分布-1" class="headerlink" title="寄存器分布"></a>寄存器分布</h3><p>Those address can’t be accessed by user program.</p><table><thead><tr><th>Name</th><th>Symbol</th><th>Size</th><th>Address(Decimal)</th></tr></thead><tbody><tr><td>NullPtr Register</td><td>NULL</td><td>1byte</td><td>ROM: 0 - 1</td></tr><tr><td>VM Flag Register</td><td>FLAG</td><td>1byte</td><td>ROM: 1 - 2</td></tr><tr><td>Addressing Register</td><td>A</td><td>4byte</td><td>ROM: 3 - 5</td></tr><tr><td>ACCumulator</td><td>ACC</td><td>4byte</td><td>ROM: 6 - 9</td></tr><tr><td>Program counter</td><td>PC</td><td>4byte</td><td>ROM: 10 - 13</td></tr><tr><td>Stack index pointer</td><td>SP</td><td>4byte</td><td>ROM: 14 - 17</td></tr><tr><td>Stack deepth pointer</td><td>SD</td><td>4byte</td><td>ROM: 18 - 21</td></tr><tr><td>Exception Register</td><td>EXCPT</td><td>4byte</td><td>ROM: 22 - 25</td></tr><tr><td>General Register</td><td>R{0…31}</td><td>4byte(per)</td><td>ROM: 25 - 152</td></tr><tr><td>Stack Register</td><td>S{0…7}</td><td>4byte(per)</td><td>ROM: 153 - 378</td></tr></tbody></table><h3 id="标志位寄存器"><a href="#标志位寄存器" class="headerlink" title="标志位寄存器"></a>标志位寄存器</h3><table><thead><tr><th>Name</th><th>Symbol</th><th>Size</th></tr></thead><tbody><tr><td>Zero</td><td>ZE</td><td>1bit</td></tr><tr><td>Equal</td><td>EQ</td><td>1bit</td></tr><tr><td>Execption</td><td>EX</td><td>1bit</td></tr><tr><td>Reserved</td><td>–</td><td>1bit</td></tr><tr><td>Reserved</td><td>–</td><td>1bit</td></tr><tr><td>Reserved</td><td>–</td><td>1bit</td></tr><tr><td>Reserved</td><td>–</td><td>1bit</td></tr><tr><td>Reserved</td><td>–</td><td>1bit</td></tr></tbody></table><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><table><thead><tr><th>Instruction Code</th><th>Symbol</th><th>Example</th><th>Function</th></tr></thead><tbody><tr><td>0X0000</td><td>NOP</td><td>NOP</td><td>No operation, used for delay</td></tr><tr><td>0X0001</td><td>START</td><td>START</td><td>Start ohvm</td></tr><tr><td>0X0002</td><td>STOP</td><td>STOP</td><td>Stop ohvm</td></tr><tr><td>0X0003</td><td>RSTR</td><td>RSTR</td><td>Reset all Register</td></tr><tr><td>0X0004</td><td>TIMER [Rn]</td><td>MOVR R0 #5<br>TIMER R0</td><td>Start Timer</td></tr><tr><td>0X0005</td><td>GOTO [Rn]/[Label]</td><td>GOTO LOOP<br>GOTO R0</td><td>GOTO ADDress</td></tr><tr><td>0X0006</td><td>CALL [Rn]/[Label]</td><td>CALL LOOP<br>CALL R0</td><td>CALL SUB process</td></tr><tr><td>0X0007</td><td>BACK</td><td>BACK</td><td>RETURN from SUB process</td></tr><tr><td>0X0008</td><td>JMP [Rn]/[Label]</td><td>JMP LOOP</td><td>JUMP Address With No Condition</td></tr><tr><td>0X0009</td><td>JZ [ACC] [Rn]/[Label]</td><td>JZ LOOP</td><td>Compare with ACC, Jump Address if Zero Flag == 1</td></tr><tr><td>0X000A</td><td>JE [ACC] [Rn]/[Label]</td><td>JE LOOP</td><td>Compare with ACC, Jump Address if Equal Flag == 1</td></tr><tr><td>0X000B</td><td>JX [ACC] [Rn]/[Label]</td><td>JX LOOP</td><td>Compare with ACC, Jump Address if Excepion Flag == 1</td></tr><tr><td>0X000C</td><td>CMRAE [Rn]</td><td>MOV R0 #1<br>CMRAE</td><td>COMPARE R{x} if equal ACC</td></tr><tr><td>0X000D</td><td>CMRAG [Rn]</td><td>MOV R0 #1<br>CMRAG</td><td>COMPARE R{x} if greater than ACC</td></tr><tr><td>0X000E</td><td>CMRAL [Rn]</td><td>MOV R0 #1<br>CMRAL</td><td>COMPARE R{x} if little than ACC</td></tr><tr><td>0X000F</td><td>CMRRE [Rn] [Rn]</td><td>MOV R0 #1<br>MOV R1 #1<br>CMRRE R0 R1</td><td>COMPARE R{x} if equal R{x}</td></tr><tr><td>0X0010</td><td>CMRRG [Rn] [Rn]</td><td>MOV R0 #1<br>MOV R1 #1<br>CMRRG R0 R1</td><td>COMPARE R{x} if greater than R{x}</td></tr><tr><td>0X0011</td><td>CMRRL [Rn] [Rn]</td><td>MOV R0 #1<br>MOV R1 #1<br>CMRRL R0 R1</td><td>COMPARE R{x} if little than R{x}</td></tr><tr><td>0X0012</td><td>CMASE [Rn] [Sn]</td><td>CMASE R0 S0</td><td>COMPARE ACC if equal than Stack</td></tr><tr><td>0X0013</td><td>CMASG [Rn] [Sn]</td><td>CMASG R0 S0</td><td>COMPARE ACC if greater than Stack</td></tr><tr><td>0X0014</td><td>CMASL [Rn] [Sn]</td><td>CMASL R0 S0</td><td>COMPARE ACC if little than Stack</td></tr><tr><td>0X0015</td><td>CMRSE [Rn] [Sn]</td><td>CMRSE R0 S0</td><td>COMPARE R{x} if little than Stack</td></tr><tr><td>0X0016</td><td>CMRSG [Rn] [Sn]</td><td>CMRSG R0 S0</td><td>COMPARE R{x} if greater than Stack</td></tr><tr><td>0X0017</td><td>CMRSL [Rn] [Sn]</td><td>CMRSL R0 S0</td><td>COMPARE R{x} if little than Stack</td></tr><tr><td>0X0018</td><td>INCA</td><td>INCA</td><td>INCREASE ACC</td></tr><tr><td>0X0019</td><td>DECA</td><td>DECA</td><td>DECREASE ACC</td></tr><tr><td>0X001A</td><td>INCR [Rn]</td><td>INCR R0</td><td>INCREASE Register{x}</td></tr><tr><td>0X001B</td><td>DECR [Rn]</td><td>DECR R0</td><td>DECREASE Register{x}</td></tr><tr><td>0X001C</td><td>ADDAR [Rn]</td><td>MOV R0 #1<br>ADDAR R0</td><td>ADD ACC and Register{x}</td></tr><tr><td>0X001D</td><td>SUBAR [Rn]</td><td>MOV R0 #1<br>SUBAR R0</td><td>SUB ACC and Register{x}</td></tr><tr><td>0X001E</td><td>INCS</td><td>INCS</td><td>INCREASE Stack</td></tr><tr><td>0X001F</td><td>DECS</td><td>DECS</td><td>DECREASE Stack</td></tr><tr><td>0X0020</td><td>ADDAS [Sn]</td><td>ADDAS S0</td><td>ADD ACC and Stack</td></tr><tr><td>0X0021</td><td>SUBAS [Sn]</td><td>SUBAS S0</td><td>SUB ACC and Stack</td></tr><tr><td>0X0022</td><td>ANDR [Rn]</td><td>MOV R0 #1<br>ANDR R0</td><td>ACC AND Register{x}</td></tr><tr><td>0X0023</td><td>AOR [Rn]</td><td>MOV R0 #1<br>AOR R0</td><td>ACC OR Register{x}</td></tr><tr><td>0X0024</td><td>AXR [Rn]</td><td>MOV R0 #1<br>AXR R0</td><td>ACC XOR Register{x}</td></tr><tr><td>0X0025</td><td>BSLR [Rn]</td><td>MOV R0 #1<br>BSLR R0</td><td>BIT Shift left in Register{x}</td></tr><tr><td>0X0026</td><td>BSRR [Rn]</td><td>MOV R0 #1<br>BSRR R0</td><td>BIT Shift right in Register{x}</td></tr><tr><td>0X0027</td><td>BSLLR [Rn]</td><td>MOV R0 #1<br>BSLLR R0</td><td>BIT Shift left loop in Register{x}</td></tr><tr><td>0X0028</td><td>BSRLR [Rn]</td><td>MOV R0 #1<br>BSRLR R0</td><td>BIT Shift right loop in Register{x}</td></tr><tr><td>0X0029</td><td>ANDS [Sn]</td><td>ANDS S0</td><td>ACC AND Stack</td></tr><tr><td>0X002A</td><td>AOS [Sn]</td><td>AOS S0</td><td>ACC OR Stack</td></tr><tr><td>0X002B</td><td>AXS [Sn]</td><td>AXS S0</td><td>ACC XOR Stack</td></tr><tr><td>0X002C</td><td>BSLS [Sn]</td><td>BSLS S0</td><td>BIT Shift left in Stack</td></tr><tr><td>0X002D</td><td>BSRS [Sn]</td><td>BSRS S0</td><td>BIT Shift right in Stack</td></tr><tr><td>0X002E</td><td>BSLLS [Sn]</td><td>BSLLS S0</td><td>BIT Shift left loop in Stack</td></tr><tr><td>0X002F</td><td>BSRLS [Sn]</td><td>BSRLS S0</td><td>BIT Shift right loop in Stack</td></tr><tr><td>0X0030</td><td>IMA #[Hex]</td><td>IMA #1</td><td>Immediately value to ACC</td></tr><tr><td>0X0031</td><td>IMR [Rn] #[Hex]</td><td>IMR R0 #1</td><td>Immediately value to Register</td></tr><tr><td>0X0032</td><td>IMS [Sn] #[Hex]</td><td>IMS S1 #1</td><td>Immediately value to Stack</td></tr><tr><td>0X0033</td><td>GET [Rn]</td><td>GET R1</td><td>Get value from address</td></tr><tr><td>0X0034</td><td>MVRR [Rn] [Rn]</td><td>MVRR R0 R0</td><td>MOVE Register value to another Register{x}</td></tr><tr><td>0X0035</td><td>MVRS [Rn] [Sn]</td><td>MVRS R0 S0</td><td>MOVE Register value to Stack</td></tr><tr><td>0X0036</td><td>MVSR [Rn] [Rn]</td><td>MVRS S0 R0</td><td>MOVE Stack value to Register</td></tr><tr><td>0X0037</td><td>MVAR [Rn]</td><td>MVAR R0</td><td>MOVE ACC value to Register</td></tr><tr><td>0X0038</td><td>INTK</td><td>INTK</td><td>Wait key interupt</td></tr><tr><td>0X0039</td><td>KEY</td><td>KEY</td><td>Get key</td></tr><tr><td>0X003A</td><td>PLY [Rn]</td><td>MOV R0 #1<br>PLY R0</td><td>Play dididi sound</td></tr><tr><td>0X003B</td><td>PLYS [Rn]</td><td>MOV R0 #1<br>PLYS R0</td><td>Play a series of sound.Usually have a frequence</td></tr><tr><td>0X003C</td><td>GSET [Rn]</td><td>MOV R0 #1<br>GSET R0</td><td>Graphics resolution setting, [64X32 - 640X320]</td></tr><tr><td>0X003D</td><td>CLS</td><td>CLS</td><td>Clear screen</td></tr><tr><td>0X003E</td><td>DPXY [Rn]</td><td>MOV R0 #1<br>DPXY R0</td><td>Draw 8 * x pixels at (x, y)</td></tr><tr><td>0X003F</td><td>DXY [Rn]</td><td>MOV R0 #1<br>DXY R0</td><td>Draw point at (x, y)</td></tr><tr><td>0X0040</td><td>DCXY [Rn]</td><td>MOV R0 #1<br>DCXY R0</td><td>Draw char at (x, y)</td></tr><tr><td>0X0041</td><td>DLINE [Rn]</td><td>MOV R0 #1<br>DCXY R0</td><td>Draw line</td></tr><tr><td>0X0042</td><td>DRECT [Rn]</td><td>MOV R0 #1<br>DCXY R0</td><td>Draw rectangle</td></tr><tr><td>0X0043</td><td>SCRU</td><td>SCRU</td><td>Screen scrool up x pixel</td></tr><tr><td>0X0044</td><td>SCRD</td><td>SCRD</td><td>Screen scrool down x pixel</td></tr><tr><td>0X0045</td><td>SCRL</td><td>SCRL</td><td>Screen scrool left x pixel</td></tr><tr><td>0X0046</td><td>SCRR</td><td>SCRR</td><td>Screen scrool right x pixel</td></tr><tr><td>0X0047</td><td>SET [Rn]</td><td>SET R0</td><td>Set value to ram</td></tr></tbody></table><h2 id="汇编规范"><a href="#汇编规范" class="headerlink" title="汇编规范"></a>汇编规范</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li><strong><em>MAIN</em></strong>: 入口标识符</li><li><strong><em>STOP</em></strong>: 直接退出虚拟机</li><li><strong><em>BEGIN</em></strong>: 子程序声明标识符</li><li><strong><em>END</em></strong>: 子程序标签</li></ul><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a><em>注意:</em></h5><blockquote><div style="color:red">关键字不可用于其他地方!</div></blockquote><h3 id="汇编格式"><a href="#汇编格式" class="headerlink" title="汇编格式"></a>汇编格式</h3><ol><li>入口<br>用 <code>MAIN</code> 标记入口，一个程序必须有一个 <code>MAIN</code>。</li><li>子程序<br>用 <code>BEGIN &#123;子程序名&#125;: [statement] END</code> 来声明一个子程序，例如声明一个输出字符的子程序：<pre><code class="hljs assembly">BEGIN OUTPUT_CHAR:   ;;END</code></pre></li><li>退出<br>退出用 <code>STOP</code> 标签标记，程序只要到 <code>STOP</code>，立即结束所有运行。<pre><code class="hljs assembly">STOP</code></pre></li><li>注释<br>使用双分号注释: <code>;;</code><pre><code class="hljs abnf"><span class="hljs-comment">;;这是一行注释</span></code></pre></li></ol><h2 id="汇编案例"><a href="#汇编案例" class="headerlink" title="汇编案例"></a>汇编案例</h2><pre><code class="hljs assembly">;; Example program;; mainMAIN:    IA 0              ;; ACC = 0    IR R0 #1          ;; R0 = 1    ADDAR R0          ;; ACC = ACC + R0    CALL DISPLAY      ;; Call display    STOP              ;;END;; display sub processBEGIN DISPLAY:    DCXY 40, 50, ACC ;; Display value in ACCEND</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>按理来说汇编不应该有异常处理这种设计的，但是我想了下异常处理的本质也是一个 <code>JMP</code>,于是我自作聪明的设计了这个语法：<code>TRY ... CATCH</code>.</p><pre><code class="hljs erlang">TRY    ;; ....    ;; ....    ;; ....CATCH $&#123;Address&#125;</code></pre><p>捕获异常时，将设置 <code>EX</code> 寄存器设置为1，并且跳转到 <code>CATCH</code> 指定的代码位置处。</p><h2 id="字节码规范"><a href="#字节码规范" class="headerlink" title="字节码规范"></a>字节码规范</h2><p>如图：</p><p><img src="res/bc-format.png" alt=""></p><h2 id="OHVM-Lang"><a href="#OHVM-Lang" class="headerlink" title="OHVM Lang"></a>OHVM Lang</h2><p>假设已经设计好了一个高级语言叫:OHVM Lang: <a href="./ohvmlang/readme.md">OHVM Lang</a>。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>我现在技术不到家，写不出来高级语言编译器，本来打算设计一个简单的编译器，把 C 或者是 BASIC 这种基础语法编译成字节码，但是我水平太菜了，搞不定，于是这里只能手动来写字节码了。</p><h3 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h3><p>编译流程：</p><pre><code class="hljs armasm">┌───────────────────────┐│    BASIC Source <span class="hljs-meta">code</span>  ││                       │└──────────┬────────────┘           │           ▼┌───────────────────────┐│   OHVM ASM <span class="hljs-meta">code</span>       ││                       │└──────────┬────────────┘           │┌──────────▼────────────┐│                       ││   OHVM Byte <span class="hljs-meta">code</span>      │└───────────────────────┘</code></pre><p>假设编译器已经实现好了，应该按照下面的方式来使用：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 要编译这个文件：hello_world.oohvms</span>oohvmcc hello_world.oohvms<span class="hljs-meta">#</span><span class="bash"> 编译完成后，应该有下面这几个文件：</span><span class="hljs-meta">#</span><span class="bash"> hello_world.oohvmasm hello_world.oohvmbc</span></code></pre><blockquote><p>oohvms 为源代码文件；oohvmasm 为汇编代码；oohvmbc 为字节码文件</p></blockquote><h2 id="任务规划"><a href="#任务规划" class="headerlink" title="任务规划"></a>任务规划</h2><ul><li><input checked="" disabled="" type="checkbox"> 基础指令集设计</li><li><input disabled="" type="checkbox"> 项目结构设计</li><li><input disabled="" type="checkbox"> 虚拟机内核设计</li><li><input disabled="" type="checkbox"> 汇编器设计</li><li><input disabled="" type="checkbox"> 高级程序语言设计</li><li><input disabled="" type="checkbox"> 程序编译器设计</li></ul><h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><ul><li>Blog: <a href="https://openlab.ezlinker.cn">https://openlab.ezlinker.cn</a></li><li>Mail: <a href="mailto:cnwwhai@gmail.com">cnwwhai@gmail.com</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>《计算机程序运行原理》</p></li><li><p>《C语言核心技术》</p></li><li><p>《Linux内核开发》</p></li><li><p>YACC，LEX 等基础官方文档（实现编译器相关）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟串口基本使用</title>
    <link href="/2021/03/21/clpqt1ivd00664cue1fjza6ml.html"/>
    <url>/2021/03/21/clpqt1ivd00664cue1fjza6ml.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：虚拟串口基本使用。</p><span id="more"></span><h1 id="虚拟串口使用"><a href="#虚拟串口使用" class="headerlink" title="虚拟串口使用"></a>虚拟串口使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>调试串口的时候一般用真实设备模拟，但是没有真实设备的时候也可以用模拟器来实现串口调试。本次使用 SOCAT来实现效果。UNIX自带了一个工具，可以直接使用，文档在这里：<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a> 。</p><h2 id="模拟串口"><a href="#模拟串口" class="headerlink" title="模拟串口"></a>模拟串口</h2><p>直接在shell中输入如下命令，表示启动两个虚拟串口，为什么是一对？可能大家有疑惑，想一下两个设备通过串口连起来，是不是要求两边都支持串口？</p><pre><code class="hljs shell">socat -ddd -v -v -v  pty,raw,echo=1  pty,raw,echo=0</code></pre><p>上述命令生成两个串口，你可以实现一个模拟两台串口设备收发数据。</p><p>输出类似下面的日志代表启动成功：</p><pre><code class="hljs shell">2021/03/08 18:44:56 socat[39731] I socat by Gerhard Rieger and contributors - see www.dest-unreach.org2021/03/08 18:44:56 socat[39731] I This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/)2021/03/08 18:44:56 socat[39731] I This product includes software written by Tim Hudson (tjh@cryptsoft.com)2021/03/08 18:44:56 socat[39731] I setting option &quot;raw&quot;2021/03/08 18:44:56 socat[39731] I setting option &quot;echo&quot; to 12021/03/08 18:44:56 socat[39731] I openpty(&#123;5&#125;, &#123;6&#125;, &#123;&quot;/dev/ttys010&quot;&#125;,,) -&gt; 02021/03/08 18:44:56 socat[39731] N PTY is /dev/ttys0102021/03/08 18:44:56 socat[39731] I setting option &quot;raw&quot;2021/03/08 18:44:56 socat[39731] I setting option &quot;echo&quot; to 02021/03/08 18:44:56 socat[39731] I openpty(&#123;7&#125;, &#123;8&#125;, &#123;&quot;/dev/ttys013&quot;&#125;,,) -&gt; 02021/03/08 18:44:56 socat[39731] N PTY is /dev/ttys0132021/03/08 18:44:56 socat[39731] I resolved and opened all sock addresses2021/03/08 18:44:56 socat[39731] N starting data transfer loop with FDs [5,5] and [7,7]</code></pre><p>然后使用cat命令，监控你要接收的那个虚拟串口，上述案例我选择:<code>&quot;/dev/ttys013&quot;</code>作为监控端，</p><pre><code class="hljs shell">cat /dev/ttys013</code></pre><p>然后使用串口工具可连接你准备发送的一端,上面使用    <code>cat /dev/ttys010</code>，本案例使用Erlang来模拟串口发送端：</p><pre><code class="hljs erlang"><span class="hljs-comment">%% 连接</span>&#123;ok, FD&#125; = serctl:open(<span class="hljs-string">&quot;/dev/ttys010&quot;</span>).<span class="hljs-comment">%% 发送</span>serctl:write(FD, &lt;&lt;<span class="hljs-string">&quot;ok&quot;</span>&gt;&gt;).</code></pre><p>观察cat挂起的终端：</p><pre><code class="hljs shell"><span class="hljs-meta">-&gt;</span><span class="bash"> % cat /dev/ttys013</span>ok</code></pre><p>同时 socat 也会有日志：</p><pre><code class="hljs sh">&gt; 2021/03/08 18:46:49.213306  length=2 from=2 to=3ok2021/03/08 18:46:49 socat[39731] I transferred 2 bytes from 5 to 7</code></pre><p>最前面的 <code>ok</code>就是发送端发送的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>socat 工具是一款很强大的工具，我们可以很容易实现数据转发功能，而串口模拟仅仅是其中一个功能，更多功能需要深入挖掘。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Erlang纯手工实现一个WEB框架</title>
    <link href="/2021/03/21/clpqt1iui00364cue1lne17pf.html"/>
    <url>/2021/03/21/clpqt1iui00364cue1lne17pf.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：基于Erlang纯手工实现一个WEB框架</p><span id="more"></span><h1 id="基于Erlang纯手工实现一个WEB框架"><a href="#基于Erlang纯手工实现一个WEB框架" class="headerlink" title="基于Erlang纯手工实现一个WEB框架"></a>基于Erlang纯手工实现一个WEB框架</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>记得很久以前，我还是个java程序员的时候，使用过很多Java世界的WEB框架，例如国产的JFinal，还有风靡全球的SpringMVC系列，甚至我开始入门的时候还学过上古时代（我是2015年正式自学Java WEB，Struts是2008年左右的框架）的Struts框架（这个框架后来被爆出各种漏洞，逐步被人淡忘），当时觉得很神奇，框架这个东西为何能被这么多人认可和使用？设计框架的人是怎么想的？一连串的问题在我脑海里环绕了好几年，直到我大学毕业后工作，逐步明白了SpringMVC的工作原理以后才逐步知道了框架是怎么回事，用一句话来说，框架就是把很多人做的公共重复工作给抽象出来，公开给其他人用，减少一些机械劳动的一套软件。当时还尝试写出来个简单的框，得益于Java的动态特性，基于Java的反射来实现一个简单的WEB框架很简单，于是在2019年我才真正自己实现了个简单的JavaWEB框架。</p><p>后来这几年，因为工作逐步磨灭了我的一些想法和精力，再没有精力去尝试实现一些有趣的东西，“写个框架”这个想法就被搁置了很久。尽管后来的工作逐渐接触了很多其他编程领域的WEB框架，比如Python的Flask，Django等等，但是始终没有自己去研究过一些细节。</p><p>契机在2020年，我到了杭州现在公司以后。2020年我转行做了Erlang（此处有记录《我为何转向Erlang》），从此告别了我熟悉很多年的Java世界。</p><p>做了Erlang以后发现很多问题，Erlang是小众领域的编程语言，很多库，依赖都不完善，就连个好点的WEB开发框架都没有，像SpringMVC这种重量级生产框架，Erlang世界是空白。当时我就在想，为何目前没有人愿意给Erlang造轮子呢？但是随着Erlang的深入学习和工作中的积累我发现，Erlang并不适合做SpringMVC那种级别的WEB项目，它的精髓在并发和容错。</p><p>直到有一天我看到了我们公司的大牛同事写的一个很有趣的框架：minirest，我突然觉得Erlang来实现一些WEB框架其实还是比较简单的，受了minirest的启发以后，我突然想起多年前那个想法：自己写个WEB框架试试。</p><p>于是2020年下半年那段时间，晚上下班以后回到家里就研究Erlang的一些深度技术，还有参考minirest的设计和实现原理，重新打造设计了一套WEB框架：FWEB。FWEB的含义是：Functional WEB或者是 Funny WEB，有两层含义，一是“函数式”，另一是“有点意思”。</p><p>后来因为各种原因，FWEB还是没有实现完全，但是其设计思路和架构设计极具学习价值，于是经过长时间的整理和总结，我把当时的一些想法整理出来，以供后人学习。</p><h2 id="2-基础架构"><a href="#2-基础架构" class="headerlink" title="2.基础架构"></a>2.基础架构</h2><p>说起WEB框架的架构，我们首先来看下Java的SpringMVC的基础架构：</p><p><img src="/uploads/Implement-Web-framework-with-erlang/static/image-20210321154811292.png" alt="image-20210321154811292"></p><p>基本原理就是用户请求发送到前端控制器，然后前端控制器解析参数，分别来调度到不同的Mapping路由映射中去，调用对应的方法，最后把结果反馈给用户，如果我们觉得这个图很复杂，其实SpringMVC可以简化一下，简化成一个<strong><em>WEB框架的基本架构</em></strong>。</p><p><img src="/uploads/Implement-Web-framework-with-erlang/static/image-20210321155754294.png" alt="image-20210321155754294"></p><p>其实我们简化到这里就很明显了，一个基础位WEB框架需要的东西，其实就这3部分：</p><ol><li>前端调度器</li><li>动作执行器</li><li>数据加工器</li></ol><p>前端调度器处理路由，然后处理好的参数交给动作执行器去执行某个函数，然后把执行的返回值，加工成数据返回给前端。</p><h3 id="2-1架构设计"><a href="#2-1架构设计" class="headerlink" title="2.1架构设计"></a>2.1架构设计</h3><p>现在我们来设计我们的FWEB的基础架构：</p><p><img src="/uploads/Implement-Web-framework-with-erlang/static/image-20210321161052440.png" alt="image-20210321161052440"></p><p>从上图可知，FWEB包含了这几个关键组件：</p><ol><li>Dispatcher</li><li>Interceptor chain</li><li>Actions function</li></ol><p>接下来我们一一解释这些组件的功能。</p><h3 id="2-3基础组件"><a href="#2-3基础组件" class="headerlink" title="2.3基础组件"></a>2.3基础组件</h3><ul><li><p>Dispatcher</p><p>这是核心前端调度器，主要用来解析URL参数，例如我们访问如下URL：</p><pre><code class="hljs sh">http://host:port/users?name=fweb</code></pre><p>此时这个请求到FWEB的前端调度器以后，会做以下几件事：</p><ol><li>提取请求参数：users?name=fweb;</li><li>查找路由Action Module;</li><li>查找Module是否包含Action：users</li><li>如果有<code>users</code>则把 name=fweb 参数传递给function。</li></ol><p>整个过程其实很容易理解，就是一个解析<strong><em>URL参数</em></strong>的过程。路由的格式为：</p><pre><code class="hljs sh">http://host:port/mapping@action?k=v&amp;m=n………</code></pre></li><li><p>Interceptor chain</p><p>如果你熟悉Java WEB 就会很熟悉一个组件叫：拦截器。我们这里的拦截器也是同样的功能。只要有一个拦截器不通过，则整个拦截链被中断。</p></li><li><p>Actions function</p><p>Actions指的就是最终的动作，映射到Erlang里面就是函数，例如下面这个Actions的功能就是返回一个字符串“hello”：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">index</span><span class="hljs-params">()</span> -&gt;</span>    <span class="hljs-string">&quot;hello&quot;</span>.</code></pre></li></ul><p>接下来我们看一下应用。</p><h2 id="3-基本应用"><a href="#3-基本应用" class="headerlink" title="3.基本应用"></a>3.基本应用</h2><p>假设我们现在需要实现一个简单的功能：返回一个页面：</p><ul><li><p>先增加处理器</p><pre><code class="hljs erlang">Handlers = [#&#123;name =&gt; article_handler, mapping =&gt; <span class="hljs-string">&quot;/index&quot;</span>&#125;],fweb:add_mapping(Handlers).</code></pre></li><li><p>开始写Actions</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(index)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([index/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">index</span><span class="hljs-params">(_, _)</span> -&gt;</span>  &#123;html, fweb:render(<span class="hljs-string">&quot;/index.html&quot;</span>)&#125;.</code></pre></li><li><p>页面内容</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Welcome Fweb World<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello(&#x27;_&#x27;)World,This is fweb<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>访问URL</p><pre><code class="hljs perl">http:<span class="hljs-regexp">//l</span>ocalhost:<span class="hljs-number">9990</span>/<span class="hljs-keyword">index</span>@index</code></pre><p><img src="/uploads/Implement-Web-framework-with-erlang/static/image-20210321164820592.png" alt="image-20210321164820592"></p></li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>我们简要讲了一个简单的WEB框架的设计过程，通过这个框架，让我们更能认识到Erlang的一些开发技巧和特性。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h2><ul><li>FWEB：<a href="https://github.com/wwhai/fweb">wwhai/fweb: A lightweight web framework Implement by Erlang/OTP (github.com)</a></li><li>MINIREST：<a href="https://github.com/emqx/minirest">emqx/minirest: A Mini RESTful API Framework (github.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期计划</title>
    <link href="/2021/03/13/clpqt1ivz008q4cue9xb5cuah.html"/>
    <url>/2021/03/13/clpqt1ivz008q4cue9xb5cuah.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：近期计划。</p><span id="more"></span><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>白天主要是工作为主，提高Erlang水平，晚上回家拓展知识，以物联网的核心理论为主。</p><ul><li>Erlang：以大蝴蝶鱼那本书为主，反复翻阅；</li><li>通信基础：以无线通讯为主，Lora，蓝牙，WIFI等等</li></ul><h2 id="锻炼"><a href="#锻炼" class="headerlink" title="锻炼"></a>锻炼</h2><h3 id="周一"><a href="#周一" class="headerlink" title="周一"></a>周一</h3><ul><li>俯卧撑三组，每组20个</li><li>跑步机20分钟</li><li>杠铃3组，每组10个</li><li>三头肌拉练3组，每组10个</li><li>拉伸10分钟<br>总共时间差不多控制在2.5小时。</li></ul><h3 id="周三"><a href="#周三" class="headerlink" title="周三"></a>周三</h3><ul><li>俯卧撑三组，每组20个</li><li>跑步机20分钟</li><li>杠铃3组，每组10个</li><li>三头肌拉练3组，每组10个</li><li>拉伸10分钟<br>总共时间差不多控制在2.5小时。</li></ul><h3 id="周五"><a href="#周五" class="headerlink" title="周五"></a>周五</h3><ul><li>俯卧撑三组，每组20个</li><li>跑步机20分钟</li><li>杠铃3组，每组10个</li><li>三头肌拉练3组，每组10个</li><li>拉伸10分钟<br>总共时间差不多控制在2.5小时。</li></ul><h3 id="周六"><a href="#周六" class="headerlink" title="周六"></a>周六</h3><ul><li>俯卧撑三组，每组20个</li><li>腹肌拉练3组，每组10次</li><li>杠铃3组，每组10个</li><li>三头肌拉练3组，每组10个</li><li>拉伸10分钟<br>总共时间差不多控制在2.5小时。</li></ul><p>基本是除了周六，其他时间全部是一样的项目。</p><h1 style="color:red;"> 对了，最后说一句，健身房套路很多，我已经完美避雷，看到的人可以找我探讨。</h1>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年计划和以前的一些反思</title>
    <link href="/2021/01/23/clpqt1ivn007f4cueehxw4696.html"/>
    <url>/2021/01/23/clpqt1ivn007f4cueehxw4696.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2021年计划和以前的一些反思</p><span id="more"></span><blockquote><p>2020年下半年，我再三决定后转行做了Erlang，对于跳出业务为主的Java技术体系，我其实是慎重考虑了很久。</p></blockquote><hr><h1 id="2021年的一些计划"><a href="#2021年的一些计划" class="headerlink" title="2021年的一些计划"></a>2021年的一些计划</h1><p>2020年下半年，我再三决定后转行做了Erlang，对于跳出业务为主的Java技术体系，我其实是慎重考虑了很久。2020年夏天辞职那段时间，其实也有收到很多Java的Offer，但是对比了一下国内Java圈子的现状以后，我决定还是投身于Erlang圈。Erlang对于绝大部分，估计有98%的人来说没听过的冷门编程语言，所以就有人问我：Erlang不好找工作怎么办？Java工资高之类的。其实在我眼里，编程语言就是个工具而已，重要的是思想和方法。关于这段心理历程，会单独出个博文，名字暂定《我为什么转行》，目前的博文仅仅对2021年做个规划。</p><h2 id="1-Erlang"><a href="#1-Erlang" class="headerlink" title="1.Erlang"></a>1.Erlang</h2><p>多的不说，至少能把Erlang写的很熟练，现阶段在开发过程中，我的Erlang能力还是很欠缺，尽管看了不少博客，书也看了，但是始终没有做过完整的中型以上的项目，所以只能做些模块之类的，没达到全局把控的能力。然后就是练习Erlang的热部署，热升级系统的开发和部署能力。说实话Erlang的热升级系统是我最惊讶的特性，完全不停机的情况下下一秒就完成升级。换做Java或者PHP，要搞一套什么灰度发布之类的麻烦框架。想象一下王者荣耀在你移动英雄的下一秒就完成了更新是一件多么令人惊讶的事情。关于Erlang，2020年我也写了点博客，可以看看入门基础，同时后期还会写几篇博文帮助各位能更好”转行“的博文，比如《如何从java转行到Erlang》之类的博文。</p><h2 id="2-C"><a href="#2-C" class="headerlink" title="2.C"></a>2.C</h2><p>2020年我到杭州以后重新学习了一遍C，算是直接抹去了我之前所有关于C的知识，从HelloWorld开始写到了能独立写出个CPU模拟器的程度，如今再次回头学的时候，很多问题都豁然开朗。</p><p>回想起来我的大学学习的计算机科学知识几乎为0，大学的工科教育者能力不足和实践性不强，还有教学不认真，导致我们那一批理工科学生，学会C语言的没几个人，这也是国内普通二流本科大学的通病。大部分的精力是集中在过二级，就在刚才我还翻出来我的计算机二级证书，心想这有什么用呢？</p><p>我至今耿耿于怀我的大学，我的青春竟然在获取知识上如此的贫瘠，除了我们自己不努力之外，我还是希望当年那些高校老师能给我们这些渴望获取知识的人公开道歉，学生本来就是迷茫的，获取知识的过程中需要指路的教师却是目光短浅和无可奈何。但凡是稍微学过点东西的教育从业者，也不至于耽误数不清学子那美好的四年。</p><p>未来对于C的期望，首先希望能把Erlang给移植到嵌入式单片机上，可以在单片机上用Erlang开发，这样就能实现和EMQ无缝衔接，同时也是扩展EMQ的一个好方法。当然这是个很长的路程，接下来一年会持续研究这块技术，目前看有个老外写的AtomVM挺好，但是我不懂编译原理，龙书啃不动，但是接下来可能会尝试看看基础。</p><p>其二则是希望能用C构建一些精简的分布式物联网消息服务器，EMQ是个很优秀的软件，我从中学到了很多分布式系统的精髓，尝试看看能不能吸取一部分出来，做到低级芯片上去。</p><h2 id="3-Java"><a href="#3-Java" class="headerlink" title="3.Java"></a>3.Java</h2><p>Java保持手不生，以后能捞起来做项目即可，我想能达到这种能力的，在某些圈子都能当“架构师”了吧（嘲讽脸）。</p><h2 id="4-算法"><a href="#4-算法" class="headerlink" title="4.算法"></a>4.算法</h2><p>我的算法基础停留在冒牌排序，因为我大学的老师都没听过算法是什么，所以那时候直接就弃了，后来做了2年java的CURD业务仔，也是永远没机会学算法，当然如今的工作确实不需要算法。</p><p>算法欠缺导致我没法写出质量很高的程序出来，很典型的前段时间，写的CPU模拟器，有些位运算涉及到了很简单的算法，但是我还是不能第一时间写出来，从中看出基础能力还是很薄弱。不由得想起来那些做了几年CURD的”架构师“们号称技术很好，如今我猜认识到这个好叫”熟练“。还是老老实实学习基础知识，少浮躁，动不动就架构师，其实目前的那些”架构师“什么水平，大部分人心里其实自己也很清楚，《卖油翁》这篇古文就是很好的答案。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>前几年的年度计划都很空，受了之前福州圈子内的影响，身边的同事对计算机认知都不是很深刻，99%的人认为CS行业就是业务CURD，终点就是”架构师“，当项目经理，手下带人做项目，仿佛也是大部分同事和朋友的职业规划。也没有人真的想过在CS方面能做出来成就出来。我前几年每年的目标都是很肤浅，什么架构师，什么转行项目经理，现在看来真的是挺low的。</p><p>今年2021年，我想还是务实点好，老老实实写代码，如今内涵不够，经不起推敲，唯有多读书多练习才能弥补。其他的目标就不定了，架构师啥的，留给其他大佬们去当好了。</p><h1 id="愿代码没BUG，愿编译器能理解我。"><a href="#愿代码没BUG，愿编译器能理解我。" class="headerlink" title="愿代码没BUG，愿编译器能理解我。"></a><center>愿代码没BUG，愿编译器能理解我。</center></h1>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟学Erlang (三)</title>
    <link href="/2021/01/16/clpqt1iub002e4cuecn2yhzoy.html"/>
    <url>/2021/01/16/clpqt1iub002e4cuecn2yhzoy.html</url>
    
    <content type="html"><![CDATA[<p>作者：Shawn # 概要：Erlang 自带分布式功能，并且 Erlang 语言的消息发送也完全适应分布式环境。</p><span id="more"></span><blockquote><p>本文来自我的同事Shawn大佬的总结，Shawn大佬是目前国内Erlang领域内的权威开发架构师，30分钟学erlang系列文章是Shawn的一线经验，对于新入门的朋友很有帮助。再次感谢Shawn花时间整理博客，和贡献文档供社区学习。</p></blockquote><h1 id="30分钟学Erlang-三"><a href="#30分钟学Erlang-三" class="headerlink" title="30分钟学Erlang (三)"></a>30分钟学Erlang (三)</h1><h2 id="分布式-Erlang"><a href="#分布式-Erlang" class="headerlink" title="分布式 Erlang"></a>分布式 Erlang</h2><p>Erlang 自带分布式功能，并且 Erlang 语言的消息发送也完全适应分布式环境。<br>我们称一个 Erlang VM 是一个 <code>Erlang Node</code>。所以每次用 erl 命令启动一个 erlang shell，就是启动了一个 <code>Node</code>.</p><p>我们有两种办法连接两个 Node。第一种是显式的调用 <code>net_kernel:connect_node/1</code>，第二种是在使用 RPC 调用一个远程的方法的时候，自动加入集群。</p><p>来试一下，先启动第一个 node，命名为 ‘node1’, 绑定在 127.0.0.1 上。并设置 erlang distribution cookie：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -name node1@127.0.0.1 -setcookie <span class="hljs-string">&#x27;dist-cookie&#x27;</span></span>(node1@127.0.0.1)1&gt;</code></pre><p>cookie 是用来保护分布式系统安全的，只有设置了相同 cookie 的 node 才能建立分布式连接。</p><p>我们在另外一个终端里，再启动一个新的 node2：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -name node2@127.0.0.1 -setcookie <span class="hljs-string">&#x27;dist-cookie&#x27;</span></span>(node2@127.0.0.1)1&gt; nodes().[](node2@127.0.0.1)2&gt; net_kernel:connect_node(&#x27;node1@127.0.0.1&#x27;).true(node2@127.0.0.1)3&gt; nodes().[&#x27;node1@127.0.0.1&#x27;](node2@127.0.0.1)4&gt;</code></pre><p><code>erlang:nodes/0</code> 用来显示与当前建立了分布式连接的那些 nodes。</p><p>再启动一个新的 node:</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -name node3@127.0.0.1 -setcookie <span class="hljs-string">&#x27;dist-cookie&#x27;</span></span>(node3@127.0.0.1)1&gt; net_adm:ping(&#x27;node1@127.0.0.1&#x27;).pong(node3@127.0.0.1)2&gt; nodes().[&#x27;node1@127.0.0.1&#x27;,&#x27;node2@127.0.0.1&#x27;](node3@127.0.0.1)3&gt;</code></pre><p>这次我们仅仅 ping 了一下 node1, 就已经建立了 node1, node2, node3 所有 3 台 node 组成的集群。</p><p>前面我们有提到过，发送消息语句完全适应分布式环境，我们来试试：<br>在 node2 里查看一下当前 erlang shell 的 PID：</p><pre><code class="hljs shell">(node2@127.0.0.1)4&gt; self().&lt;0.63.0&gt;</code></pre><p>在 node3 里，我们查看一下这个 &lt;0.63.0&gt; 对应到本地的 PID 系统是怎么表示的：</p><pre><code class="hljs shell">(node3@127.0.0.1)7&gt; ShellNode2 = rpc:call(&#x27;node2@127.0.0.1&#x27;, erlang, list_to_pid, [&quot;&lt;0.63.0&gt;&quot;]).&lt;7525.63.0&gt;<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 然后我们给它发个消息：</span>(node3@127.0.0.1)8&gt; ShellNode2 ! &quot;hi, I&#x27;m node3&quot;.&quot;hi, I&#x27;m node3&quot;</code></pre><p>在 node2 里，我们就会收到这条消息：</p><pre><code class="hljs shell">(node2@127.0.0.1)5&gt; flush().Shell got &quot;hi, I&#x27;m node3&quot;ok</code></pre><p>看到了吧，只要我们知道一个 PID，不论他是在本地 node 还是在远端，我们都能用 <code>!</code> 发送消息，语义完全一样。<br>所以前面的聊天程序里，我们只需要把 PID 存到 mnesia，让它在各个 node 之间共享，就可以实现从单节点到分布式的无缝迁移。</p><h4 id="分布式-Erlang-怎么工作的？"><a href="#分布式-Erlang-怎么工作的？" class="headerlink" title="分布式 Erlang 怎么工作的？"></a>分布式 Erlang 怎么工作的？</h4><p>启动 erlang 的时候，系统会确保一个 epmd (erlang port mapping daemon) 已经起来了。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> lsof -i -n -P | grep TCP | grep epmd</span>epmd      22871 liuxinyu    3u  IPv4 0x1b13d7ce066b8f6d      0t0  TCP *:4369 (LISTEN)epmd      22871 liuxinyu    4u  IPv6 0x1b13d7ce04d5741d      0t0  TCP *:4369 (LISTEN)epmd      22871 liuxinyu    5u  IPv4 0x1b13d7ce0830f865      0t0  TCP 127.0.0.1:4369-&gt;127.0.0.1:59719 (ESTABLISHED)epmd      22871 liuxinyu    6u  IPv4 0x1b13d7ce055ded7d      0t0  TCP 127.0.0.1:4369-&gt;127.0.0.1:52371 (ESTABLISHED)epmd      22871 liuxinyu    7u  IPv4 0x1b13d7ce10169295      0t0  TCP 127.0.0.1:4369-&gt;127.0.0.1:52381 (ESTABLISHED)epmd      22871 liuxinyu    9u  IPv4 0x1b13d7ce12755d7d      0t0  TCP 127.0.0.1:4369-&gt;127.0.0.1:53066 (ESTABLISHED)</code></pre><p><code>epmd</code> 监听在系统的 4369 端口，并记录了本地所有 erlang node 开放的分布式端口。</p><p>来看一下 node1 使用的端口情况：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> lsof -i -n -P | grep TCP | grep beam</span>beam.smp  47263 liuxinyu   25u  IPv4 0x1b13d7ce10713b8d      0t0  TCP *:52370 (LISTEN)beam.smp  47263 liuxinyu   26u  IPv4 0x1b13d7ce10713295      0t0  TCP 127.0.0.1:52371-&gt;127.0.0.1:4369 (ESTABLISHED)beam.smp  47263 liuxinyu   27u  IPv4 0x1b13d7ce12754295      0t0  TCP 127.0.0.1:52370-&gt;127.0.0.1:52405 (ESTABLISHED)beam.smp  47263 liuxinyu   28u  IPv4 0x1b13d7ce12844295      0t0  TCP 127.0.0.1:52370-&gt;127.0.0.1:53312 (ESTABLISHED)</code></pre><p>epmd 工作的原理是：</p><ul><li>node1 监听在 52370 端口。</li><li>当 node2 尝试连接 <a href="mailto:node1@127.0.0.1">node1@127.0.0.1</a> 的时候，node2 首先去 127.0.0.1 机器上的 empd 请求一下，获得 node1 监听的端口号：52370。</li><li>然后 node2 使用一个临时端口号 52405 作为 client 端，与 node1 的 52370 建立了 TCP 连接。</li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>我们 Hello World 程序的教学目的是，熟悉如何创建一个可以上线的项目。<br>让我们用 <a href="https://erlang.mk/">erlang.mk</a> 创建一个真正的 hello world 工程。很多项目是用 <a href="https://www.rebar3.org/">rebar</a> 的，到时候自己学吧。</p><h4 id="OTP-工程的基本框架"><a href="#OTP-工程的基本框架" class="headerlink" title="OTP 工程的基本框架"></a>OTP 工程的基本框架</h4><p><img src="https://upload-images.jianshu.io/upload_images/2997299-141ff6db199368d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-03-21 下午4.12.36.png"></p><ul><li>一个项目可以包含很多个 <code>Application</code>, 每个 application 包含了本应用的所有代码，可以随时加载和关闭。</li><li>一个 Application 一般会包含一个顶层 <code>Supervisor</code> 进程，这个顶层 Supervisor 下面管理了许多 sub Supervisor 和 <code>worker</code> 进程。</li><li>Supervisor 是用来监控 <code>worker</code> 的, 我们的业务逻辑都在 worker 里面，supervisor 里可以定制重启策略，如果返现某个 worker 挂掉了，我们可以按照既定的策略重启它。</li><li>这个框架叫做 <code>Supervision Tree</code>.</li></ul><p>Supervisor 可用的重启策略：</p><ul><li>one_for_all：如果一个子进程挂了，重启所有的子进程</li><li>one_for_one：如果一个子进程挂了，只重启那一个子进程</li><li>rest_for_one：如果一个子进程挂了，只重启那个子进程，以及排在那个子进程后面的所有子进程 (一个 supervisor 会按顺序启动很多子进程，排在一个子进程后面的叫 <code>rest</code>)。</li><li>simple_one_for_one：当你想要动态的启动一个进程的多个实例时，用这个策略。比如来一个 socket 连接我们就启动一个 handler 进程，就适用于这种。</li></ul><p>我们在后面的实例中理解这些概念。</p><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p><a href="https://erlang.mk/guide/getting_started.html#_creating_a_folder_for_your_project">官方示例</a></p><p>我们首先创建一个 hello_world 目录，然后在里面建立工程的基本框架：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir hello_world &amp;&amp; <span class="hljs-built_in">cd</span> hello_world</span><span class="hljs-meta">$</span><span class="bash"> curl -O https://erlang.mk/erlang.mk</span><span class="hljs-meta"></span><span class="hljs-meta">$</span><span class="bash"> make -f erlang.mk bootstrap SP=2</span><span class="hljs-meta">$</span><span class="bash"> make -f erlang.mk bootstrap-rel</span><span class="hljs-meta">$</span><span class="bash"> l</span>total 480drwxr-xr-x  7 liuxinyu  staff   238B  3 21 15:21 .drwxr-xr-x  9 liuxinyu  staff   306B  3 21 15:04 ..-rw-r--r--  1 liuxinyu  staff   167B  3 21 15:21 Makefile-rw-r--r--  1 liuxinyu  staff   229K  3 21 15:14 erlang.mkdrwxr-xr-x  4 liuxinyu  staff   136B  3 21 15:14 rel-rw-r--r--  1 liuxinyu  staff   164B  3 21 15:14 relx.configdrwxr-xr-x  4 liuxinyu  staff   136B  3 21 15:21 src<span class="hljs-meta">$</span><span class="bash"> l rel/</span>total 16drwxr-xr-x  4 liuxinyu  staff   136B  3 21 15:14 .drwxr-xr-x  7 liuxinyu  staff   238B  3 21 15:21 ..-rw-r--r--  1 liuxinyu  staff     5B  3 21 15:14 sys.config-rw-r--r--  1 liuxinyu  staff    58B  3 21 15:14 vm.args</code></pre><p>然后我们创建一个 hello_world.erl, 模板是 gen_server :</p><pre><code class="hljs erlang">$ make new t=gen_server n=hello_world SP=<span class="hljs-number">2</span>$ l srctotal <span class="hljs-number">24</span>drwxr-xr-x  <span class="hljs-number">5</span> liuxinyu  staff   <span class="hljs-number">170</span>B  <span class="hljs-number">3</span> <span class="hljs-number">21</span> <span class="hljs-number">19</span>:<span class="hljs-number">01</span> .drwxr-xr-x  <span class="hljs-number">8</span> liuxinyu  staff   <span class="hljs-number">272</span>B  <span class="hljs-number">3</span> <span class="hljs-number">21</span> <span class="hljs-number">18</span>:<span class="hljs-number">59</span> ..-rw-r--r--  1 liuxinyu  staff   673B  3 21 19:01 hello_world.erl-rw-r--r--  1 liuxinyu  staff   170B  3 21 18:59 hello_world_app.erl-rw-r--r--  1 liuxinyu  staff   233B  3 21 18:59 hello_world_sup.erl</code></pre><p>以上我们生成的文件里，文件命名有一些约定。与工程名同名的文件 hello_world.erl 里是我们的 worker，gen_server 的模板文件，是工程的入口文件。<code>_app</code> 后缀的是 application behavior, <code>_sup</code> 结尾的是 supervisor behavior.</p><p>hello_world_app.erl 里面，start/2 函数启动的时候，启动了整个应用的顶层 supervisor，hello_world_sup:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>  hello_world_sup:start_link().</code></pre><p>hello_world_sup.erl 里面，调用 supervisor:start_link/3 之后，supervisor 会回调 init/1。我们需要在 init/1 中做一些初始化参数的设置:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([])</span> -&gt;</span>  <span class="hljs-comment">%% 重启策略是 one_for_one</span>  <span class="hljs-comment">%% 重启频率是5 秒内最多重启1次，如果超过这个频率就不再重启</span>  SupFlags = #&#123;strategy =&gt; one_for_one, intensity =&gt; <span class="hljs-number">1</span>, period =&gt; <span class="hljs-number">5</span>&#125;,  <span class="hljs-comment">%% 只启动一个子进程，类型是 worker</span>  Procs = [#&#123;id =&gt; hello_world,   <span class="hljs-comment">%%  给子进程设置一个名字，supervisor 用这个名字标识这个进程。</span>              start =&gt; &#123;hello_world, start_link, []&#125;, <span class="hljs-comment">%% 启动时调用的 Module:Function(Args)</span>              restart =&gt; permanent,  <span class="hljs-comment">%% 永远需要重启</span>              shutdown =&gt; brutal_kill, <span class="hljs-comment">%% 关闭时不需要等待，直接强行杀死进程</span>              type =&gt; worker,              modules =&gt; [cg3]&#125;],  <span class="hljs-comment">%% 使用的 Modules</span>  &#123;ok, &#123;SupFlags, Procs&#125;&#125;.</code></pre><p>在 hello_world.erl 里的 init/1 里添加一个 timer</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([])</span> -&gt;</span>  timer:send_interval(<span class="hljs-number">10000</span>, &#123;interval, <span class="hljs-number">3</span>&#125;), <span class="hljs-comment">%% 每隔 10 秒发一个 &#123;interval, 3&#125; 给自己进程</span>  &#123;ok, #state&#123;&#125;&#125;.</code></pre><p>最后 make run 看看效果。可以看到每次崩溃都会被 supervisor 重启：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make run</span>(hello_world@127.0.0.1)1&gt; hello_world(&lt;0.228.0&gt;): doing something bad now...=ERROR REPORT==== 21-Mar-2018::19:44:35 ===** Generic server &lt;0.228.0&gt; terminating** Last message in was &#123;interval,3&#125;...hello_world(&lt;0.247.0&gt;): doing something bad now...=ERROR REPORT==== 21-Mar-2018::19:44:58 ===** Generic server &lt;0.247.0&gt; terminating** Last message in was &#123;interval,3&#125;</code></pre><p>然后添加一个 timer 的回调函数，回调函数里故意写了一行让程序崩溃的代码</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(&#123;interval, Num&#125;, State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;~p(~p): doing something bad now...~n&quot;</span>, [?MODULE, self()]),  <span class="hljs-number">1</span> = Num,  &#123;noreply, State&#125;;</code></pre><p>完整代码：<br><a href="https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/hello_world">https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/hello_world</a></p><h1 id="然后呢？"><a href="#然后呢？" class="headerlink" title="然后呢？"></a>然后呢？</h1><p>以上你已经学会了基本的 Erlang 常用技能，可以投入工作了。<br>当你使用 Erlang 有了一段时间，想要系统学习和掌握它的时候，看下面的资料：</p><ul><li><a href="http://learnyousomeerlang.com/content">Learn You Some Erlang for Great Good</a>：Fred 老师擅长讲故事，灵魂画风。可能是多数Erlang从业者的第一位老师。</li><li><a href="https://www.manning.com/books/erlang-and-otp-in-action">Erlang and OTP In Action</a>: 快速教会你在生产环境中，怎么使用 Erlang。</li><li><a href="http://shop.oreilly.com/product/0636920024149.do">Designing for Scalability with Erlang/OTP</a>: 作者以其丰富的从业经验，告诉你如何使用 Erlang 设计可伸缩的系统。</li><li><a href="https://erldocs.com/">Erldocs</a> 平常你需要查文档的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟学Erlang (二)</title>
    <link href="/2021/01/16/clpqt1iu900284cue8ia9ggr9.html"/>
    <url>/2021/01/16/clpqt1iu900284cue8ia9ggr9.html</url>
    
    <content type="html"><![CDATA[<p>作者：Shawn # 概要：那些已经有过至少一门编程语言基础，并且需要快速了解Erlang，掌握其基本要点，并马上投入工作中的人。<br>文章挺长，所以分成了几篇。但只要掌握了本文中提到的这些知识点，你就可以上手工作了。剩下的就是在实践中继续学习。</p><span id="more"></span><blockquote><p>本文来自我的同事Shawn大佬的总结，Shawn大佬是目前国内Erlang领域内的权威开发架构师，30分钟学erlang系列文章是Shawn的一线经验，对于新入门的朋友很有帮助。再次感谢Shawn花时间整理博客，和贡献文档供社区学习。</p></blockquote><h1 id="30分钟学Erlang-一"><a href="#30分钟学Erlang-一" class="headerlink" title="30分钟学Erlang (一)"></a>30分钟学Erlang (一)</h1><h3 id="本文写给谁看的？"><a href="#本文写给谁看的？" class="headerlink" title="本文写给谁看的？"></a>本文写给谁看的？</h3><p>那些已经有过至少一门编程语言基础，并且需要快速了解Erlang，掌握其基本要点，并马上投入工作中的人。<br>文章挺长，所以分成了几篇。但只要掌握了本文中提到的这些知识点，你就可以上手工作了。剩下的就是在实践中继续学习。<br><code>Erlang 读作 ai lan, er lan, er lang 都行，但你别单个字母读 E-R-L-A-N-G，那样我就不跟你玩了。</code></p><h3 id="什么时候用-Erlang？"><a href="#什么时候用-Erlang？" class="headerlink" title="什么时候用 Erlang？"></a>什么时候用 Erlang？</h3><p>Erlang 的设计目标非常明确，就是专门为大型的电信系统设计。<br>所以它的应用场景和设计需求就是电信领域里需要解决的问题。<br>主要是三个： <strong>高并发</strong>、<strong>高容错</strong>、<strong>软实时</strong>。电信系统负载非常大，需要同时服务大量用户的能力；同时不允许出错，电话频繁掉线会很快把客户赶到竞争对手那边；再者，即便某个通话再繁忙也不能影响其他通话的正常进行，到技术层面就是，不能因为某个任务很重，就把其他的任务的资源都占用了，while loop 占用 100% CPU是绝对不允许的。</p><p>Erlang 是实用主义的语言，属于函数式语言但并不是完全的函数式，使用 Actor 并发模型，并在此之上提供了一些更高级别的设计模式，还提供了各种常用的功能组件(e.g. HTTP客户端, XML编解码等)。Erlang 早已经脱离电信行业，飞奔到互联网行业了，因为这些年互联网行业所面临的问题，跟几十年前的电信系统越来越像。如今，<a href="http://www.emqtt.io">Erlang 正在进入物联网行业</a>，它将为世界物联网的发展做出自己的贡献。</p><h3 id="Erlang-的不同之处"><a href="#Erlang-的不同之处" class="headerlink" title="Erlang 的不同之处"></a>Erlang 的不同之处</h3><p>如果问到 Erlang (相较于其他编程语言) 的特别之处，有人会回答它的并发能力，有人会说并发模型或者分布式能力。这些人都不是真正理解 Erlang 设计目的的“正规军”，因为 Erlang 与其他语言最大的区别在于他的容错能力。Erlang 从设计之初就将容错作为最高级别的任务，它的大多数特性是都为容错服务的：</p><p>抢占式调度的虚拟机和基于每个进程的垃圾回收保证了软实时能力，进程并发模型保证了单个进程异常终止不会将异常扩散到其他进程，消息传递模型消除了共享内存导致的竞态条件，OTP 提供的程序组织结构 application 和 supervisor tree 更是 Erlang 独有的高容错架构，热更新功能则提供了开着跑车换轮子的能力。</p><p>所以当别人问到你 Erlang 最大的特点是什么，就两个字：容错。</p><h2 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h2><p>学习 Erlang 等小众语言的过程中，没有太多中文资料，所以这篇文章里，对于名词、概念类的，还是用英文原词不做翻译。以免造成以后学习的障碍。</p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li>For <a href="http://brew.sh/">Homebrew</a> on OS X: brew install erlang</li><li>For <a href="https://www.macports.org/">MacPorts</a> on OS X: port install erlang</li><li>For <a href="http://www.ubuntu.com/">Ubuntu</a> and <a href="https://www.debian.org/">Debian</a>: apt-get install erlang</li><li>For <a href="https://getfedora.org/">Fedora</a>: yum install erlang</li><li>For <a href="https://www.freebsd.org/">FreeBSD</a>: pkg install erlang</li></ul><h5 id="启动-Erlang-Shell"><a href="#启动-Erlang-Shell" class="headerlink" title="启动 Erlang Shell"></a>启动 Erlang Shell</h5><p>安装完成后，在终端里敲 ‘erl’ 进入 Erlang 的 <a href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF">REPL</a>，erlang shell:</p><pre><code class="hljs shell">➜  ~ erlErlang/OTP 20 [erts-9.3] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]Eshell V9.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> io:format(<span class="hljs-string">&quot;hello world!~n&quot;</span>).</span>hello world!ok<span class="hljs-meta">2&gt;</span><span class="bash"> 1 + 1.</span>2<span class="hljs-meta">3&gt;</span><span class="bash"> q().</span>ok                                                                       ➜  ~</code></pre><p>上面 Erlang shell 里:</p><ul><li>第一行 <code>io:format(&quot;hello world!~n&quot;).</code> 向标准输出写了一行 <code>&quot;hello world!&quot;</code>, 并以 “~n” 换行结尾。最后显示的那个 <code>ok</code> 是<code>io:format()</code> 函数的返回值。</li><li>第二行 <code>1 + 1.</code> 做了个加法运算，返回值是 <code>2</code>。</li><li>第三行 <code>q().</code> 是退出 erlang shell, 是 <code>init:stop().</code> 的快捷方式. 连续按两次<code>Ctrl - C</code>, 或者 <code>Ctrl - C</code> 之后选 <code>q</code>, 是一样的效果。</li></ul><p>上面的两个例子展示了几个要点：</p><ul><li>Erlang 的每个语句都要用 <code>.</code> 结尾。</li><li>Erlang 是函数式语言，所有的函数、表达式都必须有一个返回值。输出 “hello world” 会返回一个 atom 类型的 <code>ok</code>。</li><li><code>Ctrl - C</code> 然后 <code>q</code> or <code>a</code>, 或者 <code>q().</code> 会退出 shell，如果你运行了代码的话，你的应用程序会连带着一起关掉。所以线上系统千万不要 <code>Ctrl - C</code>。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Erlang 里用 % 来做行注释，相当于C语言里的 //, 或者Python里的 #。 没有块注释。</p><pre><code class="hljs erlang"><span class="hljs-comment">% I am a comment</span><span class="hljs-function"><span class="hljs-title">test_fuc</span><span class="hljs-params">()</span> -&gt;</span>   <span class="hljs-string">&quot;test&quot;</span>.</code></pre><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p><code>摘取自 learn-you-some-erlang，并为你们这些有经验的程序员删减和加工</code></p><h5 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h5><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> 2 + 15.</span>17<span class="hljs-meta">2&gt;</span><span class="bash"> 49 * 100.</span>4900<span class="hljs-meta">3&gt;</span><span class="bash"> 1892 - 1472.</span>420<span class="hljs-meta">4&gt;</span><span class="bash"> 5 / 2.   %% 最常用的浮点数除法</span>2.5<span class="hljs-meta">5&gt;</span><span class="bash"> 5 div 2.  %% div 是整除</span>2<span class="hljs-meta">6&gt;</span><span class="bash"> 5 rem 2.  %% rem 是取余运算</span>1...<span class="hljs-meta">%</span><span class="bash">% 数字前面可以用 ‘<span class="hljs-comment">#’ 来标注其 ‘Base’</span></span><span class="hljs-meta">%</span><span class="bash">% 语法：Base<span class="hljs-comment">#Value</span></span><span class="hljs-meta">%</span><span class="bash">% 默认的 Base 是 10</span> ...<span class="hljs-meta">10&gt;</span><span class="bash"> 2<span class="hljs-comment">#101010.  %% 2 进制的 101010</span></span>42<span class="hljs-meta">11&gt;</span><span class="bash"> 8<span class="hljs-comment">#0677.  %% 8 进制的 0677</span></span>447<span class="hljs-meta">12&gt;</span><span class="bash"> 16<span class="hljs-comment">#AE.   %% 16 进制的 AE</span></span>174</code></pre><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>Erlang 是函数式语言(虽然也支持副作用)。这意味着 Erlang 里的变量 ‘ <strong>Immutable</strong>’ (不可变的).<br>Immutable variables 在设计上简单，减少了并发过程中处理状态改变带来的复杂性。理解这一点很重要。</p><p>Erlang 是动态类型的语言，但它也是强类型的语言。动态类型意味着你声明变量时不需要指定类型，而强类型是说，erlang 不会偷偷做类型转换:</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> 6 + <span class="hljs-string">&quot;1&quot;</span>.</span>** exception error: bad argument in an arithmetic expressionin operator  +/2called as 6 + &quot;1&quot;</code></pre><p>Erlang 里变量的命名有约定，必须首字母大写。因为首字母小写的，会被认为是 <code>atom</code> (原子) 类型。<br><code>这一点在 elixir 里有改进</code></p><p>正常的变量命名比如 Hello, Test. 而像 hello, test 这种的不是变量名，他们是 <code>atom</code> 类型，跟数字、字符串一样，是值类型：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Hello = <span class="hljs-string">&quot;hello?&quot;</span>.</span>&quot;hello?&quot;<span class="hljs-meta">2&gt;</span><span class="bash"> Test = <span class="hljs-string">&quot;testing words&quot;</span>.</span>&quot;testing words&quot;<span class="hljs-meta">3&gt;</span><span class="bash"> hello.</span>hello<span class="hljs-meta">4&gt;</span><span class="bash"> V1 = hello.  %% <span class="hljs-built_in">bind</span> atom hello to V1</span>hello<span class="hljs-meta">5&gt;</span><span class="bash"> V1.</span>hello</code></pre><p>Erlang 里没有赋值语句。<code>=</code> 在 Erlang 里是 <code>pattern matching</code> (匹配、模式匹配)，如果 <code>=</code> 左侧跟右侧的值不相等，就叫没匹配上，这时那个 erlang 进程会直接异常崩溃(不要害怕，erlang 里面崩溃挺正常的)。如果 <code>=</code> 左侧的变量还没有值，这次匹配过后，右侧的值就会 <code>bind</code> (绑定) 到那个变量上。</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> One.     %% 变量没绑定，不能使用。所以这里出错了。</span>* 1: variable &#x27;One&#x27; is unbound<span class="hljs-meta">2&gt;</span><span class="bash"> One = 1.   %% 匹配变量 One 与 1. 由于One 之前没有绑定过值，这里将 Number 1 绑定给 One</span>1<span class="hljs-meta">3&gt;</span><span class="bash"> Un = Uno = One = 1.</span>  <span class="hljs-meta">%</span><span class="bash">% 1) 匹配 Un, Uno, One 和 1. One 的值是 1, 所以最右侧的 One = 1 匹配成功，匹配操作返回值是 1.</span> <span class="hljs-meta">%</span><span class="bash">% 2) 然后继续与左边的 Uno 匹配。 Uno 之前没有绑定过值，所以将 1 绑定给 Uno，匹配操作返回值也是 1.</span>  <span class="hljs-meta">%</span><span class="bash">% 3) 同理 Un 也被绑定为 1. 返回值也是 1.</span>1<span class="hljs-meta">4&gt;</span><span class="bash"> Two = One + One. %% Two 这时候被绑定为 2.</span>2<span class="hljs-meta">5&gt;</span><span class="bash"> Two = 2.    %% 尝试匹配 2 = 2. 成功并返回 2.</span>2<span class="hljs-meta">6&gt;</span><span class="bash"> Two = Two + 1.  %% 尝试匹配 2 = 3. 失败了，所以当前的 erlang shell 进程崩溃了，然后又自动给你启动了一个新的 erlang shell。</span>** exception error: no match of right hand side value 3<span class="hljs-meta">7&gt;</span><span class="bash"> two = 2.  %% 尝试匹配一个 atom 和一个数字: two = 2. 匹配, 失败崩溃了。</span>** exception error: no match of right hand side value 2<span class="hljs-meta">8&gt;</span><span class="bash"> _ = 14+3.  %% 下划线 _ 是个特殊保留字，表示 <span class="hljs-string">&quot;ignore&quot;</span>，可以匹配任何值。</span>17<span class="hljs-meta">9&gt;</span><span class="bash"> _.</span>* 1: variable &#x27;_&#x27; is unbound<span class="hljs-meta">10&gt;</span><span class="bash"> _Ignore = 2.  %% 以下划线开头的变量跟普通的变量作用没有什么区别，只不过在代码中，以下滑线开头的变量告诉编译器，<span class="hljs-string">&quot;如果这个变量后面我没用到的话，也不要警告我!&quot;</span></span>2<span class="hljs-meta">11&gt;</span><span class="bash"> _Ignore.</span>2 <span class="hljs-meta">12&gt;</span><span class="bash"> _Ignore = 3.</span>** exception error: no match of right hand side value 3</code></pre><h5 id="Atoms"><a href="#Atoms" class="headerlink" title="Atoms"></a>Atoms</h5><p>上面已经提到过了，Erlang 里面有 <code>atom</code> 类型，atom 类型使用的内存很小，所以常用来做函数的参数和返回值。参加 pattern matching 的时候，运算也非常快速。<br>在其他没有 atom 的语言里，你可能用过 <code>constant</code> 之类的东西，一个常量需要对应一个数字值或者其他类型的值。比如：</p><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> red = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> green = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> blue = <span class="hljs-number">3</span>;</code></pre><p>但多了这个映射，其实用起来不大方便，后面对应的值 1， 2，3 一般只是用来比较，具体是什么值都关系不大。所以有了 <code>atom</code> 就很方便了，我们从字面上就能看出，这个值是干嘛的:</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> red.</span>red</code></pre><p><code>atom</code> 类型支持的写法：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> atom.</span>atom<span class="hljs-meta">2&gt;</span><span class="bash"> atoms_rule.</span>atoms_rule<span class="hljs-meta">3&gt;</span><span class="bash"> atoms_rule@erlang.</span>atoms_rule@erlang<span class="hljs-meta">4&gt;</span><span class="bash"> <span class="hljs-string">&#x27;Atoms can be cheated!&#x27;</span>.  %% 包含空格等特殊字符的 atom 需要用单引号括起来</span>&#x27;Atoms can be cheated!&#x27;<span class="hljs-meta">5&gt;</span><span class="bash"> atom = <span class="hljs-string">&#x27;atom&#x27;</span>.</span>atom</code></pre><p><strong>需要注意的是</strong>：在一个 erlang vm 里，可创建的 atom 的数量是有限制的(默认是 1,048,576 )，因为erlang 虚拟机创建 atom 表也是需要内存的。一旦创建了某个 atom，它就一直存在那里了，不会被垃圾回收。不要在代码里动态的做 string -&gt; atom 的类型转换，这样最终会使你的 erlang atom 爆表。比如在你的接口逻辑处理的部分做 to atom 的转换的话，别人只需要用不一样的参数不停地调用你的接口，就可以攻击你。</p><h5 id="Boolean-以及比较"><a href="#Boolean-以及比较" class="headerlink" title="Boolean 以及比较"></a>Boolean 以及比较</h5><p><code>atom</code> 类型的 <code>true</code> 和 <code>false</code> 两个值，被用作布尔处理。</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> <span class="hljs-literal">true</span> and <span class="hljs-literal">false</span>.     %% 逻辑 并</span>false<span class="hljs-meta">2&gt;</span><span class="bash"> <span class="hljs-literal">false</span> or <span class="hljs-literal">true</span>.     %% 逻辑 或</span>true<span class="hljs-meta">3&gt;</span><span class="bash"> <span class="hljs-literal">true</span> xor <span class="hljs-literal">false</span>.     %% 逻辑 异或</span>true<span class="hljs-meta">4&gt;</span><span class="bash"> not <span class="hljs-literal">false</span>.     %% 逻辑 非</span>true<span class="hljs-meta">5&gt;</span><span class="bash"> not (<span class="hljs-literal">true</span> and <span class="hljs-literal">true</span>).</span>false</code></pre><p>还有两个与 <code>and</code> 和 <code>or</code> 类似的操作：<code>andalso</code> 和 <code>orelse</code>。区别是 <code>and</code> 和 <code>or</code> 不论左边的运算结果是真还是假，都会执行右边的操作。而 <code>andalso</code> 和 <code>orelse</code>是短路的，意味着右边的运算不一定会执行。</p><p>来看一下比较：</p><pre><code class="hljs shell"><span class="hljs-meta">6&gt;</span><span class="bash"> 5 =:= 5.    %% =:= 是<span class="hljs-string">&quot;严格相等&quot;</span>运算符，== <span class="hljs-string">&quot;是大概相等&quot;</span></span>true<span class="hljs-meta">7&gt;</span><span class="bash"> 1 =:= 0.</span>false<span class="hljs-meta">8&gt;</span><span class="bash"> 1 =/= 0.   %%  =/= 是<span class="hljs-string">&quot;严格不等&quot;</span>运算符，/= <span class="hljs-string">&quot;是相差很多&quot;</span></span>true<span class="hljs-meta">9&gt;</span><span class="bash"> 5 =:= 5.0.</span>false<span class="hljs-meta">10&gt;</span><span class="bash"> 5 == 5.0.</span>true<span class="hljs-meta">11&gt;</span><span class="bash"> 5 /= 5.0.</span>false</code></pre><p>一般如果懒得纠结太多，用 =:= 和 =/= 就可以了。</p><pre><code class="hljs shell"><span class="hljs-meta">12&gt;</span><span class="bash"> 1 &lt; 2.</span>true<span class="hljs-meta">13&gt;</span><span class="bash"> 1 &lt; 1.</span>false<span class="hljs-meta">14&gt;</span><span class="bash"> 1 &gt;= 1.      %% 大于等于</span>true<span class="hljs-meta">15&gt;</span><span class="bash"> 1 =&lt; 1.      %% 注意这个 <span class="hljs-string">&quot;小于等于&quot;</span> 的写法，= 在前面。因为 =&gt; 还有其他的用处。。</span>true<span class="hljs-meta">17&gt;</span><span class="bash"> 0 == <span class="hljs-literal">false</span>.  %% 数字和 atom 类型是不相等的</span>false<span class="hljs-meta">18&gt;</span><span class="bash"> 1 &lt; <span class="hljs-literal">false</span>.</span>  true</code></pre><p>虽然不同的类型之间可以比较，也有个对应的顺序，但一般情况用不到的:<br><code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</code></p><h5 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h5><p><code>Tuple</code> 类型是多个不同类型的值组合成的类型。有点类似于 C 语言里的 <code>struct</code>。<br>语法是：<code>&#123;Element1, Element2, ..., ElementN&#125;</code></p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> X = 10, Y = 4.</span>4<span class="hljs-meta">2&gt;</span><span class="bash"> Point = &#123;X,Y&#125;.  %% Point 是个 Tuple 类型，包含了两个整形的变量 X 和 Y</span>&#123;10,4&#125;</code></pre><p>实践中，我们经常 在 tuple 的第一个值放一个 atom 类型，来标注这个 tuple 的含义。这种叫做 tagged tuple: </p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Data1 = &#123;point, 1, 2&#125;.</span>&#123;point,1,2&#125;<span class="hljs-meta">2&gt;</span><span class="bash"> Data2 = &#123;rectangle, 20, 30&#125;.</span>&#123;rectangle,20,30&#125;</code></pre><p>后面的代码如果要处理 Data1 和 Data2 的话，只需要检查 tuple 的第一项，就知道这个 tuple 是个点坐标，还是个矩形:</p><pre><code class="hljs shell"><span class="hljs-meta">3&gt;</span><span class="bash"> <span class="hljs-keyword">case</span> Data1 of</span><span class="hljs-meta">3&gt;</span><span class="bash">   &#123;point, X, Y&#125; -&gt; <span class="hljs-string">&quot;this is a point&quot;</span>;</span><span class="hljs-meta">3&gt;</span><span class="bash">   &#123;rectangle, Length, Width&#125; -&gt; <span class="hljs-string">&quot;this is a rectangle&quot;</span></span><span class="hljs-meta">3&gt;</span><span class="bash"> end.</span>&quot;this is a point&quot;</code></pre><p>上面用 <code>case</code> 做 pattern matching ，这个后面还要讲。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><code>List</code> 就是我们经常说的链表，数据结构里学的那个。但 List 类型在 Erlang 里使用极其频繁，因为用起来很方便。</p><p><code>List</code> 可以包含各种类型的值:</p><pre><code class="hljs erlang-repl"><span class="hljs-meta">1&gt; </span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, &#123;numbers,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;, <span class="hljs-number">5.34</span>, atom].[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,&#123;numbers,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;,<span class="hljs-number">5.34</span>,atom]</code></pre><p>上面这个 list 包含了数字类型 1，2，3，一个 tuple，一个浮点数，一个 atom 类型。</p><p>来看看这个：</p><pre><code class="hljs erlang-repl"><span class="hljs-meta">2&gt; </span>[<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>].<span class="hljs-string">&quot;abc&quot;</span></code></pre><p>卧槽这什么意思？！因为 Erlang 的 String 类型其实就是 List！所以 erlang shell 自动给你显示出来了。<br>就是说如果你这么写 <code>&quot;abc&quot;</code>, 跟 <code>[97, 98, 99]</code> 是等效的。<br>链表存储空间还是比纯字符串数组大的，拼接等操作也费时，所以一般如果你想用 ‘真 · 字符串’ 的时候，用 Erlang 的 <code>Binary</code> 类型，这样写：<code>&lt;&lt;&quot;abc&quot;&gt;&gt;</code>。这样内存消耗就小很多了。Binary 这是后话了，这篇文章里不介绍。</p><p>我知道一开始你可能不大明白 tuple 跟 list 的区别，这样吧：</p><ul><li>当你知道你的数据结构有多少项的时候，用 <code>Tuple</code>；</li><li>当你需要动态长度的数据结构时，用 <code>List</code>。</li></ul><p><strong>List 处理:</strong></p><pre><code class="hljs shell"><span class="hljs-meta">5&gt;</span><span class="bash"> [1,2,3] ++ [4,5].       %% ++ 运算符是往左边的那个 List 尾部追加右边的 List。</span><span class="hljs-meta">%</span><span class="bash">% 这样挺耗时的。链表嘛你知道的，往链表尾部追加，需要先遍历这个链表，找到链表的尾部。</span><span class="hljs-meta">%</span><span class="bash">% 所以 <span class="hljs-string">&quot;abc&quot;</span> ++ <span class="hljs-string">&quot;de&quot;</span> 这种的操作的复杂度，取决于前面 <span class="hljs-string">&quot;abc&quot;</span> 的长度。</span>[1,2,3,4,5]<span class="hljs-meta">6&gt;</span><span class="bash"> [1,2,3,4,5] -- [1,2,3].  %% -- 是移除操作符。</span>[4,5]<span class="hljs-meta">7&gt;</span><span class="bash"> [2,4,2] -- [2,4].</span>[2]<span class="hljs-meta">8&gt;</span><span class="bash"> [2,4,2] -- [2,4,2].</span>[]<span class="hljs-meta">9&gt;</span><span class="bash"> [] -- [1, 3].   %% 如果左边的 List 里不包含需要移除的值，也没事儿。不要拿这种东西来做面试题，这样会没朋友的。</span>[]<span class="hljs-meta">11&gt;</span><span class="bash"> hd([1,2,3,4]).</span>  1<span class="hljs-meta">12&gt;</span><span class="bash"> tl([1,2,3,4]).</span>[2,3,4]</code></pre><p>上面 hd/1 是取 Head 函数。tl/1 是取 Tail. 这俩都是 BIF (Built-In-Function)，就是 Erlang 内置函数.<br>第一行里你也看到了，List 的追加操作会有性能损耗 (lists:append/2 跟 ++ 是一回事儿)，所以我们需要一个从头部插入 List 的操作: </p><pre><code class="hljs shell"><span class="hljs-meta">13&gt;</span><span class="bash"> List = [2,3,4].</span>[2,3,4]<span class="hljs-meta">14&gt;</span><span class="bash"> NewList = [1|List].   %% 注意这个 | 的左边应该放元素，右边应该放 List。</span>[1,2,3,4]<span class="hljs-meta">15&gt;</span><span class="bash"> [1, 2 | [0]].   %% 左边元素有好几个的话，erlang 会帮你一个一个的插到头部。先插 2，后插1.</span>[1,2,0]<span class="hljs-meta">16&gt;</span><span class="bash"> [1, 2 | 0].     %%  右边放的不是 List，这种叫 <span class="hljs-string">&#x27;improper list&#x27;</span>。</span><span class="hljs-meta">%</span><span class="bash">% 虽然你可以生成这种列表，但不要这么做，代码里出现这种一般就是个 bug。忘了这种用法吧。</span>[1,2|0]<span class="hljs-meta"></span><span class="hljs-meta">20&gt;</span><span class="bash"> [1 | []].       %% List 可以分解为 [ 第一个元素 | 剩下的 List ]。仔细看一下这几行体会一下。</span>[1]<span class="hljs-meta">21&gt;</span><span class="bash"> [2 | [1 | []]].</span>[2,1]<span class="hljs-meta">22&gt;</span><span class="bash"> [3 | [2 | [1 | []] ] ].</span>[3,2,1]</code></pre><h5 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h5><p>实践中我们经常会从一个 List 中，取出我们需要的那些元素，然后做处理，最后再将处理过的元素重新构造成一个新的元素。<br>你马上就想到了 map，reduce。在 Erlang 里，我们可以用  List Comprehensions 语法，很方便的做一些简单的处理。</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> [2*N || N &lt;- [1,2,3,4]].   %% 取出  [1,2,3,4] 中的每个元素，然后乘2，返回值再组成一个新的 List</span>[2,4,6,8]<span class="hljs-meta">2&gt;</span><span class="bash"> [X || X &lt;- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0].   %% 取出右边列表里所有偶数。</span>[2,4,6,8,10]</code></pre><h5 id="Anonymous-functions"><a href="#Anonymous-functions" class="headerlink" title="Anonymous functions"></a>Anonymous functions</h5><p>让我们定义一个函数：</p><pre><code class="hljs shell">Add = fun (A, B) -&gt; A + B end.</code></pre><p>上面的代码里，我们用 fun() 定义了一个 匿名函数, 接收两个参数，并将两个参数的和作为返回值。<br>最后将这个函数 bind 到 Add 变量:</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> Add = fun (A, B) -&gt; A + B end.</span><span class="hljs-meta">#</span><span class="bash">Fun&lt;erl_eval.12.118419387&gt;</span><span class="hljs-meta">2&gt;</span><span class="bash"> Add(1, 2).</span>3</code></pre><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>本章代码在：<a href="https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/modules">https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/modules</a></p><p>Erlang Shell 是一个快速尝试新想法的地方，但我们真正的代码是要写到文件里，然后参与编译的。</p><p>Erlang 里代码是用 Module 组织的。一个 Module 包含了一组功能相近的函数。<br>用一个函数的时候，要这么调用：<code>Module:Function(arg1, arg2)</code>。<br>或者你先 <code>import</code> 某个 Module 里的函数，然后用省略Module名的方式调用：<code>Function(arg1, arg2)</code>。</p><p>Module 可也提供代码管理的作用，加载一个 Module 到 Erlang VM就加载了那个 Module 里的所有代码，然后你想热更新代码的话，直接更新这个 Module 就行了。</p><p>来看 Erlang 自带的几个 Module：</p><pre><code class="hljs erlang-repl"><span class="hljs-meta">1&gt; </span>erlang:element(<span class="hljs-number">2</span>, &#123;a,b,c&#125;).b<span class="hljs-meta">2&gt; </span>element(<span class="hljs-number">2</span>, &#123;a,b,c&#125;).b<span class="hljs-meta">3&gt; </span>lists:seq(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>).[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-meta">4&gt; </span>seq(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>).** exception error: undefined shell command seq/<span class="hljs-number">2</span></code></pre><p>上面的例子里，你能直接用 <code>erlang</code> Module 里的 element/2 函数，是因为 erlang 里的常用函数会被 潜在的 <code>import</code> 过来。其他的 Module 比如 lists 不会.</p><p><code>erlang</code> module 里的函数叫做 <code>BIF</code>.</p><p><strong>使用 Module 写 functions:</strong><br>建立一个名为 useless.erl 的文件。<br>在文件的第一行, 用 -module(useless) 来声明你的 module name。注意跟 java 类似，module 名要跟文件名一样。<br>然后你在你的 module 里写你的函数：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(useless)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([add/<span class="hljs-number">2</span>, add/<span class="hljs-number">3</span>])</span>. <span class="hljs-comment">%% export 是导出语法，指定导出 add/2, add/3 函数。没导出的函数在 Module 外是无法访问的。</span><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> -&gt;</span>  A + B.<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B, C)</span> -&gt;</span>  A + B + C.</code></pre><p>然后你用 erlc 编译</p><pre><code class="hljs shell">mkdir -p ./ebinerlc -o ebin useless.erl</code></pre><p>编译后的 beam 文件会在 ebin 目录下，然后你启动 erlang shell：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ./ebin</span>Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> useless:add(1, 2).</span>3<span class="hljs-meta">2&gt;</span><span class="bash"> useless:add(1, 2, 1).</span>4</code></pre><p>erl -pa 参数的意思是 <code>Path Add</code>, 添加目录到 erlang 的 beam 文件查找目录列表里。<br>就是说，你运行  useless:add(1, 2). 的时候，erlang 发现 module ‘useless’ 没加载，就在那些查找目录里找 useless.beam，然后加载进来。</p><p>Erlang 里面函数是用 函数名/参数个数来表示的，如果两个函数的函数名与参数个数都一样，他们就是一个函数的两个分支，必须写在一起，分支之间用分号分割。<br>上面的 add(A, B) 可以叫做 add/2, 而 add(A, B, C) 函数叫做 add/3. 注意这个 add/3和 add/2 因为参数个数不一样，所以被认为两个不同的函数，即使他们的函数名是一样的。<br>所以，第一个函数用 <code>.</code> 结尾。如果是一个函数的多个 clause, 是要用 <code>;</code> 分割的：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(clauses)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([add/<span class="hljs-number">2</span>])</span>.<span class="hljs-comment">%% goes into this clause when both A and B are numbers</span><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_number</span><span class="hljs-params">(A)</span>, <span class="hljs-title">is_number</span><span class="hljs-params">(B)</span> -&gt;</span>  A + B;<span class="hljs-comment">%% goes this clause when both A and B are lists</span><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(A, B)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_list</span><span class="hljs-params">(A)</span>, <span class="hljs-title">is_list</span><span class="hljs-params">(B)</span> -&gt;</span>  A ++ B.<span class="hljs-comment">%% crashes when no above clauses matched.</span></code></pre><p>上面代码里，定义了一个函数：add/2. 这个函数有两个 clause 分支，一个是计算数字相加的，一个是计算字符串相加的。<br>代码里 <code>when</code> 是一个 <code>Guard</code> 关键字。<code>Pattern Matching</code> 和 <code>Guard</code> 后面讲解。<br>运行 add/2 时会从上往下挨个匹配：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> clauses:add(<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-string">&quot;DEF&quot;</span>).  %% 第一个 clause 没匹配上。走的是第二个 clause。</span>&quot;ABCDEF&quot;<span class="hljs-meta">2&gt;</span><span class="bash"> clauses:add(1, 2).  %% 走第一个 clause</span>3<span class="hljs-meta">3&gt;</span><span class="bash"> clauses:add(1, 2.4).</span>3.4<span class="hljs-meta">4&gt;</span><span class="bash"> clauses:add(1, <span class="hljs-string">&quot;no&quot;</span>).  %% 两个 clause 都没匹配上，崩溃了。</span>** exception error: no function clause matching clauses:add(1,&quot;no&quot;) (clauses.erl, line 4)</code></pre><h3 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h3><h5 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h5><p>Erlang 里到处都用匹配的。</p><p><strong>1. case clauses</strong><br>下面的代码里，我们定义了一个 greet/2 函数</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(case_matching)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([greet/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(Gender, Name)</span> -&gt;</span>  <span class="hljs-keyword">case</span> Gender <span class="hljs-keyword">of</span>    male -&gt;      io:format(<span class="hljs-string">&quot;Hello, Mr. ~s!~n&quot;</span>, [Name]);    female -&gt;      io:format(<span class="hljs-string">&quot;Hello, Mrs. ~s!~n&quot;</span>, [Name]);    _ -&gt;      io:format(<span class="hljs-string">&quot;Hello, ~s!~n&quot;</span>, [Name])  <span class="hljs-keyword">end</span>.</code></pre><p>case 的各个分支是自上往下依次匹配的，如果 Gender 是 atom ‘male’, 则走第一个，如果是 ‘female’ 走第二个，如果上面两个都没匹配上，则走第三个。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> case_matching:greet(male, <span class="hljs-string">&quot;Shawn&quot;</span>).</span>Hello, Mr. Shawn!ok</code></pre><p><strong>2. function clauses</strong><br>我们把上面的例子改一下，让代码更规整一点：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(function_matching)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([greet/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(male, Name)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Hello, Mr. ~s!~n&quot;</span>, [Name]);<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(female, Name)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Hello, Mrs. ~s!~n&quot;</span>, [Name]);<span class="hljs-function"><span class="hljs-title">greet</span><span class="hljs-params">(_, Name)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Hello, ~s!~n&quot;</span>, [Name]).</code></pre><p>这个 function 有三个 clause，与 case 一样，自上往下依次匹配。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl -pa ebin/</span>Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> function_matching:greet(female, <span class="hljs-string">&quot;Scarlett&quot;</span>).</span>Hello, Mrs. Scarlett!ok<span class="hljs-meta">2&gt;</span></code></pre><h5 id="在匹配中获取值"><a href="#在匹配中获取值" class="headerlink" title="在匹配中获取值"></a>在匹配中获取值</h5><pre><code class="hljs shell"><span class="hljs-meta">3&gt;</span><span class="bash"> &#123;X, 1, 5&#125; = &#123;2, 1, 5&#125;.     %% 如果匹配成功的话，将对应的值 <span class="hljs-built_in">bind</span> 到 X 上。</span>&#123;2,1,5&#125;<span class="hljs-meta">4&gt;</span><span class="bash"> X.</span> 2<span class="hljs-meta">5&gt;</span><span class="bash"> [H | T] = [1, 2, 3].       %% 现在我们使用匹配来解析 List，将第一个元素绑定到 H, 将其余绑定到 T。</span>[1,2,3]<span class="hljs-meta">6&gt;</span><span class="bash"> H.</span>1<span class="hljs-meta">7&gt;</span><span class="bash"> T.</span>[2,3]<span class="hljs-meta"></span><span class="hljs-meta">8&gt;</span><span class="bash"> [_ | T2] = T.      %% 我可以一直这么做下去</span>[2,3]<span class="hljs-meta">9&gt;</span><span class="bash"> T2.</span>[3]<span class="hljs-meta">10&gt;</span><span class="bash"> [_ | T3] = T2.    %% 再来</span>[3]<span class="hljs-meta">11&gt;</span><span class="bash"> T3.</span>[]<span class="hljs-meta">12&gt;</span><span class="bash"> f().              %% Erlang 里面变量是 immutable 的，所以我们现在解绑一下所有变量，清理之前用过的变量名。</span>ok<span class="hljs-meta">13&gt;</span><span class="bash"> Add = fun(&#123;A, B&#125;) -&gt; A + B end.  %% 我们重新定义了 Add 函数，现在它只接收一个 tuple 参数</span><span class="hljs-meta">%</span><span class="bash">% 然后在参数列表里我们做了 pattern matching 以获取 tuple 中的两个值，解析到 A，B.</span><span class="hljs-meta">#</span><span class="bash">Fun&lt;erl_eval.6.118419387&gt;</span><span class="hljs-meta">14&gt;</span><span class="bash"> Add(&#123;1, 2&#125;).</span>   3</code></pre><p>好了，就问你厉不厉害？</p><h5 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h5><p>前面有用过 <code>when</code>, 提到过 guards. 现在我们来认真讨论它：<br>learn-you-some-erlang 的作者那边 16岁才能”开车” (笑). 那我们写个函数判断一下，某个人能不能开车？</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;...<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">14</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span> -&gt;</span> <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(_)</span> -&gt;</span> <span class="hljs-literal">true</span>.</code></pre><p>上面这个又点太繁琐了，所以我们得另想办法：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16 -&gt;</span> <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-title">old_enough</span><span class="hljs-params">(_)</span> -&gt;</span> <span class="hljs-literal">false</span>.</code></pre><p>然后作者又说了，超过 104 岁的人，禁止开车：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16, X =&lt; 104 -&gt;</span>   <span class="hljs-comment">%% 注意这里用了逗号，表示 and</span>   <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(_)</span> -&gt;</span>   <span class="hljs-literal">false</span>.</code></pre><p><code>when</code> 语句里，<code>,</code>表示 <code>and</code>, <code>;</code> 表示 <code>or</code>, 如果你想用短路运算符的话，用 <code>andalso</code> 和<code>orelse</code>,  这么写：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">right_age</span><span class="hljs-params">(X)</span> <span class="hljs-title">when</span> X &gt;= 16 <span class="hljs-title">andalso</span> X =&lt; 104 -&gt;</span> <span class="hljs-literal">true</span>;</code></pre><h5 id="Records"><a href="#Records" class="headerlink" title="Records"></a>Records</h5><p>前面讲过 <code>tagged tuple</code>，但它用起来还不够方便，因为没有个名字，也不好访问其中的变量。<br>我们来定义一个好用点的 <code>tagged tuple</code>，Erlang 里就是<code>record</code>：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(records)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([get_user_name/<span class="hljs-number">1</span>,</span><span class="hljs-params">         get_user_phone/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-record</span><span class="hljs-params">(user, &#123;</span><span class="hljs-params">  name,</span><span class="hljs-params">  phone</span><span class="hljs-params">&#125;)</span>.<span class="hljs-function"><span class="hljs-title">get_user_name</span><span class="hljs-params">(#user&#123;name=Name&#125;)</span> -&gt;</span>  Name.<span class="hljs-function"><span class="hljs-title">get_user_phone</span><span class="hljs-params">(#user&#123;phone=Phone&#125;)</span> -&gt;</span>  Phone.</code></pre><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erl</span>Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V8.3  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> c(records).   %% 这是编译 erlang 代码的另外一种办法。c/1 编译并加载 module。</span>&#123;ok,records&#125;<span class="hljs-meta">2&gt;</span><span class="bash"> rr(records).  %% 将 records module 中的所有 record 都加载到 erl shell 里。</span>[user]<span class="hljs-meta">4&gt;</span><span class="bash"> Shawn = <span class="hljs-comment">#user&#123;name = &lt;&lt;&quot;Shawn&quot;&gt;&gt;, phone = &lt;&lt;&quot;18253232321&quot;&gt;&gt;&#125;.</span></span><span class="hljs-meta">#</span><span class="bash">user&#123;name = &lt;&lt;<span class="hljs-string">&quot;Shawn&quot;</span>&gt;&gt;,phone = &lt;&lt;<span class="hljs-string">&quot;18253232321&quot;</span>&gt;&gt;&#125;</span><span class="hljs-meta">5&gt;</span><span class="bash"> records:get_user_phone(Shawn).</span>&lt;&lt;&quot;18253232321&quot;&gt;&gt;<span class="hljs-meta">6&gt;</span><span class="bash"> records:get_user_name(Shawn).</span>&lt;&lt;&quot;Shawn&quot;&gt;&gt;<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% record 其实就是个 tagged tuple, 第一个元素是 record 名字。</span><span class="hljs-meta">7&gt;</span><span class="bash"> records:get_user_name(&#123;user, &lt;&lt;<span class="hljs-string">&quot;Shawn&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;18253232321&quot;</span>&gt;&gt;&#125;).</span>&lt;&lt;&quot;Shawn&quot;&gt;&gt;<span class="hljs-meta"></span><span class="hljs-meta">9&gt;</span><span class="bash"> Shawn<span class="hljs-comment">#user.name.</span></span>&lt;&lt;&quot;Shawn&quot;&gt;&gt;<span class="hljs-meta">10&gt;</span><span class="bash"> <span class="hljs-comment">#user.name.</span></span>2</code></pre><p>你看到 <code>#user&#123;&#125;</code> 其实只是一个第一个元素为 <code>user</code> 的 tagged tuple <code>&#123;user, name, phone&#125;</code>, 而 #user.name 是这个 tuple 里 <code>name</code> 字段的位置号 2。<br><code>注意: Erlang 里面的位置、Index 等都是约定从 1 开始的。</code></p><p> Shawn#user.name 的意思是取 Shawn 里的第 2 个元素。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Erlang 是函数式语言，变量 immutable 的，所以没有 while loop。因为不能让你定义一个递增的 counter 变量。<br>所以我们用递归来解决大多数问题。<br>先来一个计算 List 长度的函数：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([])</span> -&gt;</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">%% 空列表的长度是 0</span><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([_|T])</span> -&gt;</span> <span class="hljs-number">1</span> + len(T)   <span class="hljs-comment">%% 列表的长度，是 1 + 剩余列表的长度。</span></code></pre><p>简单吧？但是你知道的，这样子如果要计算的 List 长度太长的话，调用栈就特别长，会吃尽内存。计算过程是这样的:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])</span> = <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">1</span> | [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])</span></span><span class="hljs-function">               = 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">2</span> | [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])</span></span><span class="hljs-function">               = 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">3</span> | [<span class="hljs-number">4</span>]])</span></span><span class="hljs-function">               = 1 + 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([<span class="hljs-number">4</span> | []])</span></span><span class="hljs-function">               = 1 + 1 + 1 + 1 + <span class="hljs-title">len</span><span class="hljs-params">([])</span></span><span class="hljs-function">               = 1 + 1 + 1 + 1 + 0</span><span class="hljs-function">               = 1 + 1 + 1 + 1</span><span class="hljs-function">               = 1 + 1 + 2</span><span class="hljs-function">               = 1 + 3 </span><span class="hljs-function">               = 4</span></code></pre><p>所以我们必须用 <code>Tail Recursion</code> (尾递归) 来改写一下:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">(L)</span> -&gt;</span> len(L,<span class="hljs-number">0</span>).   <span class="hljs-comment">%% 这其实只是给 len/2 的第二个参数设置了一个默认值 0.</span> <span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([], Acc)</span> -&gt;</span> Acc;  <span class="hljs-comment">%% 所有的元素都读完了</span><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">([_|T], Acc)</span> -&gt;</span> len(T,Acc+<span class="hljs-number">1</span>).  <span class="hljs-comment">%% 读一个元素，Acc 增1，然后计算剩下的 List 的长度。</span></code></pre><p>尾递归就是，最后一个语句是调用自身的那种递归。Erlang 遇到这总递归的时候，不会再保留调用栈。这样的递归相当于一个 while loop。</p><p>我们用 Acc 来记录每次计算的结果，读取一个元素 Acc 就增 1，一直到读取完所有的元素。</p><p>第一个例子里，第二个 clause 的最后一个调用是 <code>1 + len(T)</code> ，这不是尾递归。因为系统还要保留着调用栈，等其算出 len(T) 之后，再回来跟 1 做加法运算。只有 <code>len(T,Acc+1).</code> 这种才是。</p><p><strong>尾递归与递归的区别：</strong><br>有个比喻可以帮你理解他们的差异。<br>假设玩一个游戏，你需要去收集散落了一路，并通向远方的硬币。</p><p>于是你一个一个的捡，一边捡一边往前走，但是你必须往地上撒些纸条做记号，因为不做记号你就忘了回来的路。于是你一路走，一路捡，一路撒纸条。等你捡到最后一个硬币时，你开始沿着记号回来了，一路走，一路捡纸条(保护环境)。等回到出发点时，你把硬币装你包里，把纸条扔进垃圾桶。<br>这就是<strong>非尾递归</strong>，纸条就是你的调用栈，是内存记录。</p><p>下次再玩这个游戏时，你学聪明了，你直接背着包过去了，一路走，一路捡，一路往包里塞。等到了终点时，最后一个硬币进包了，任务完成了，你不回来了！<br>这就是<strong>尾递归</strong>，省去了调用栈的消耗。</p><p><strong>书接下文</strong>：<a href="https://www.jianshu.com/p/5b7e73576dcb">30 分钟学 Erlang (二)</a></p>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟学Erlang (一)</title>
    <link href="/2021/01/16/clpqt1iu800264cue8xx6dpnv.html"/>
    <url>/2021/01/16/clpqt1iu800264cue8xx6dpnv.html</url>
    
    <content type="html"><![CDATA[<p>作者：Shawn # 概要：使用 erlang:spawn/1,2,3,4 用来创建一个 erlang 进程。Erlang 进程不是操作系统的进程，而是类似其他语言里“协程”的概念，它由 Erlang 虚拟机调度。本文以后说“进程”，就是指 Erlang 进程。</p><span id="more"></span><blockquote><p>本文来自我的同事Shawn大佬的总结，Shawn大佬是目前国内Erlang领域内的权威开发架构师，30分钟学erlang系列文章是Shawn的一线经验，对于新入门的朋友很有帮助。再次感谢Shawn花时间整理博客，和贡献文档供社区学习。</p></blockquote><h1 id="30分钟学Erlang-二"><a href="#30分钟学Erlang-二" class="headerlink" title="30分钟学Erlang (二)"></a>30分钟学Erlang (二)</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h5 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h5><p>使用 erlang:spawn/1,2,3,4 用来创建一个 erlang 进程。Erlang 进程不是操作系统的进程，而是类似其他语言里“协程”的概念，它由 Erlang 虚拟机调度。本文以后说“进程”，就是指 Erlang 进程。</p><p>进程之间是互相独立的，一个进程要想与另外一个进程通信，就必须通过消息传递。消息会被发送到对方进程的信箱存储起来，对方进程可以在合适的时间，按照自定的顺序读取信箱里的消息。</p><p>Erlang 里进程非常轻量，启动速度很快，并且可以同时运行千千万万个，默认的进程个数上限是 262144 ，但可以在启动时使用 erl +P 修改这个配置。</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> HelloParallel = fun() -&gt; io:format(<span class="hljs-string">&quot;hello parallel!~n&quot;</span>) end.</span><span class="hljs-meta">#</span><span class="bash">Fun&lt;erl_eval.20.99386804&gt;</span><span class="hljs-meta">2&gt;</span><span class="bash"> spawn(HelloParallel).  %% spawn/1 BIF 接受一个函数做为参数。</span>hello parallel!&lt;0.63.0&gt;<span class="hljs-meta">3&gt;</span><span class="bash"> PID = pid(0,63,0).   %% 使用 pid 来生成一个 PID</span><span class="hljs-meta">4&gt;</span><span class="bash"> is_pid(PID).  %% 检查是否是 PID 类型</span>true<span class="hljs-meta">5&gt;</span><span class="bash"> is_process_alive(PID). %%  检查 Process 是否还活着。显示 <span class="hljs-literal">false</span> 是因为它已经运行完成终止了。</span>false</code></pre><p>spawn 函数返回一个新进程的 pid，我们可以使用这个 pid 与其交互。</p><p>erlang shell 也是有 pid 的。前面说到一个运行时错误会使得当前的shell 进程崩溃，并重新启动一个新的进程，我们验证一下：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> self().   %% self/1 返回当前进程的 pid</span>&lt;0.60.0&gt;<span class="hljs-meta">2&gt;</span><span class="bash"> 1 = 2.</span>** exception error: no match of right hand side value 2<span class="hljs-meta">3&gt;</span><span class="bash"> self().</span>&lt;0.63.0&gt;</code></pre><h4 id="消息发送和接收"><a href="#消息发送和接收" class="headerlink" title="消息发送和接收"></a>消息发送和接收</h4><p>使用消息发送运算符 <code>!</code> 发送消息。</p><pre><code class="hljs shell"><span class="hljs-meta">4&gt;</span><span class="bash"> self() ! <span class="hljs-string">&quot;hello&quot;</span>.    %% 向自己所在的进程发送一个 List 类型的 <span class="hljs-string">&quot;hello&quot;</span>. `!` 操作的返回值是消息内容, <span class="hljs-string">&quot;hello&quot;</span>.</span>&quot;hello&quot;<span class="hljs-meta">5&gt;</span><span class="bash"> flush().  %% flush() 将当前 process 的信箱里的所有消息清空并打印。</span>Shell got &quot;hello&quot;ok</code></pre><p>receive … end 语句使用 pattern matching 来从自己进程的信箱里读取消息，可以使用 after 语句来设置等待超时时间：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> self() ! <span class="hljs-string">&quot;msg1&quot;</span>.</span>&quot;msg1&quot;<span class="hljs-meta">2&gt;</span><span class="bash"> self() ! <span class="hljs-string">&quot;msg2&quot;</span>.</span>&quot;msg2&quot;<span class="hljs-meta">3&gt;</span><span class="bash"> self() ! <span class="hljs-string">&quot;msg3&quot;</span>.</span>&quot;msg3&quot;<span class="hljs-meta">4&gt;</span><span class="bash"> receive Msg -&gt; Msg after 3000 -&gt; no_more end. %% 读取任意消息并返回这条消息，如果信箱里没有消息了，等待 3 秒后结束并返回 no_more.</span>&quot;msg1&quot;<span class="hljs-meta">5&gt;</span><span class="bash"> receive Msg -&gt; Msg after 3000 -&gt; no_more end.  %% 后面这两条为什么返回 no_more ? 不应该是 <span class="hljs-string">&quot;msg2&quot;</span>, <span class="hljs-string">&quot;msg3&quot;</span> 吗？</span>no_more<span class="hljs-meta">6&gt;</span><span class="bash"> receive Msg -&gt; Msg after 3000 -&gt; no_more end.</span>no_more</code></pre><p>上面的第 4 行 <code>receive</code> 语句里，erlang shell 进程查看邮箱，查到第一个消息是 “msg1”, Msg 被绑定为 “msg1”。再次运行 receive 语句的时候，由于 Msg 的值已经为 “msg1”，与信箱里的 “msg2”, “msg3” 都不匹配，所以后面两条 <code>receive</code> 语句都没有从信箱里读取新消息，”msg2” 和 “msg3” 仍然存储在信箱里:</p><pre><code class="hljs shell"><span class="hljs-meta">16&gt;</span><span class="bash"> flush().</span>Shell got &quot;msg2&quot;Shell got &quot;msg3&quot;ok</code></pre><p>注意虽然后面两个 <code>receive</code> 语句都没有从信箱里读取消息，但在 receive 语句的执行过程中，它仍然是从头到尾遍历了整个邮箱，并尝试拿邮箱里的各个消息跟代码里的 <code>Msg</code> 进行匹配，这是消耗资源的，等后面消息堆积越多越麻烦。这个叫 <code>Selective Message Reception</code>. 消息的读取顺序是接收方决定的。</p><p>所以一般情况下我们在读取信箱消息时，读到我们不感兴趣的消息也取出来，打个 error log 然后扔掉它，不要让它一直在信箱里耗费资源。</p><p>在 Erlang shell 已经伸展不开拳脚了。让我们来写个复杂点的程序：<br>我们的程序实现一个 <strong>消息缓存</strong>，具体需求是：</p><ul><li>我们需要一个消息栈，用于存储用户发来的消息。</li><li>考虑到用户发来的消息可能有很多，我们需要好几个这样的消息栈来分担负载。</li><li>我们还想能够给消息栈命名，以便区分。</li></ul><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(msg_cache)</span>.<span class="hljs-comment">%% APIs</span><span class="hljs-keyword">-export</span><span class="hljs-params">([start_one/<span class="hljs-number">1</span>])</span>.<span class="hljs-comment">%% for spawns</span><span class="hljs-keyword">-export</span><span class="hljs-params">([loop/<span class="hljs-number">1</span>])</span>.<span class="hljs-comment">%% 定义进程的 state。</span><span class="hljs-comment">%% 我们一般说，一个服务、或 “对象” 会维护自己内部的 &#x27;状态&#x27;</span><span class="hljs-comment">%% 状态可能是一个字符串缓存，可能是某个资源的引用，这个跟业务相关。</span><span class="hljs-comment">%% 状态存在于内存中，跟外界隔离，通过 API 接口与外界交互。</span><span class="hljs-comment">%% 面向对象语言里用 类和对象来存储状态，Erlang 里我们用 process。</span><span class="hljs-comment">%% 所以我们又说 Erlang 是 “面向Process 编程的”</span><span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;</span><span class="hljs-params">            name,      <span class="hljs-comment">%% 消息栈的名字</span></span><span class="hljs-params">            length = <span class="hljs-number">0</span>,  <span class="hljs-comment">%% 消息栈长度</span></span><span class="hljs-params">            buff = []   <span class="hljs-comment">%% 消息栈的存储列表</span></span><span class="hljs-params">         &#125;)</span>.<span class="hljs-function"><span class="hljs-title">loop</span><span class="hljs-params">(State = #state&#123;name = Name, length = Len, buff = Buff&#125;)</span> -&gt;</span>  <span class="hljs-keyword">receive</span>    &#123;get_name, From&#125;-&gt;      From ! &#123;ok, Name&#125;,      loop(State);    &#123;get_length, From&#125;-&gt;      From ! &#123;ok, Len&#125;,      loop(State);    &#123;set_name, NewName, From&#125; -&gt;      From ! ok,      loop(State#state&#123;name = NewName&#125;);    &#123;push, Msg, From&#125; -&gt;      From ! ok,      loop(State#state&#123;buff = [Msg | Buff], length = Len + <span class="hljs-number">1</span>&#125;);    &#123;pop, [], From&#125; -&gt;      From ! &#123;error, empty&#125;,      loop(State);    &#123;pop, [TopMsg | Msgs], From&#125; -&gt;      From ! &#123;ok, TopMsg&#125;,      loop(State#state&#123;buff = Msgs, length = Len - <span class="hljs-number">1</span>&#125;);    _Unsupported -&gt;      erlang:error(io_libs:format(<span class="hljs-string">&quot;unsupported msg: &quot;</span>, [_Unsupported]) )  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">start_one</span><span class="hljs-params">(BuffName)</span> -&gt;</span>  <span class="hljs-comment">%% 启动一个消息栈，并返回其 PID</span>  Pid = spawn(msg_cache, loop, [#state&#123;name=BuffName&#125;]),  io:format(<span class="hljs-string">&quot;Buff ~s created! Pid = ~p~n&quot;</span>, [BuffName, Pid]),  Pid</code></pre><p>其实除了 loop/1 长一点，其他的都挺容易理解的。<br>注意 loop/1 里的每个分支的最后一个语句都是尾递归，意味着只要不出错，loop/1 就一直循环下去，所以进程就不会停止。</p><p><code>思考：如果把上面代码里 receive 语句的最后一个 _Unsupported -&gt; 分支删掉的话，会发生什么？</code></p><p>receive 语句里，接受消息时，都要求消息发送方将自己的 Pid 带过来，放到 <code>From</code> 变量里，以便我们回复消息给对方。</p><p>我们来试试：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> PID = msg_cache:start_one(<span class="hljs-string">&quot;cache2&quot;</span>).</span>Buff cache2 created! Pid = &lt;0.62.0&gt;&lt;0.62.0&gt;<span class="hljs-meta">2&gt;</span><span class="bash"> PID ! &#123;get_length, self()&#125;.</span>&#123;get_length,&lt;0.60.0&gt;&#125;<span class="hljs-meta">3&gt;</span><span class="bash"> flush().</span>Shell got &#123;ok,0&#125;ok<span class="hljs-meta"></span><span class="hljs-meta">4&gt;</span><span class="bash"> PID ! &#123;pop, self()&#125;.</span>&#123;pop,&lt;0.60.0&gt;&#125;<span class="hljs-meta">5&gt;</span><span class="bash"> flush().</span>Shell got &#123;error,empty&#125;ok<span class="hljs-meta"></span><span class="hljs-meta">6&gt;</span><span class="bash"> PID ! &#123;push, <span class="hljs-string">&quot;msg1&quot;</span>, self()&#125;.</span>&#123;push,&quot;msg1&quot;,&lt;0.60.0&gt;&#125;<span class="hljs-meta">7&gt;</span><span class="bash"> PID ! &#123;push, <span class="hljs-string">&quot;msg2&quot;</span>, self()&#125;.</span>&#123;push,&quot;msg2&quot;,&lt;0.60.0&gt;&#125;<span class="hljs-meta">8&gt;</span><span class="bash"> PID ! &#123;push, <span class="hljs-string">&quot;msg3&quot;</span>, self()&#125;.</span>&#123;push,&quot;msg3&quot;,&lt;0.60.0&gt;&#125;<span class="hljs-meta">9&gt;</span><span class="bash"> PID ! &#123;get_length, self()&#125;.</span>&#123;get_length,&lt;0.60.0&gt;&#125;<span class="hljs-meta">10&gt;</span><span class="bash"> flush().</span>Shell got okShell got okShell got okShell got &#123;ok,3&#125;ok<span class="hljs-meta"></span><span class="hljs-meta">11&gt;</span><span class="bash"> PID ! &#123;pop, self()&#125;.</span>&#123;pop,&lt;0.60.0&gt;&#125;<span class="hljs-meta">12&gt;</span><span class="bash"> flush().</span>Shell got &#123;ok,&quot;msg3&quot;&#125;ok<span class="hljs-meta"></span><span class="hljs-meta">13&gt;</span><span class="bash"> PID ! &#123;get_length, self()&#125;.</span>&#123;get_length,&lt;0.60.0&gt;&#125;<span class="hljs-meta">14&gt;</span><span class="bash"> flush().</span>Shell got &#123;ok,2&#125;ok</code></pre><p><strong>继续往下阅读之前，仔细看一下这个例子，确保你完全理解了这段代码。</strong></p><p>挺厉害的吧？但我们还有两个问题没有解决：</p><ul><li>没有一个易用易维护的 API。 PID ! {get_length, self()}. 这种调用方式实在有些反人类。</li><li>没有管理进程。我们调用一次 msg_cache:start_one/1 就启动了一个msg_cache, 但是现在我不知道当前已经启动了几个 msg_cache.</li></ul><p>我们来解决这第一个问题，重新整理一下代码：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(msg_cache)</span>.<span class="hljs-comment">%% APIs</span><span class="hljs-keyword">-export</span><span class="hljs-params">([start_one/<span class="hljs-number">1</span>,</span><span class="hljs-params">         get_name/<span class="hljs-number">1</span>,</span><span class="hljs-params">         get_length/<span class="hljs-number">1</span>,</span><span class="hljs-params">         pop/<span class="hljs-number">1</span>,</span><span class="hljs-params">         set_name/<span class="hljs-number">2</span>,</span><span class="hljs-params">         push/<span class="hljs-number">2</span></span><span class="hljs-params">        ])</span>.<span class="hljs-comment">%% for spawns</span><span class="hljs-keyword">-export</span><span class="hljs-params">([loop/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-define</span><span class="hljs-params">(API_TIMEOUT, <span class="hljs-number">3000</span>)</span>.<span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;</span><span class="hljs-params">            name,</span><span class="hljs-params">            length = <span class="hljs-number">0</span>,</span><span class="hljs-params">            buff = []</span><span class="hljs-params">         &#125;)</span>.<span class="hljs-function"><span class="hljs-title">start_one</span><span class="hljs-params">(BuffName)</span> -&gt;</span>  Pid = spawn(msg_cache, loop, [#state&#123;name=BuffName&#125;]),  io:format(<span class="hljs-string">&quot;Buff ~s created! Pid = ~p~n&quot;</span>, [BuffName, Pid]),  Pid.<span class="hljs-comment">%% 加了这几个 API</span><span class="hljs-function"><span class="hljs-title">get_name</span><span class="hljs-params">(CacheID)</span> -&gt;</span>  call(CacheID, &#123;get_name, self()&#125;).<span class="hljs-function"><span class="hljs-title">get_length</span><span class="hljs-params">(CacheID)</span> -&gt;</span>  call(CacheID, &#123;get_length, self()&#125;).<span class="hljs-function"><span class="hljs-title">set_name</span><span class="hljs-params">(CacheID, NewName)</span> -&gt;</span>  call(CacheID, &#123;set_name, NewName, self()&#125;).<span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">(CacheID)</span> -&gt;</span>  call(CacheID, &#123;pop, self()&#125;).<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(CacheID, Msg)</span> -&gt;</span>  call(CacheID, &#123;push, Msg, self()&#125;).<span class="hljs-comment">%% 由于发送和接受消息的处理方面，各个 API 都差不多，就提取出来专门写个 call 函数，提高代码复用。</span><span class="hljs-function"><span class="hljs-title">call</span><span class="hljs-params">(Pid, Request)</span> -&gt;</span>  Pid ! Request,  <span class="hljs-keyword">receive</span>    Response -&gt; Response  <span class="hljs-keyword">after</span> ?API_TIMEOUT -&gt;    &#123;error, api_timeout&#125;  <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% loop 这一部分我们没改动任何代码</span><span class="hljs-function"><span class="hljs-title">loop</span><span class="hljs-params">(State = #state&#123;name = Name, length = Len, buff = Buff&#125;)</span> -&gt;</span>  <span class="hljs-keyword">receive</span>    &#123;get_name, From&#125;-&gt;      From ! &#123;ok, Name&#125;,      loop(State);    &#123;get_length, From&#125;-&gt;      From ! &#123;ok, Len&#125;,      loop(State);    &#123;set_name, NewName, From&#125; -&gt;      From ! ok,      loop(State#state&#123;name = NewName&#125;);    &#123;push, Msg, From&#125; -&gt;      From ! ok,      loop(State#state&#123;buff = [Msg | Buff], length = Len + <span class="hljs-number">1</span>&#125;);    &#123;pop, From&#125; -&gt;      <span class="hljs-keyword">case</span> Buff <span class="hljs-keyword">of</span>        [] -&gt;          From ! &#123;error, empty&#125;,          loop(State);        [TopMsg | Msgs] -&gt;          From ! &#123;ok, TopMsg&#125;,          loop(State#state&#123;buff = Msgs, length = Len - <span class="hljs-number">1</span>&#125;)      <span class="hljs-keyword">end</span>;    _Unsupported -&gt;      erlang:error(io_libs:format(<span class="hljs-string">&quot;unsupported msg: &quot;</span>, [_Unsupported]) )  <span class="hljs-keyword">end</span>.</code></pre><p>再试一下：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> PID = msg_cache:start_one(<span class="hljs-string">&quot;cache_worker_1&quot;</span>).</span>Buff cache_worker_1 created! Pid = &lt;0.62.0&gt;&lt;0.62.0&gt;<span class="hljs-meta">2&gt;</span><span class="bash"> msg_cache:get_name(PID).</span>&#123;ok,&quot;cache_worker_1&quot;&#125;<span class="hljs-meta">3&gt;</span><span class="bash"> msg_cache:get_length(PID).</span>&#123;ok,0&#125;<span class="hljs-meta">4&gt;</span><span class="bash"> msg_cache:pop(PID).</span>&#123;error,empty&#125;<span class="hljs-meta">5&gt;</span><span class="bash"> msg_cache:push(PID, <span class="hljs-string">&quot;msg1&quot;</span>).</span>ok<span class="hljs-meta">6&gt;</span><span class="bash"> msg_cache:push(PID, <span class="hljs-string">&quot;msg2&quot;</span>).</span>ok<span class="hljs-meta">7&gt;</span><span class="bash"> msg_cache:get_length(PID).</span>&#123;ok,2&#125;<span class="hljs-meta">8&gt;</span><span class="bash"> msg_cache:pop(PID).</span>&#123;ok,&quot;msg2&quot;&#125;<span class="hljs-meta">9&gt;</span><span class="bash"> msg_cache:pop(PID).</span>&#123;ok,&quot;msg1&quot;&#125;<span class="hljs-meta">10&gt;</span><span class="bash"> msg_cache:pop(PID).</span>&#123;error,empty&#125;<span class="hljs-meta">11&gt;</span><span class="bash"> msg_cache:get_length(PID).</span>&#123;ok,0&#125;</code></pre><p>还阔以吧？</p><h5 id="留个作业"><a href="#留个作业" class="headerlink" title="留个作业"></a>留个作业</h5><p>上面那个 “管理进程” 我们没有实现。你来实现它。</p><p>我想这么调用：</p><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">% 启动两个 worker：</span><span class="hljs-meta">1&gt;</span><span class="bash"> msg_cache:start_cache_workers([<span class="hljs-string">&quot;c_worker_1&quot;</span>, <span class="hljs-string">&quot;c_worker_2&quot;</span>]).</span>[&lt;0.62.0&gt;, &lt;0.65.0&gt;]<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 列出所有 workers, 返回值是个 worker 列表, 元素展示了每个 worker 的 name, pid, 和 length 。</span><span class="hljs-meta">2&gt;</span><span class="bash"> CachePidList = msg_cache:list_cache_workers().</span>[&#123;&quot;c_worker_1&quot;, &lt;0.62.0&gt;, 0&#125;, &#123;&quot;c_worker_2&quot;, &lt;0.65.0&gt;, 0&#125;]<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 负载均衡, 会往随机的一个 cache worker 里 push.</span><span class="hljs-meta">%</span><span class="bash">% 注意我这里调用 msg_cache:push 的时候，没有提供某个 cache worker 的 PID</span><span class="hljs-meta">3&gt;</span><span class="bash"> ok = msg_cache:push(<span class="hljs-string">&quot;msg1&quot;</span>).</span>ok<span class="hljs-meta">4&gt;</span><span class="bash"> ok = msg_cache:push(<span class="hljs-string">&quot;msg2&quot;</span>).</span>ok<span class="hljs-meta">5&gt;</span><span class="bash"> CachePidList = msg_cache:list_cache_workers().</span>[&#123;&quot;c_worker_1&quot;, &lt;0.62.0&gt;, 1&#125;, &#123;&quot;c_worker_2&quot;, &lt;0.65.0&gt;, 1&#125;]<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 至于 pop 不用管顺序了，有消息就随便 pop 出一个来。</span><span class="hljs-meta">4&gt;</span><span class="bash"> msg_cache:pop().</span>&#123;ok, &quot;msg1&quot;&#125;</code></pre><p>提示：</p><ul><li><a href="http://erldocs.com/18.0/erts/erlang.html#register/2" title="here be a title. Enjoy">erlang:register/2</a> 可以给一个 PID 注册一个名字，以后使用这个 PID 就可以使用这个名字代替。比如<pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">register</span><span class="hljs-params">(msg_cache_manger, Pid)</span>.</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">msg_cache</span>:<span class="hljs-title">list_cache_workers</span><span class="hljs-params">()</span> -&gt;</span>  msg_cache_manger ! get_all_workers.</code></pre></li></ul><h5 id="课后必读文章"><a href="#课后必读文章" class="headerlink" title="课后必读文章"></a>课后必读文章</h5><p>Erlang 中的错误处理机制, Link、Monitor:<br><a href="http://learnyousomeerlang.com/errors-and-processes">Errors and Processes</a></p><h1 id="ETS"><a href="#ETS" class="headerlink" title="ETS"></a>ETS</h1><p>ETS (Erlang Term Storage) 是设计来存放大量的 Erlang 数据的。跟 ETS 打交道不用消息格式转换，可直接存放 Erlang 数据格式 (erlang 各种数据格式的统称叫做 erlang terms)。<br>ETS 非常快，访问时间是常数级的，自动帮你解决了多进程访问的各种竞态条件问题，让我们在 Erlang 中做并发编程一身轻松。ETS 是非常优秀的缓存系统，是我们开发中不可或缺的利器之一。这比起用某种流行语言来说，舒服太多<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Golang 里你需要自己找多线程安全的 maps 库，写并发没有安全感。Golang 官方也没有下文要说到的 OTP 里提供的各种 Behavior，代码写起来天马行空最后一团糟。然后又不能支持函数式的 pattern matching 等写法… 总之用 golang 写代码从来不会给人愉快的感觉。流行是流行的，但那叫“普通”吧？第一次这么吐槽 golang，但这篇是 erlang 的教程，应该不算过分吧。等到写 go 的时候我再来吐槽 erlang 。我是不会写 go 的 …">[1]</span></a></sup>。<br>ETS 只将数据存储在内存里，如果想保存到磁盘，或者要在多个 Erlang Node 之间共享数据，OTP 基于 ETS 和 DETS 实现了 <a href="http://learnyousomeerlang.com/mnesia">mnesia</a>.<br><code>NODE: mnesia 只适合用来做缓存，在多个 Node 之间共享少量数据，非常快速。但是并不适合当做数据库存储大量的数据，因为 mnesia 在启动时会加载所有数据到内存里，导致启动缓慢、新节点加入缓慢。并且 mnesia 是强一致性的数据库，其本身并不处理由于集群脑裂导致的不一致性，这可能不太符合你的预期。</code></p><p>ETS 支持几种数据类型：</p><ul><li>set: set 是普通的 key - value 存储类型，一个 ETS table 里，两个数据的 key 不能相同。重复插入 key 相同的两条数据，后面的那条会覆盖前面的那条。</li><li>ordered_set: 有序的 set 表。</li><li>bag: bag 允许多个 key 相同的数据的存在，但 key, value 都完全相同的数据只能留一个。</li><li>duplicate_bag: 允许多个 key, value 完全相同的数据的存在。</li></ul><p>我们来试试 set 类型的 table，这也是最常用的类型。我们创建一个命名表，叫 <code>users</code>, 然后插入两条数据：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> ets:new(users, [<span class="hljs-built_in">set</span>, named_table]).</span>users<span class="hljs-meta">2&gt;</span><span class="bash"> ets:info(users).   %% 注意默认的权限是 protected</span>[&#123;read_concurrency,false&#125;, &#123;write_concurrency,false&#125;, &#123;compressed,false&#125;, &#123;memory,304&#125;, &#123;owner,&lt;0.57.0&gt;&#125;, &#123;heir,none&#125;, &#123;name,users&#125;, &#123;size,0&#125;, &#123;node,nonode@nohost&#125;, &#123;named_table,true&#125;, &#123;type,set&#125;, &#123;keypos,1&#125;, &#123;protection,protected&#125;]<span class="hljs-meta">3&gt;</span><span class="bash"> ets:insert(users, &#123;1, &lt;&lt;<span class="hljs-string">&quot;Shawn&quot;</span>&gt;&gt;, 27&#125;).</span>true<span class="hljs-meta">4&gt;</span><span class="bash"> ets:insert(users, &#123;2, &lt;&lt;<span class="hljs-string">&quot;Scarlett&quot;</span>&gt;&gt;, 25&#125;).</span>true<span class="hljs-meta">5&gt;</span><span class="bash"> ets:lookup(users, 1).</span>[&#123;1,&lt;&lt;&quot;Shawn&quot;&gt;&gt;,27&#125;]<span class="hljs-meta">6&gt;</span><span class="bash"> ets:lookup(users, 2).</span>[&#123;2,&lt;&lt;&quot;Scarlett&quot;&gt;&gt;,25&#125;]<span class="hljs-meta">7&gt;</span><span class="bash"> ets:info(users).</span>[&#123;read_concurrency,false&#125;, &#123;write_concurrency,false&#125;, &#123;compressed,false&#125;, &#123;memory,332&#125;, &#123;owner,&lt;0.57.0&gt;&#125;, &#123;heir,none&#125;, &#123;name,users&#125;, &#123;size,2&#125;, &#123;node,nonode@nohost&#125;, &#123;named_table,true&#125;, &#123;type,set&#125;, &#123;keypos,1&#125;, &#123;protection,protected&#125;]<span class="hljs-meta">8&gt;</span></code></pre><p>注意上边的示例里：</p><ul><li>创建 ETS table 时给了两个 Options 参数：[set, named_table]。set 是指定创建 set 类型的表，named_table 是创建命名表，命名为 <code>users</code>，后面可以用这个表名来引用。</li><li>插入数据 <code>&#123;1, &lt;&lt;&quot;Shawn&quot;&gt;&gt;, 27&#125;</code> 和 <code>&#123;2, &lt;&lt;&quot;Scarlett&quot;&gt;&gt;, 25&#125;</code> 时，两个 tuple 的第一项就是默认的 key，tuple 里其他项都是 values。如果你想用其他的项作为 key，可以在  ets:new 的时候，指定 <code>&#123;keypos, Pos&#125;</code> 参数，设置 key 在 tuple 中的位置。</li></ul><p>ETS 表的其他类型你可以自己试验一下。</p><p><strong>需要注意的是：</strong></p><ul><li>ETS 表里的任何数据都不参加 GC</li><li>ETS 表有自己的 <code>owner</code> 进程，默认情况下，创建表的那个进程就是 ETS table 的 owner。如果 owner 进程挂了，ETS 表也就被释放了。我们上边的例子里，erlang shell 进程就是 <code>user</code> table 的 owner。</li><li>ETS 表也是有访问权限的，默认是 <code>protected</code>:<ul><li>public：任何人可以读写这张表。</li><li>protected: owner 可以读写，但其他进程只能读。</li><li>private：只有 owner 可以读写。别的进程无法访问。</li></ul></li></ul><p>由于 ETS 表非常高效，一般情况下我们都直接使用 <code>public</code>，然后设置 <code>&#123;read_concurrency, true&#125;</code> 或 <code>&#123;write_concurrency,true&#125;</code> 选项来提高并发读或写的效率，在写一个管理模块来直接访问 ets 表，让什么封装什么设计模式都去 shi。</p><h1 id="OTP"><a href="#OTP" class="headerlink" title="OTP"></a>OTP</h1><p>OTP 已经失去了字面意思，基本上指的就是 Erlang 生态环境的官方部分。Erlang 世界的组成是这样的：</p><ul><li>Erlang 以及 Elixir 等语言。</li><li>工具和函数库，包括 erlang runtime，kernel，stdlib(像 lists 这种的官方库), sasl, 还有像 ETS，dbg 之类的很多。</li><li>系统设计原则, 包括本章要讲的一众 Behaviors。是一堆应用于并发世界的设计模式，他们包含了解决通用问题的通用代码。</li><li>开源社区生态环境，包括各种开源软件和社区。</li></ul><p>OTP 指的是前三个，Elixir 的话还不大算。</p><p>Erlang 的逻辑是，架构的设计应该由有经验的人负责，由专家做好基础代码框架，解决好最困难的问题。而使用者只需要写自己的逻辑代码。这就是 OTP behaviors，他们已经在通信、互联网领域，经历了几十年的战火考验。</p><p>本文要讲的有三个：</p><ul><li>gen_server</li><li>application</li><li>supervisor</li></ul><p>本章只讲解 gen_server。 application 和 supervisor 放到后面 Hello World 工程里讲解。</p><p><strong>gen_server</strong> 要解决的问题，就是我们上面那个 msg_cache 面临的问题：怎样做一个服务来响应用户的请求。</p><p>我们之前写的代码很短，可以工作，但是很多东西都没有考虑。比如请求者如果同时收到来自服务端的两个 Response 的话，不知道是对应哪个请求的：</p><pre><code class="hljs erlang"><span class="hljs-comment">%% 服务端：</span>    &#123;get_name, From&#125;-&gt;      From ! &#123;ok, Name&#125;,      loop(State);    &#123;get_length, From&#125;-&gt;      From ! &#123;ok, Len&#125;,      loop(State);<span class="hljs-comment">%% 客户端：</span>    ServerPID ! &#123;get_length, self()&#125;,   <span class="hljs-comment">%% 客户端连续调用了两次</span>    ServerPID ! &#123;get_length, self()&#125;,      <span class="hljs-keyword">receive</span>      &#123;ok, Len&#125; -&gt;  <span class="hljs-comment">%% 你知道这次匹配到的消息，是上面哪次调用的回复吗？</span>         success;      _ -&gt;         failed    <span class="hljs-keyword">end</span>.</code></pre><p>上面代码里连续调用了两次 {get_length}, 但是由于发送消息是异步的，消息通过网络回来，你并不能确定第一次收到的回复就是第一次调用产生的。</p><p>这个问题可以加一个随机生成的 RequestID 的字段来解决，客户端发送请求消息的时候带 RequestID 过去，服务端返回的时候再传回来。客户端通过匹配 RequestID，就能知道当前的回复是对应的哪个请求。</p><p>但这种需求其实是通用的，你现在写 msg_cache 用得到，改天写其他代码也一样用得到。另外我们也没有过多考虑异常的情况：如果程序崩溃了怎么办？发送消息怎么知道对方是不是还活着？</p><p>诸如此类的问题应该由专家来解决，所以我们有了 <code>gen_server</code>.<br>gen_server 的模板是这样的：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(gen_server_demo)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(gen_server)</span>.<span class="hljs-comment">%% API functions</span><span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">0</span>])</span>.<span class="hljs-comment">%% gen_server callbacks</span><span class="hljs-keyword">-export</span><span class="hljs-params">([init/<span class="hljs-number">1</span>,</span><span class="hljs-params">         handle_call/<span class="hljs-number">3</span>,</span><span class="hljs-params">         handle_cast/<span class="hljs-number">2</span>,</span><span class="hljs-params">         handle_info/<span class="hljs-number">2</span>,</span><span class="hljs-params">         terminate/<span class="hljs-number">2</span>,</span><span class="hljs-params">         code_change/<span class="hljs-number">3</span>])</span>.<span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;&#125;)</span>.<span class="hljs-comment">%%%% %%%% %%%% %%%% %%%% </span><span class="hljs-comment">%%%% 这是给客户端调用的接口部分</span><span class="hljs-comment">%%%% %%%% %%%% %%%% %%%% </span><span class="hljs-comment">%% 启动一个服务，后台会启动一个 erlang process, 并进入 loop 函数, 回想一下我们实现 msg_cache 时写的那个 loop/1.</span><span class="hljs-comment">%% 但是这个 loop 函数属于通用部分的代码，是由 OTP 官方实现的，所以代码不在这里，在 OTP 代码的 lib/stdlib/src/gen_server.erl 里。</span><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">()</span> -&gt;</span>    <span class="hljs-comment">%% gen_server:start_link 启动 process, 然后将 process 注册在当前</span>    <span class="hljs-comment">%% node 上，注册名字就是当前 Module 名：gen_server_demo</span>    gen_server:start_link(&#123;local, ?MODULE&#125;, ?MODULE, [], []).<span class="hljs-comment">%%%% %%%% %%%% %%%% %%%% </span><span class="hljs-comment">%%%% 这是 gen_server 发生某事件时的回调函数部分</span><span class="hljs-comment">%%%% %%%% %%%% %%%% %%%%</span><span class="hljs-comment">%% gen_server:start_link 被调用，服务启动时，回调 init/1</span><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([])</span> -&gt;</span>    &#123;ok, #state&#123;&#125;&#125;.<span class="hljs-comment">%% gen_server:call 被调用。gen_server:call 是“同步”调用，调用方可以设置一个超时时间。</span><span class="hljs-comment">%% 返回值里的 Reply 是返回给调用者的内容。</span><span class="hljs-function"><span class="hljs-title">handle_call</span><span class="hljs-params">(_Request, _From, State)</span> -&gt;</span>    Reply = ok,    &#123;reply, Reply, State&#125;.<span class="hljs-comment">%% gen_server:cast 被调用。gen_server:cast 是“异步”调用。</span><span class="hljs-comment">%% 调用者一般是想发一个消息给我们的 gen_server，然后继续做自己的事情，他不想收到来自 gen_server 的回复。</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(_Msg, State)</span> -&gt;</span>    &#123;noreply, State&#125;.<span class="hljs-comment">%% gen_server 进程收到一个普通 erlang 消息：一个不是通过 gen_server:call 和 gen_server:cast 发来的消息。</span><span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(_Info, State)</span> -&gt;</span>    &#123;noreply, State&#125;.<span class="hljs-comment">%% 上面的三个函数 handle_call, handle_cast, handle_info</span><span class="hljs-comment">%%   都可以返回一个 &#123;stop, Reason, State&#125;，这样的话 gen_server 会退出。</span><span class="hljs-comment">%%   但退出之前，可能会回调 terminate(_Reason, _State)。</span><span class="hljs-comment">%% gen_server 将要退出时，回调 terminate/2.</span><span class="hljs-comment">%% 注意</span><span class="hljs-comment">%% 1) 要想 terminate 在 gen_server 退出前被回调，gen_server 必须捕获退出信号：</span><span class="hljs-comment">%%    需要在 init 回调里，加这么一行：process_flag(trap_exit, true).</span><span class="hljs-comment">%% 2) 有几个特定的 Reason 被认为是正常退出：normal, shutdown, or &#123;shutdown,Term&#125;，</span><span class="hljs-comment">%%    其他的 Reason，sasl 是会报错打日志的。</span><span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _State)</span> -&gt;</span>    ok.<span class="hljs-function"><span class="hljs-title">code_change</span><span class="hljs-params">(_OldVsn, State, _Extra)</span> -&gt;</span>    &#123;ok, State&#125;.</code></pre><p>gen_server 真正的进程代码在 OTP 库里，运行 start_link()，gen_server 就在后台跑起来了。你需要实现的只是这个模板里的各个回调函数，将你的业务逻辑放到这些回调里。</p><p><strong>仔细看一下上面的 gen_server 模板和注释，确保你能完全理解。</strong></p><p>我不想重新实现之前的 msg_cache，一点都不酷。我们重新写个其他的，让你对 Erlang 程序的基本设计理念有更深的印象。</p><p>我们要实现一个多用户聊天的程序：</p><ul><li>用户能够查询在线的其他用户。</li><li>用户之间能够聊天。</li><li>要容易扩展，因为后面我们的 Client 会通过TCP、WebSocket 等连接上来，不会是 Erlang 写的 Client。</li><li>要容易伸缩，因为我们业务发展很快，用户量会越来越大，我们希望程序能很容易的部署在多台服务器上。</li></ul><p>先来设计我们程序的架构：<br><img src="https://upload-images.jianshu.io/upload_images/2997299-7100392cb582c4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="chat_server-2.png"></p><ul><li>每个 client 连接上来，都会启动一个新的 Process，叫做 ChatServer.</li><li>ChatServer 负责维护这个 Client 的 TCP 连接。</li><li>Route 是一个Module，它提供了数据库的管理，数据库里维护了从 User 到其 ChatServer 的 PID 的映射关系。</li></ul><p>注意我们的设计思想：</p><ul><li>为每一个连接上来的请求启动一个 Erlang 进程 “ChatServer”，不要担心进程个数，百万也没问题。</li><li>两个用户之间的消息传递，体现在服务端就是两个 “ChatServer” 之间的 Erlang 消息传递。</li><li>Route 部分只是一个 Module，不是进程。每一个 ChatServer 调用 Route 里的代码的时候，执行过程其实是在每个 ChatServer 进程内部的。这样我们就避免了集中向一个进程发送消息带来的瓶颈。我们把这种瓶颈的处理留给了 ETS 来解决。</li><li>如何伸缩？ChatServer 在不在同一个服务器上没什么关系。<code>ChatServerPID ！&#123;send, Msg&#125;</code> 会将消息发送到ChatServerPID，即使 ChatServerPID 在远端的服务器上。分布式部署的时候，这行代码根本不用改，你要做的仅仅是添加一个新的 Erlang Node。分布式 Erlang 后面还要讲。</li><li>如何扩展？ETS 使用 Route Module 管理，为的就是当以后换用其他的缓存数据库的时候简单一些。我们设想后面为了做分布式集群，要用 mnesia 替代 ETS，只需要写一个新的 Route Module，内部改用 mnesia 存储，然后替换线上已经加载的老的 Route Module。线上系统都不用停止，客户端的连接一个都不会断！</li></ul><p><code>你现在能否体会到 Erlang 的实用主义呢？完全没废话，就是解决问题！</code></p><p>Client 部分我们现在不做，让前端的同学帮我们实现。但假设我们的前端程序员还没到岗，所以我们可以先放着 WebSocket 部分后面再做。但有两个过程必须现在实现：</p><ul><li>当 Client 登录时，我们需要使用 Route 注册 user 所在的 ChatServer 的 PID。</li><li>当 Client 发消息时，我们需要使用 Route 查找对方的 ChatServer 的 PID。</li></ul><p>首先我们来定义我们的消息协议。我们的消息体内包含几部分，发送者ID，接收者ID，以及消息内容：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-record</span><span class="hljs-params">(msg, &#123;</span><span class="hljs-params">  from_userid,</span><span class="hljs-params">  to_userid,</span><span class="hljs-params">  payload</span><span class="hljs-params">&#125;)</span>.</code></pre><p>接下来让我们来实现 Route 模块，实现数据库创建，注册，查找与注销功能：</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(route)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([ensure_db/<span class="hljs-number">0</span>,</span><span class="hljs-params">         lookup_server/<span class="hljs-number">1</span>,</span><span class="hljs-params">         register_server/<span class="hljs-number">2</span>,</span><span class="hljs-params">         unregister_server/<span class="hljs-number">1</span>])</span>.<span class="hljs-function"><span class="hljs-title">ensure_db</span><span class="hljs-params">()</span> -&gt;</span>  <span class="hljs-keyword">case</span> ets:info(servers) <span class="hljs-keyword">of</span>    undefined -&gt;      <span class="hljs-comment">%% 为了演示方便，我们启动一个临时进程来创建 ETS 表，</span>      <span class="hljs-comment">%% 如果直接在 erlang shell 里创建ETS的话，出错时 shell 的崩溃连带着我们的ETS也丢了。</span>      <span class="hljs-comment">%% 当然线上系统不会这么做。</span>      spawn(<span class="hljs-keyword">fun</span>() -&gt; ets:new(servers, [named_table, public]), <span class="hljs-keyword">receive</span> <span class="hljs-keyword">after</span> infinity-&gt;ok <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>);    _ -&gt; ok  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">lookup_server</span><span class="hljs-params">(UserID)</span> -&gt;</span>  <span class="hljs-keyword">case</span> ets:lookup(servers, UserID) <span class="hljs-keyword">of</span>    [&#123;UserID, ServerID&#125;] -&gt; &#123;ok, ServerID&#125;;    _ -&gt; &#123;error, no_server&#125;  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">register_server</span><span class="hljs-params">(UserID, ServerID)</span> -&gt;</span>  ets:insert(servers, &#123;UserID, ServerID&#125;).<span class="hljs-function"><span class="hljs-title">unregister_server</span><span class="hljs-params">(UserID)</span> -&gt;</span>  ets:delete(servers, UserID).</code></pre><p>接下来实现我们的 ChatServer:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(chat_server)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(gen_server)</span>.<span class="hljs-comment">%% state 保存用户的 userid，以及 client 端连上来的 socket.</span><span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;</span><span class="hljs-params">  userid,</span><span class="hljs-params">  socket</span><span class="hljs-params">&#125;)</span>.<span class="hljs-comment">%% 后面当一个新连接连接到服务器的时候，我们会调用 start_link 启动一个新的 ChatServer 为之服务。</span><span class="hljs-comment">%% 注意这里使用的是 gen_server:start_link/3，没有注册进程名，我们直接使用 PID. 因为我们要启动很多个 ChatServer。</span><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(UserID, Socket)</span> -&gt;</span>  &#123;ok, ServerID&#125;  = gen_server:start_link(?MODULE, [UserID, Socket], []),  ServerID.<span class="hljs-comment">%% 在 init 回调里注册用户的 ChatServer。</span><span class="hljs-comment">%% 注意我们捕获了 exit signal, 以便程序退出的时候回调 terminate/2. </span><span class="hljs-comment">%% 我们在 terminate/2 里取消注册。</span><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([UserID, Socket])</span> -&gt;</span>    process_flag(trap_exit, true),    route:register_server(UserID, self()),    &#123;ok, #state&#123;userid=UserID, socket=Socket&#125;&#125;.<span class="hljs-comment">%% 如果我们的 ChatServer 收到一条来自 Socket 的消息，它会收到一条类似 &#123;tcp, Sock, Data&#125; 的普通消息。</span><span class="hljs-comment">%% 我们需要在 handle_info 里处理，转发给对方的 ChatServer。</span><span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(&#123;tcp, #msg&#123;to_userid = ToUserID, payload = Payload&#125; = Msg&#125;, State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Chat Server(User: ~p) - received msg from tcp client, Msg: ~p~n&quot;</span>,[State#state.userid, Msg]),  <span class="hljs-keyword">case</span> route:lookup_server(ToUserID) <span class="hljs-keyword">of</span>    &#123;error, Reason&#125; -&gt;      io:format(<span class="hljs-string">&quot;Chat Server(User: ~p) - cannot forward to Chat Server(User: ~p): ~p~n&quot;</span>,          [State#state.userid, ToUserID, Reason]);    &#123;ok, TargetServerID&#125; -&gt;      io:format(<span class="hljs-string">&quot;Chat Server(User: ~p) - forward msg to Chat Server(User: ~p), Payload: ~p~n&quot;</span>,        [State#state.userid, ToUserID, Payload]),      ok = gen_server:call(TargetServerID, &#123;send, Msg&#125;)  <span class="hljs-keyword">end</span>,  &#123;noreply, State&#125;;<span class="hljs-comment">%% 我们的 ChatServer 收到一条来自对端 ChatServer 的转发请求</span><span class="hljs-function"><span class="hljs-title">handle_call</span><span class="hljs-params">(&#123;send, #msg&#123;payload = Payload&#125;&#125;, _From, State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Chat Server(User: ~p) - deliver msg to tcp client, Payload: ~p~n&quot;</span>,    [State#state.userid, Payload]),  send_to_client_via_tcp(State#state.socket, Payload),  &#123;reply, ok, State&#125;;<span class="hljs-comment">%% Socket 部分我们没有实现，暂时就简单打印一下</span><span class="hljs-function"><span class="hljs-title">send_to_client_via_tcp</span><span class="hljs-params">(_Socket, Payload)</span> -&gt;</span>  <span class="hljs-comment">%gen_tcp:send(_Socket, Payload),</span>  io:format(<span class="hljs-string">&quot;Sent To Client: ~p~n&quot;</span>,[Payload]).</code></pre><p>完工了！我们测试一下：</p><pre><code class="hljs shell"><span class="hljs-meta">1&gt;</span><span class="bash"> c(chat_server).</span>&#123;ok,chat_server&#125;<span class="hljs-meta">2&gt;</span><span class="bash"> c(route).</span>&#123;ok,route&#125;<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 现在模拟系统启动时，初始化 DB 的过程。</span><span class="hljs-meta">%</span><span class="bash">% 后续这个会在启动代码里写。</span><span class="hljs-meta">3&gt;</span><span class="bash"> route:ensure_db().</span>&lt;0.73.0&gt;<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 现在我们模拟一个新的用户登录上来，启动新的 ChatServer 的过程。</span><span class="hljs-meta">%</span><span class="bash">% 后续这个过程当然是由 WebSocket 模块调用。</span><span class="hljs-meta">4&gt;</span><span class="bash"> ServerIDUser1 = chat_server:start_link(&lt;&lt;<span class="hljs-string">&quot;user1&quot;</span>&gt;&gt;, fake_socket).</span>&lt;0.75.0&gt;<span class="hljs-meta">5&gt;</span><span class="bash"> ServerIDUser2 = chat_server:start_link(&lt;&lt;<span class="hljs-string">&quot;user2&quot;</span>&gt;&gt;, fake_socket).</span>&lt;0.77.0&gt;<span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 我们来做一个 <span class="hljs-comment">#msg&#123;&#125; 消息体。</span></span><span class="hljs-meta">%</span><span class="bash">% 后续我们应该在收到 socket 上来的消息解析成功之后，打包一个 <span class="hljs-comment">#msg&#123;&#125; 消息体。</span></span><span class="hljs-meta">6&gt;</span><span class="bash"> rr(<span class="hljs-string">&quot;chat_protocol.hrl&quot;</span>).</span>[msg]<span class="hljs-meta">7&gt;</span><span class="bash"> Msg = <span class="hljs-comment">#msg&#123;from_userid= &lt;&lt;&quot;user1&quot;&gt;&gt;, to_userid = &lt;&lt;&quot;user2&quot;&gt;&gt;, payload = &lt;&lt;&quot;hello?&quot;&gt;&gt;&#125;.</span></span><span class="hljs-meta">#</span><span class="bash">msg&#123;from_userid = &lt;&lt;<span class="hljs-string">&quot;user1&quot;</span>&gt;&gt;,to_userid = &lt;&lt;<span class="hljs-string">&quot;user2&quot;</span>&gt;&gt;,</span>     payload = &lt;&lt;&quot;hello?&quot;&gt;&gt;&#125;<span class="hljs-meta"></span><span class="hljs-meta"></span><span class="hljs-meta">%</span><span class="bash">% 模拟从 socket 收到消息的过程。</span><span class="hljs-meta">8&gt;</span><span class="bash"> ServerIDUser1 ! &#123;tcp, Msg&#125;.</span>Chat Server(User: &lt;&lt;&quot;user1&quot;&gt;&gt;) - received msg from tcp client, Msg: &#123;msg,                                                                     &lt;&lt;&quot;user1&quot;&gt;&gt;,                                                                     &lt;&lt;&quot;user2&quot;&gt;&gt;,                                                                     &lt;&lt;&quot;hello?&quot;&gt;&gt;&#125;&#123;tcp,#msg&#123;from_userid = &lt;&lt;&quot;user1&quot;&gt;&gt;,to_userid = &lt;&lt;&quot;user2&quot;&gt;&gt;,          payload = &lt;&lt;&quot;hello?&quot;&gt;&gt;&#125;&#125;Chat Server(User: &lt;&lt;&quot;user1&quot;&gt;&gt;) - forward msg to Chat Server(User: &lt;&lt;&quot;user2&quot;&gt;&gt;), Payload: &lt;&lt;&quot;hello?&quot;&gt;&gt;Chat Server(User: &lt;&lt;&quot;user2&quot;&gt;&gt;) - deliver msg to tcp client, Payload: &lt;&lt;&quot;hello?&quot;&gt;&gt;Sent To Client: &lt;&lt;&quot;hello?&quot;&gt;&gt;<span class="hljs-meta">9&gt;</span></code></pre><p>我们看到服务端的路由已经走通了，接下来只要写一个 web socket 模块，listen 在某个端口，当有连接请求时，像上面第 4、第 5 行一样调用 chat_server:start_link/2 就行了。当然 send_to_client_via_tcp 也要改为真正往 socket 发送消息。</p><p>完整代码：<br><a href="https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/chat">https://github.com/terry-xiaoyu/learn-erlang-in-30-mins/tree/master/chat</a></p><p>一个完整的线上演示：<br>(即将上线)</p><p><strong>书接下文</strong>：<a href="https://www.jianshu.com/p/bbaf695ec167">30 分钟学 Erlang (三)</a></p><section class="footnotes">批注<div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Golang 里你需要自己找多线程安全的 maps 库，写并发没有安全感。Golang 官方也没有下文要说到的 OTP 里提供的各种 Behavior，代码写起来天马行空最后一团糟。然后又不能支持函数式的 pattern matching 等写法… 总之用 golang 写代码从来不会给人愉快的感觉。流行是流行的，但那叫“普通”吧？第一次这么吐槽 golang，但这篇是 erlang 的教程，应该不算过分吧。等到写 go 的时候我再来吐槽 erlang 。我是不会写 go 的 …<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种对于当前宇宙模型的假设</title>
    <link href="/2020/12/06/clpqt1itm00094cue49qkhqce.html"/>
    <url>/2020/12/06/clpqt1itm00094cue49qkhqce.html</url>
    
    <content type="html"><![CDATA[<p>一种对于当前宇宙模型的假设</p><span id="more"></span><h1 id="一个民科的假想"><a href="#一个民科的假想" class="headerlink" title="一个民科的假想"></a>一个民科的假想</h1><p>很久以前的一个想法，大致意思就是:</p><p><strong><em>我们的宇宙是实心的一个物体，我们能看到的事物变化就是这个实心空间内的“像素”着色和坐标变换的结果。</em></strong></p><p>当时想象出来的比较有意思，我想以后有没有可能基于这个搞个小说啥的还挺有意思。就这水平我估计连民科都达不到。各位路过的懂得大佬就当个猎奇笑话吧。</p><p><img src="/uploads/openlab/space-assume.png"> </img></p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>一个原子从空间A点移动到B点，实际上就是A点的“像素”取消，然后坐标变换到B点后继续显示。至于这个“像素”是啥，我暂且就叫“宇宙元”吧。而这个坐标系统我想不出来叫啥好，就叫“度量值”。<br>我也学人家搞个符号表示宇宙:</p><p>$$<br>O = P(V)<br>$$</p><ul><li>O: 表示物质</li><li>P: 表示位置量</li><li>V: 表示视觉量</li></ul><p>hiahia，这个想法是不是很有意思？</p>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网所需技术总结</title>
    <link href="/2020/12/06/clpqt1itp000g4cue2u1sh5l7.html"/>
    <url>/2020/12/06/clpqt1itp000g4cue2u1sh5l7.html</url>
    
    <content type="html"><![CDATA[<p>本文主要讲了物联网所需技术总结</p><span id="more"></span><p>总结了一下物联网领域内的一些技术路线：</p><p><img src="/uploads/wulianwangjishu.png" alt="wulianwangjishu"></p>]]></content>
    
    
    <categories>
      
      <category>freeopenlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>freeopenlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.Netty基础知识-NIO与IO</title>
    <link href="/2020/09/03/clpqt1ixv00j94cue0kaq81c5.html"/>
    <url>/2020/09/03/clpqt1ixv00j94cue0kaq81c5.html</url>
    
    <content type="html"><![CDATA[<p>概要：开始进入Java NIO系列的深入学习了，Netty 是Java系的一个著名NIO框架，Netty在互联网领域获得了广泛的应用，一些著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。</p><blockquote><p>本文来源于：【<a href="https://github.com/ztgreat/blog-docs.git】">https://github.com/ztgreat/blog-docs.git】</a><br>编者仅仅做了简单排版和搬运收藏，非商业用途，最终知识版权归原作者所有。</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始进入Java NIO系列的深入学习了，Netty 是Java系的一个著名NIO框架，Netty在互联网领域获得了广泛的应用，一些著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。</p><p>Netty从使用的角度来说非常的简单，套官方的Demo就可以了，当然对于我们大部分的猿类来说仅仅是使用是不可能的，对于一些核心的技术知识，必须要知其所以然，不然长江后浪推前浪，前浪死在沙滩上(＞﹏＜)</p><p>既然好用，那么说明设计得友好，当然各个类之间的关系肯定也就错综复杂，不断记录学习的过程，同时也不断的提高自己写作的能力，尽量用通俗的方式阐述清楚。</p><p>我自己的风格喜欢先看大概，有一个框框，很多知识点都了解一下，但是不深入，这样再深入研究的时候，不至于不知所云，因此对于Netty系列的文章，我尽量从整体框架入手，从整体再到局部。</p><p>Java NIO的知识 可以说从应用层到底层都有涉及，因此具体想如何学习，这个要看自己的定位，这里推荐几本书，尤其适合还在学校读书的朋友看，这个也是我以前看过的：<code>UNIX网络编程 卷1：套接字联网API</code>，<code>UNIX网络编程 卷2：进程间通信</code>，<code>UNIX环境高级编程</code>,整体偏向中下层，当然还有<code>TCP协议栈</code>相关的至少 对构建自己知识体系很有帮助，LZ是网络专业出身的，因此这方面相对比较熟悉。</p><p><strong>注:本系列文章中用到的Netty 版本为 4.x</strong></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先你得要有NIO基础吧，下面是我前段时间简单些的关于Java NIO的文章，可以参考一下</p><p><a href="http://blog.ztgreat.cn/article/43">Java NIO之Channel、Buffer</a></p><p><a href="http://blog.ztgreat.cn/article/47">Java NIO之Selector 浅析</a></p><p>如果有Linux 相关的网络编程基础那就更好了（类似Linux 的select，epoll），了解Java 线程池。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>废话扯完，现在可以开始正文了(๑•̀ㅂ•́)و✧。我们用官方源码中的例子（<strong>Echo</strong>），先来进行简单分析，可以自行clone 官方源码，里面有很多例子，值得学习和研究，调试也更加的方便。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端的代码我稍微调整了一下，方便理解和后面的介绍</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> &#123;</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> HOST = System.<span class="hljs-built_in">getProperty</span>(<span class="hljs-string">&quot;host&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PORT = Integer.<span class="hljs-built_in">parseInt</span>(System.<span class="hljs-built_in">getProperty</span>(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = Integer.<span class="hljs-built_in">parseInt</span>(System.<span class="hljs-built_in">getProperty</span>(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-string">&quot;256&quot;</span>));    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws Exception </span>&#123;        EventLoopGroup group = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NioEventLoopGroup</span>();        <span class="hljs-keyword">try</span> &#123;            Bootstrap b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bootstrap</span>();            b.<span class="hljs-built_in">group</span>(group);            b.<span class="hljs-built_in">channel</span>(NioSocketChannel.class);            b.<span class="hljs-built_in">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>);            b.<span class="hljs-built_in">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;                 @Override                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">initChannel</span>(SocketChannel ch) throws Exception &#123;                     ChannelPipeline p = ch.<span class="hljs-built_in">pipeline</span>();                     p.<span class="hljs-built_in">addLast</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EchoClientHandler</span>());                 &#125;             &#125;);            <span class="hljs-comment">// Start the client.</span>            ChannelFuture future = b.<span class="hljs-built_in">connect</span>(HOST, PORT);            future.<span class="hljs-built_in">sync</span>();            <span class="hljs-comment">// Wait until the connection is closed.</span>            Channel channel= future.<span class="hljs-built_in">channel</span>();            ChannelFuture closeFuture=channel.<span class="hljs-built_in">closeFuture</span>();            closeFuture.<span class="hljs-built_in">sync</span>();        &#125; finally &#123;            <span class="hljs-comment">// Shut down the event loop to terminate all threads.</span>            group.<span class="hljs-built_in">shutdownGracefully</span>();        &#125;    &#125;&#125;</code></pre><p>可以看到代码非常的简洁，但是涵盖的信息量却不少，接下来我们来大概看看一下框框，并不会深入。</p><h3 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>从名字上了解，这个是事件循环相关的，没关系，我们直接看官方注释：</p><pre><code class="hljs puppet">/** * <span class="hljs-keyword">Special</span> &#123;@<span class="hljs-literal">link</span> EventExecutorGroup&#125; <span class="hljs-keyword">which</span> <span class="hljs-keyword">allows</span> <span class="hljs-keyword">registering</span> &#123;@<span class="hljs-literal">link</span> Channel&#125;<span class="hljs-keyword">s</span> <span class="hljs-keyword">that</span> <span class="hljs-keyword">get</span> * processed for later selection during the event loop. */</code></pre><p>注册Channel以及在后续处理一些事件循环，emmmm，没关系，再来看看它的继承关系</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p><img src="http://img.blog.ztgreat.cn/document/netty/20181221183913.png" alt="netty eventLoopGroup"></p><p>原来这个EventLoopGroup 可以看做是线程池，通过它来进行任务调度执行，完成Channel的注册，以及后面一些事件的处理，到这里，我们知道它的大概用途了，虽然不是很清晰和准确，但是大概心里有谱了。</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>接下来我们看到的就是Bootstrap，从名字知道，这个是启动类相关的，看看源码注释</p><pre><code class="hljs puppet">/** * <span class="hljs-keyword">A</span> &#123;@<span class="hljs-literal">link</span> Bootstrap&#125; <span class="hljs-keyword">that</span> <span class="hljs-keyword">makes</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">easy</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">bootstrap</span> <span class="hljs-keyword">a</span> &#123;@<span class="hljs-literal">link</span> Channel&#125; <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> * for clients. * * &lt;p&gt;<span class="hljs-keyword">The</span> &#123;@<span class="hljs-literal">link</span> <span class="hljs-comment">#bind()&#125; methods are useful in combination with connectionless transports such as datagram (UDP).</span> * For regular TCP connections, please <span class="hljs-literal">use</span> the provided &#123;@<span class="hljs-literal">link</span> <span class="hljs-comment">#connect()&#125; methods.&lt;/p&gt;</span> */</code></pre><p>Bootstrap 是Netty 把复杂的启动过程进行封装后，方便我们用户使用，通过Bootstrap 我们可以很简单的建立TCP连接，可以理解成这是一个启动辅助类。</p><pre><code class="hljs less"><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.group</span>(group);<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.channel</span>(NioSocketChannel.class);</code></pre><p>（1）首先把EventLoopGroup 放到了Bootstrap 中。</p><p>（2）设置channel，这里出现了NioSocketChannel，通过名字相关，这个应该和Java 中的Channel有联系，看看继承关系</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20181221185422.png" alt="netty channel"></p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> io.netty.channel.socket.SocketChannel&#125; which uses NIO selector based implementation.</span><span class="hljs-comment"> */</span></code></pre><p>现在我们明白了NioSocketChannel 是 NIO selector 的一种实现。</p><p>我们看看 <code>channel</code>这个方法</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> B <span class="hljs-function"><span class="hljs-title">channel</span>(<span class="hljs-params">Class&lt;? <span class="hljs-keyword">extends</span> C&gt; channelClass</span>)</span> &#123;    <span class="hljs-keyword">if</span> (channelClass == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;channelClass&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));&#125;</code></pre><p>这里并没有直接创建Channel（肯定啊，不知到ip这些，怎么建立socket (￣_,￣ )），而是创建了一个channelFactory ，很明显这个是一个工厂模式，通过Factory来创建Channel。</p><p>同样的 进入这个<code>ReflectiveChannelFactory</code>里面：</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) &#123;    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">&quot;clazz&quot;</span>);    &#125;    <span class="hljs-built_in">this</span>.clazz = clazz;&#125;@Override<span class="hljs-keyword">public</span> T <span class="hljs-keyword">new</span><span class="hljs-type">Channel</span>() &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> clazz.getConstructor().<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>();    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);    &#125;&#125;</code></pre><p>它提供了一个重要的方法, 即 <strong>newChannel</strong>.</p><p>根据上面代码, 我们就可以确定:</p><ul><li>客户端 中的Bootstrap 中的 ChannelFactory 的实现是 ReflectiveChannelFactory</li><li>生成的 Channel 的具体类型是 NioSocketChannel.<br>Channel 的实例化过程, 其实就是调用的 ChannelFactory#newChannel 方法, 而实例化的 Channel 的具体的类型又是和在初始化 Bootstrap 时传入的 channel() 方法的参数相关. 因此对于我们这个例子中的客户端的 Bootstrap 而言, 生成的的 Channel 实例就是 NioSocketChannel.</li></ul><p>接下里我们继续往下看:</p><pre><code class="hljs cmake">b.<span class="hljs-keyword">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>);</code></pre><p>其实这个时候，我们可以不用care 这些的，如果了解TCP协议的话，知道这个应该是设置一些属性（option），不过这里还是提一下算了，名字表达的意思是<code>禁止延迟</code>，看下文档：</p><blockquote><p><strong>TCP_NODELAY</strong></p><p>If set, disable the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets, which results in poor utilization of the network. This option is overridden by <strong>TCP_CORK</strong>; however, setting this option forces an explicit flush of pending output, even if <strong>TCP_CORK</strong> is currently set.</p></blockquote><p>参考<a href="https://linux.die.net/man/7/tcp">TCP protocol</a></p><p>TCP/IP协议中有一个<code>Nagle</code>算法。Nagle算法通过减少需要传输的数据包，来优化网络。关于Nagle算法，在内核实现中，数据包的发送和接受会先做缓存，分别对应于写缓存和读缓存。<br>启动TCP_NODELAY，就意味着禁用了Nagle算法，允许小包的发送。对于延时敏感型，同时数据传输量比较小的应用，开启TCP_NODELAY选项无疑是一个正确的选择。</p><p>如果开启了Nagle算法，就很可能出现频繁的延时，数据只有在写缓存中累积到一定量之后，才会被发送出去，这样明显提高了网络利用率。但是这由不可避免地增加了延时。</p><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><pre><code class="hljs aspectj">b.<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ChannelPipeline p = ch.pipeline();        p.addLast(<span class="hljs-keyword">new</span> EchoClientHandler());    &#125;&#125;);</code></pre><p>在这段代码中，关键词handler,ChannelPipeline 这里不会太细讲，但是会提出相关概念，具体的分析会在后面给出。</p><p>handler  中 传入的是ChannelInitializer ，字面意思呢就是Channel 初始化，在其方法中 initChannel，参数便是创建好的 Channel,再获取ChannelPipeline，设置我们的逻辑逻辑方法 EchoClientHandler。</p><p>下面简单大致描述一下Channel的内部逻辑结构：</p><p>每个 Channel 内部都有一个 pipeline，pipeline 由<strong>多个 handler</strong> 组成，<strong>handler 之间的顺序是很重要的</strong>，因为 IO 事件将按照顺序顺次经过 pipeline 上的 handler，这样每个 handler 只关注自己的业务逻辑，由多个 handler 组合来完成一些复杂的逻辑。</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20181223152945.png" alt="netty pipeline"></p><p>首先，两个重要的概念：<strong>Inbound</strong> 和 <strong>Outbound</strong>。在 Netty 中，IO 事件被分为 Inbound 事件和 Outbound 事件。</p><p><strong>Outbound</strong> 的 <strong>out</strong> 指的是 <strong>出去</strong>，比如 connect、write、flush 这些 IO 操作是往外部方向进行的(<strong>数据往外传输</strong>)，它们就属于 Outbound 事件，其他的，类似 accept、read 这种就属于 Inbound 事件（<strong>有远程数据进入</strong>）。</p><p>定义处理 Inbound 事件的 handler 需要实现 ChannelInboundHandler，定义处理 Outbound 事件的 handler 需要实现 ChannelOutboundHandler，通常我们继承其相应的适配器，然后实现相关方法就可以了。</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20181223154151.png" alt="netty handler"></p><p>特别的，如果我们希望定义一个 handler 能同时处理 Inbound 和 Outbound 事件（可以认为是双工模式），我们可以继承 ChannelDuplexHandler 的方式(继承关系图中未列出来)。</p><p>关于Handler 和Pipeline 我们就暂说到这里。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><pre><code class="hljs arduino">ChannelFuture future = b.<span class="hljs-built_in">connect</span>(HOST, PORT);</code></pre><p>很明显，这里是进行connect，连接远程主机，建立TCP连接，那么这里面肯定也会创建Channle,我们跟踪查看一下</p><h4 id="doResolveAndConnect"><a href="#doResolveAndConnect" class="headerlink" title="doResolveAndConnect"></a>doResolveAndConnect</h4><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;    <span class="hljs-keyword">if</span> (regFuture.is<span class="hljs-constructor">Done()</span>) &#123;        <span class="hljs-keyword">if</span> (!regFuture.is<span class="hljs-constructor">Success()</span>) &#123;            return regFuture;        &#125;        return <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect0(<span class="hljs-params">channel</span>, <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">localAddress</span>, <span class="hljs-params">channel</span>.<span class="hljs-params">newPromise</span>()</span>);    &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//省略代码</span>    &#125;&#125;</code></pre><p>中间省略几个方法调用，最终我们看这个doResolveAndConnect 方法，里面对Channel进行初始化和注册（initAndRegister 方法），我们看看 initAndRegister 方法：</p><h4 id="initAndRegister"><a href="#initAndRegister" class="headerlink" title="initAndRegister"></a>initAndRegister</h4><pre><code class="hljs reasonml">final ChannelFuture init<span class="hljs-constructor">AndRegister()</span> &#123;    Channel channel = null;    <span class="hljs-keyword">try</span> &#123;        channel = channelFactory.<span class="hljs-keyword">new</span><span class="hljs-constructor">Channel()</span>;        init(channel);    &#125; catch (Throwable t) &#123;        <span class="hljs-keyword">if</span> (channel != null) &#123;            channel.unsafe<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Forcibly()</span>;            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPromise(<span class="hljs-params">channel</span>, GlobalEventExecutor.INSTANCE)</span>.set<span class="hljs-constructor">Failure(<span class="hljs-params">t</span>)</span>;        &#125;        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPromise(<span class="hljs-params">new</span> FailedChannel()</span>, GlobalEventExecutor.INSTANCE).set<span class="hljs-constructor">Failure(<span class="hljs-params">t</span>)</span>;    &#125;    ChannelFuture regFuture = config<span class="hljs-literal">()</span>.group<span class="hljs-literal">()</span>.register(channel);    <span class="hljs-keyword">if</span> (regFuture.cause<span class="hljs-literal">()</span> != null) &#123;        <span class="hljs-keyword">if</span> (channel.is<span class="hljs-constructor">Registered()</span>) &#123;            channel.close<span class="hljs-literal">()</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            channel.unsafe<span class="hljs-literal">()</span>.close<span class="hljs-constructor">Forcibly()</span>;        &#125;    &#125;    return regFuture;&#125;</code></pre><p>这里我们看到 channel = channelFactory.newChannel(); 这个便是创建Channel,而这个channelFactory便是我们前面看到的 <code>ReflectiveChannelFactory</code></p><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>我们继续往下看</p><pre><code class="hljs arduino"><span class="hljs-comment">// Start the client.</span>ChannelFuture future = b.<span class="hljs-built_in">connect</span>(HOST, PORT);future.<span class="hljs-built_in">sync</span>();<span class="hljs-comment">// Wait until the connection is closed.</span>Channel channel= future.<span class="hljs-built_in">channel</span>();ChannelFuture closeFuture=channel.<span class="hljs-built_in">closeFuture</span>();closeFuture.<span class="hljs-built_in">sync</span>();</code></pre><p>通过connect后，返回了一个ChannelFuture，查看这个ChannelFuture的继承关系，我们发现它继承JDK 中的Future。</p><p>关于 JDK 中的Future 接口，大家应该都比较熟悉吧，在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 <strong>submit</strong> 一个任务到线程池中的时候，返回的就是一个 <strong>Future</strong> 实例，通过它来获取提交的任务的执行状态和最终的执行结果，我们最常用它的 <code>isDone()</code> 和 <code>get()</code> 方法。</p><p>既然如此，虽然我们还没有研究ChannelFuture，但是我们可以猜测其实和JDK 中的Future 是差不多的，future.sync(); 方法，通过sync这个名字，我们知道这个是在同步等待，等待什么？，等待连接建立成功.</p><p>当连接建立完毕后，我们就可以通过ChannelFuture 来获取Channel。通过Channel又获取了一个Future,通过名字我们知道这个一个关于Channel 关闭后的Future，然后执行sync 方法，等待Channel 关闭</p><p>如果没有closeFuture.sync();那么执行完连接后（假设我们连接成功了），客户端会直接退出,这肯定是我们不想要的。</p><p>ok,到这里我们就把客户端的大致逻辑梳理了一下，虽然没有深入，但是对于大致的功能，流程还是有所明白的，下面再来看看服务端的代码。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre><code class="hljs reasonml">public final <span class="hljs-keyword">class</span> EchoServer &#123;    static final <span class="hljs-built_in">int</span> PORT = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(System.<span class="hljs-params">getProperty</span>(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>)</span>);    public static void main(String<span class="hljs-literal">[]</span> args) throws Exception &#123;        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup(1)</span>;        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioEventLoopGroup()</span>;        <span class="hljs-keyword">try</span> &#123;            ServerBootstrap b = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerBootstrap()</span>;            b.group(bossGroup, workerGroup);            b.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioServerSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);            b.option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>);            b.handler(<span class="hljs-keyword">new</span> <span class="hljs-constructor">LoggingHandler(LogLevel.INFO)</span>);            b.child<span class="hljs-constructor">Handler(<span class="hljs-params">new</span> ChannelInitializer&lt;SocketChannel&gt;()</span> &#123;                 @Override                 public void init<span class="hljs-constructor">Channel(SocketChannel <span class="hljs-params">ch</span>)</span> throws Exception &#123;                     ChannelPipeline p = ch.pipeline<span class="hljs-literal">()</span>;                     p.add<span class="hljs-constructor">Last(<span class="hljs-params">new</span> EchoServerHandler()</span>);                 &#125;             &#125;);            <span class="hljs-comment">// Start the server.</span>            ChannelFuture future = b.bind(PORT);            future.sync<span class="hljs-literal">()</span>;            <span class="hljs-comment">// Wait until the server socket is closed.</span>            Channel channel = future.channel<span class="hljs-literal">()</span>;            ChannelFuture closeFuture = channel.close<span class="hljs-constructor">Future()</span>;            closeFuture.sync<span class="hljs-literal">()</span>;        &#125; finally &#123;            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span>            bossGroup.shutdown<span class="hljs-constructor">Gracefully()</span>;            workerGroup.shutdown<span class="hljs-constructor">Gracefully()</span>;        &#125;    &#125;&#125;</code></pre><p>我们看到其实服务端和客户端非常的相似，这里我们也只是大概看一下差异性。</p><h3 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h3><p>相比客户端的 Bootstrap，这里变成了ServerBootstrap，这个也好理解，毕竟一个是客户端，一个是服务端，两者分开，更好的理解和设计维护，从功能上来上都是一样，都是便于用户的使用，通过ServerBootstrap 我们可以很轻松的开启一个服务端的Netty 应用。</p><h3 id="EventLoopGroup-1"><a href="#EventLoopGroup-1" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h3><p>这里我们看到有两个EventLoopGroup，而客户端只有一个，也就是说服务端用了两个线程池来处理一些任务。</p><p>对于客户端而言，通常就是连接服务器，然后与服务器进行交互。</p><p>对于服务端而言，服务端需要监听是否有客户端来进行连接，也就是对客户端的Accept的处理，当accept后，才是真正的与客户端进行交互。</p><p>我们可以从源码了解到一些信息：</p><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Specify the &#123;<span class="hljs-doctag">@link </span>EventLoopGroup&#125; which is used for the parent (acceptor) and the child (client).</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-function"><span class="hljs-title">group</span>(<span class="hljs-params">EventLoopGroup group</span>)</span> &#123;    <span class="hljs-keyword">return</span> group(group, group);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Set the &#123;<span class="hljs-doctag">@link </span>EventLoopGroup&#125; for the parent (acceptor) and the child (client). These</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link </span>EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link </span>ServerChannel&#125; and</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link </span>Channel&#125;&#x27;s.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-function"><span class="hljs-title">group</span>(<span class="hljs-params">EventLoopGroup parentGroup, EventLoopGroup childGroup</span>)</span> &#123;    <span class="hljs-built_in">super</span>.group(parentGroup);    <span class="hljs-keyword">if</span> (childGroup == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;childGroup&quot;</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.childGroup != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;childGroup set already&quot;</span>);    &#125;    <span class="hljs-built_in">this</span>.childGroup = childGroup;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;</code></pre><p>其中一个EventLoopGroup则是负责处理客户端的<strong>连接请求</strong>; 而 另一个 就是负责<strong>客户端连接后的 IO 交互</strong>.，这里，我们不深入，有个概念就可以了。</p><h3 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h3><p>同样的，这里也和客户端的NioSocketChannel 不一样，NioServerSocketChannel 是针对Netty 服务端的NIO selector的实现。</p><pre><code class="hljs puppet">/** * <span class="hljs-keyword">A</span> &#123;@<span class="hljs-literal">link</span> io.netty.channel.socket.ServerSocketChannel&#125; <span class="hljs-keyword">implementation</span> <span class="hljs-keyword">which</span> <span class="hljs-keyword">uses</span> * NIO selector based implementation to accept new connections. */</code></pre><h4 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h4><pre><code class="hljs less"><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.option</span>(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>);</code></pre><p>查看 <code>java.nio.channels.ServerSocketChannel</code> bind 方法:</p><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><span class="hljs-comment">* Binds the channel&#x27;s socket to a local address and configures the socket to</span><span class="hljs-comment">* listen for connections.</span><span class="hljs-comment">*</span><span class="hljs-comment">* &lt;p&gt; This method is used to establish an association between the socket and</span><span class="hljs-comment">* a local address. Once an association is established then the socket remains</span><span class="hljs-comment">* bound until the channel is closed.</span><span class="hljs-comment">*</span><span class="hljs-comment">* &lt;p&gt; The &#123;<span class="hljs-doctag">@code</span> backlog&#125; parameter is the maximum number of pending</span><span class="hljs-comment">* connections on the socket. Its exact semantics are implementation specific.</span><span class="hljs-comment">* In particular, an implementation may impose a maximum length or may choose</span><span class="hljs-comment">* to ignore the parameter altogther. If the &#123;<span class="hljs-doctag">@code</span> backlog&#125; parameter has</span><span class="hljs-comment">* the value &#123;<span class="hljs-doctag">@code</span> 0&#125;, or a negative value, then an implementation specific</span><span class="hljs-comment">* default is used.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function">ServerSocketChannel <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress local, <span class="hljs-keyword">int</span> backlog)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException</span>;</code></pre><p>最大等待建立连接的scoket数量（等待建立socket连接 排队数量）</p><p><strong>注:下面说法可能不严谨，仅供 提供相关信息，可以自己查阅资料</strong></p><p>（1）一种说法:</p><p>在linux系统内核中有一个队列：syns queue</p><p>用于保存<strong>半连接状态</strong>的请求（TCP三次握手），其大小通过/proc/sys/net/ipv4/tcp_max_syn_backlog指定，常见的TCP SYN FLOOD恶意DOS攻击方式就是建立大量的半连接状态的请求，然后丢弃，导致syns queue不能保存其它正常的请求。</p><blockquote><p><em>tcp_max_syn_backlog</em> (integer; default: see below; since Linux 2.2)</p><p>The maximum number of queued connection requests which have still not received an acknowledgement from the connecting client. If this number is exceeded, the kernel will begin dropping requests. The default value of 256 is increased to 1024 when the memory present in the system is adequate or greater (&gt;= 128Mb), and reduced to 128 for those systems with very low memory (&lt;= 32Mb). It is recommended that if this needs to be increased above 1024, </p></blockquote><p>参考<a href="https://linux.die.net/man/7/tcp">TCP protocol</a></p><p>更多可以参考了解 <a href="https://blog.csdn.net/u014634338/article/details/49154685">Linux网络编程—TCP三次握手，SYN洪水攻击</a></p><p>（2）第二种说法</p><p><code>backlog</code>参数的行为在<code>Linux</code>2.2之后有所改变。现在，它指定了等待<code>accept</code>系统调用的已建立连接队列的长度，而不是待完成连接请求数</p><p>更多可以参考:</p><p><a href="http://veithen.io/2014/01/01/how-tcp-backlog-works-in-linux.html">How TCP backlog works in Linux</a>(需要科学上网)</p><p><a href="https://www.jianshu.com/p/7fde92785056">[译文]深入理解Linux TCP backlog</a></p><p><a href="https://linux.die.net/man/2/listen">https://linux.die.net/man/2/listen</a></p><p>具体的和Linux系统实现有关，这个我觉得自己明白怎么回事就可以了。</p><h3 id="handler-1"><a href="#handler-1" class="headerlink" title="handler"></a>handler</h3><p>服务器端的 handler 的添加过程和客户端的有点区别, 和 EventLoopGroup 一样, 服务器端的 handler 也有两个, 一个是通过 handler() 方法设置 handler 字段, 另一个是通过 childHandler() 设置 childHandler 字段. </p><p>类比  EventLoopGroup，这个 handler 字段与 accept 过程有关, 也就是说这个 handler 负责处理客户端的<strong>连接请求</strong>; 而 childHandler 就是负责<strong>客户端连接后的 IO 交互</strong>.</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>走马观花的把Netty的demo过了一遍，对每个模块进行了简单的提及和分析，没有探讨任何细节的地方，首先我们对Netty有了一个感性的认识，了解了一些关键点，知道了大概的流程，这样，并不需要我们非要一行一行代码的弄清楚，有了大致认识后，可以去了解相关的知识点，有了这些基础知识后，再对netty 深入分析，相当于把零散的东西再进行一次整合，这样从整体到局部，再从局部到整体，我觉得这样对框架的整体认识才会比较深刻。</p>]]></content>
    
    
    <categories>
      
      <category>Netty基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.Netty基础知识-源码简单解析</title>
    <link href="/2020/09/03/clpqt1ixv00ja4cue8gju85uc.html"/>
    <url>/2020/09/03/clpqt1ixv00ja4cue8gju85uc.html</url>
    
    <content type="html"><![CDATA[<p>概要：开始进入Java NIO系列的深入学习了，Netty 是Java系的一个著名NIO框架，Netty在互联网领域获得了广泛的应用，一些著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。</p><span id="more"></span><blockquote><p>本文来源于：【<a href="https://github.com/ztgreat/blog-docs.git】">https://github.com/ztgreat/blog-docs.git】</a><br>编者仅仅做了简单排版和搬运收藏，非商业用途，最终知识版权归原作者所有。</p></blockquote><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>在Netty 中，实现了自己的Channel，我们先来看看Java 中的Channel.</p><h3 id="Java-中Channel"><a href="#Java-中Channel" class="headerlink" title="Java 中Channel"></a>Java 中Channel</h3><p><code>java.nio.channels.Channel</code>:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Closeable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;&#125;</code></pre><p>很简单，就只有两个方法，判断当前Channle 是否是开启的，以及关闭当前Channel.</p><h3 id="Netty中的Channel"><a href="#Netty中的Channel" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeMap</span>, <span class="hljs-title">ChannelOutboundInvoker</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;    <span class="hljs-function">ChannelId <span class="hljs-title">id</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//留意一下</span>    <span class="hljs-function">EventLoop <span class="hljs-title">eventLoop</span><span class="hljs-params">()</span></span>;        <span class="hljs-function">Channel <span class="hljs-title">parent</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">ChannelConfig <span class="hljs-title">config</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRegistered</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isWritable</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//留意一下</span>    <span class="hljs-function">ChannelPipeline <span class="hljs-title">pipeline</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Channel <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Channel <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &lt;em&gt;Unsafe&lt;/em&gt; operations that should &lt;em&gt;never&lt;/em&gt; be called from user-code. These methods</span><span class="hljs-comment">     * are only provided to implement the actual transport, and must be invoked from an I/O thread except for the</span><span class="hljs-comment">     */</span>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Unsafe</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(EventLoop eventLoop, ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span></span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//省略部分方法</span>    &#125;    <span class="hljs-comment">//省略部分方法</span>&#125;</code></pre><p>为了减小篇幅，省略了部分的方法，方便阅读。</p><p>相比而言，Netty 中的Channel 就比Java 中的Netty 复杂和丰富多了，每个Channel 都和EventLoop，ChannelPipeline挂钩，同时还有一个Unsafe 接口，这个和Java 中的Unsafe 有异曲同工之妙，Java 中的Unsafe 主要是面向的Java自身使用，并非面向用户而言，把一些底层封装到了Unsafe 中，而Netty 中也是一样的，它封装了对 Java 底层 Socket 的操作, 因此实际上是沟通 Netty 上层和 Java 底层的重要的桥梁.</p><p> 注意Netty 的Channel 中还有一个parent，这个说明 channel是有等级的。我们可以通过调用Channel的<code>parent()</code>方法获取，<code>parent()</code>方法的返回取决于该Channel是怎么创建出来的。比如一个<code>SocketChannel</code>由一个<code>ServerSocketChannel</code>接收，因此当调用<code>SocketChannel</code>的<code>parent()</code>方法时将返回<code>ServerSocketChannel</code></p><p>大概了解就可以了，这里也不会深入，我们一步一步来。</p><h2 id="NioSocketChannel"><a href="#NioSocketChannel" class="headerlink" title="NioSocketChannel"></a>NioSocketChannel</h2><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://img.blog.ztgreat.cn/document/netty/20181230120027.png" alt="NioSocketChannel"></p><p><strong>这里面没有Java NIO的任何身影</strong>，AttributeMap这是绑定在Channel上的一个附件，相当于附件一样。</p><h3 id="AttributeMap"><a href="#AttributeMap" class="headerlink" title="AttributeMap"></a>AttributeMap</h3><pre><code class="hljs puppet">/** * <span class="hljs-keyword">Holds</span> &#123;@<span class="hljs-literal">link</span> Attribute&#125;<span class="hljs-keyword">s</span> <span class="hljs-keyword">which</span> <span class="hljs-keyword">can</span> <span class="hljs-keyword">be</span> <span class="hljs-keyword">accessed</span> <span class="hljs-keyword">via</span> &#123;@<span class="hljs-literal">link</span> AttributeKey&#125;. * Implementations must be Thread-safe. */public interface <span class="hljs-keyword">AttributeMap</span> &#123;    &lt;T&gt; Attribute&lt;T&gt; attr(AttributeKey&lt;T&gt; key);    &lt;T&gt; boolean hasAttr(AttributeKey&lt;T&gt; key);&#125;</code></pre><p>我们可以看到这个是<strong>线程安全</strong>的，因此可以方便大胆的使用，有时候我们需要保存一会回话参数或者一些变量，通过AttributeMap就可以很方便的实现，使用的地方还是很多的。</p><h2 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h2><p>相比NioSocketChannel，这个NioServerSocketChannel 是面向服务端的。</p><h3 id="继承体系-1"><a href="#继承体系-1" class="headerlink" title="继承体系"></a>继承体系</h3><p><img src="http://img.blog.ztgreat.cn/document/netty/20181230120055.png" alt="NioServerSocketChannel"></p><p>其继承体系大体差不多。</p><p>除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 BIO( 即传统的阻塞 IO) 版本的区别. 不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</p><p>下面是一些常用的 Channel 类型:</p><ul><li>NioSocketChannel, 代表异步的客户端 TCP Socket 连接.</li><li>NioServerSocketChannel, 异步的服务器端 TCP Socket 连接.</li><li>NioDatagramChannel, 异步的 UDP 连接</li><li>NioSctpChannel, 异步的客户端 Sctp 连接.</li><li>NioSctpServerChannel, 异步的 Sctp 服务器端连接.</li><li>OioSocketChannel, 同步的客户端 TCP Socket 连接.</li><li>OioServerSocketChannel, 同步的服务器端 TCP Socket 连接.</li><li>OioDatagramChannel, 同步的 UDP 连接</li><li>OioSctpChannel, 同步的 Sctp 服务器端连接.</li><li>OioSctpServerChannel, 同步的客户端 TCP Socket 连接.</li></ul><blockquote><p>上面的异步是相对阻塞来说的，严格来说，是非完全异步模式的</p></blockquote><p>在前面我们看到不管是NioSocketChannel 还是NioServerSocketChannel 它们的继承体系中都没有和Java的SocketChannel产生直接关系，我们来看看 NioSocketChannel 是怎么和 Java的 SocketChannel 联系在一起的，它们是一对一的关系。NioServerSocketChannel 和 ServerSocketChannel 同理，也是一对一的关系。</p><p>回想一下我们在<strong>客户端</strong>连接代码的初始化 Bootstrap 中, 会调用 channel() 方法, 传入 <strong>NioSocketChannel.class</strong>, 我们就先从这里入手。</p><h2 id="NioSocketChannel的实现"><a href="#NioSocketChannel的实现" class="headerlink" title="NioSocketChannel的实现"></a>NioSocketChannel的实现</h2><p>在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 channel(…) 方法：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//这里只列出了客户端的情况</span>Bootstrap b = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Bootstrap()</span>;b.group(group);b.channel(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioSocketChannel</span>.</span></span><span class="hljs-keyword">class</span>);</code></pre><p>下面，我们来看 channel(…) 方法的源码：</p><pre><code class="hljs typescript"><span class="hljs-comment">// AbstractBootstrap</span><span class="hljs-keyword">public</span> B <span class="hljs-function"><span class="hljs-title">channel</span>(<span class="hljs-params">Class&lt;? <span class="hljs-keyword">extends</span> C&gt; channelClass</span>)</span> &#123;    <span class="hljs-keyword">if</span> (channelClass == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;channelClass&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));&#125;</code></pre><p>我们可以看到，这个方法只是设置了 channelFactory 为 ReflectiveChannelFactory 的一个实例，然后我们看下这里的 ReflectiveChannelFactory 到底是什么：</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectiveChannelFactory&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">ChannelFactory&lt;T&gt;</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">T</span>&gt; clazz;    public <span class="hljs-type">ReflectiveChannelFactory</span>(<span class="hljs-type">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-type">T</span>&gt; clazz) &#123;        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">&quot;clazz&quot;</span>);        &#125;        <span class="hljs-keyword">this</span>.clazz = clazz;    &#125;    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">T</span> newChannel() &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> clazz.getConstructor().newInstance();        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);        &#125;    &#125;    <span class="hljs-comment">//省略部分方法</span>&#125;</code></pre><p><strong>newChannel()</strong> 方法是 ChannelFactory 接口中的唯一方法，我们可以看到，ReflectiveChannelFactory#newChannel() 方法中使用了反射调用 Channel 的无参构造方法来创建 Channel。</p><p>既然这里只是产生的工厂类，那什么时候才真正的创建Channel呢？</p><ul><li>对于 NioSocketChannel，由于是客户端，它的创建时机在 <code>connect(…)</code> 的时候；</li><li>对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 <code>bind(…)</code> 的时候。</li></ul><p>接下来，我们来简单追踪下客户端的 Bootstrap 中 NioSocketChannel 的创建过程，看看 NioSocketChannel 是怎么和 Java 中的 SocketChannel 关联在一起的：</p><pre><code class="hljs arduino"><span class="hljs-comment">// Bootstrap</span><span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">String</span> inetHost, <span class="hljs-keyword">int</span> inetPort)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">connect</span>(InetSocketAddress.<span class="hljs-built_in">createUnresolved</span>(inetHost, inetPort));&#125;</code></pre><p>然后再往里看，到这个方法：</p><pre><code class="hljs reasonml">public ChannelFuture connect(SocketAddress remoteAddress) &#123;    <span class="hljs-keyword">if</span> (remoteAddress<span class="hljs-operator"> == </span>null) &#123;        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">NullPointerException(<span class="hljs-string">&quot;remoteAddress&quot;</span>)</span>;    <span class="hljs-comment">// validate 顾名思义 只是校验一下，不重要</span>    validate<span class="hljs-literal">()</span>;    return <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect(<span class="hljs-params">remoteAddress</span>, <span class="hljs-params">config</span>.<span class="hljs-params">localAddress</span>()</span>);&#125;</code></pre><p>继续看 <code>doResolveAndConnect</code>：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveAndConnect(<span class="hljs-params">final</span> SocketAddress <span class="hljs-params">remoteAddress</span>, <span class="hljs-params">final</span> SocketAddress <span class="hljs-params">localAddress</span>)</span> &#123;    <span class="hljs-comment">// 初始化和注册，很明显我们需要关注一下这个方法</span>    final ChannelFuture regFuture = init<span class="hljs-constructor">AndRegister()</span>;    final Channel channel = regFuture.channel<span class="hljs-literal">()</span>;    ......&#125;</code></pre><p>我们看 <code>initAndRegister()</code> 方法：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">final</span> ChannelFuture initAndRegister() &#123;    Channel channel = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// Channel 的实例化</span>        channel = channelFactory.newChannel();        <span class="hljs-keyword">init</span>(channel);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-comment">//省略代码</span>    &#125;    <span class="hljs-comment">//省略代码</span>    <span class="hljs-keyword">return</span> regFuture;&#125;</code></pre><p>我们找到了 <code>channel = channelFactory.newChannel()</code> 这行代码，这个就和我们前面的分析联系起来了，这里会调用相应 Channel 的无参构造方法，创建Channel,至于ChannelFuture 这个我们后面再来看。</p><p>然后我们就可以去看 NioSocketChannel 的构造方法了：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioSocketChannel</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-comment">// SelectorProvider 实例用于创建 JDK 的 SocketChannel 实例</span>    <span class="hljs-built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioSocketChannel</span>(<span class="hljs-params">SelectorProvider provider</span>)</span> &#123;    <span class="hljs-comment">// 到这里，newSocket(provider) 方法会创建 JDK 的 SocketChannel</span>    <span class="hljs-built_in">this</span>(newSocket(provider));&#125;</code></pre><p>我们可以看到，在调用 newSocket(provider) 的时候，会创建 JDK NIO 的一个 SocketChannel 实例：</p><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel <span class="hljs-keyword">new</span><span class="hljs-type">Socket</span>(SelectorProvider provider) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 创建 SocketChannel 实例</span>        <span class="hljs-keyword">return</span> provider.openSocketChannel();    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a socket.&quot;</span>, e);    &#125;&#125;</code></pre><p>NioServerSocketChannel 同理，也非常简单，从 <code>ServerBootstrap#bind(...)</code> 方法一路点进去就清楚了。</p><p>现在我们知道了，NioSocketChannel 在实例化过程中，<strong>会先实例化 JDK 底层的 SocketChannel</strong>，NioServerSocketChannel 也一样，会先实例化 ServerSocketChannel 实例：</p><p>说到这里，我们再继续往里看一下 NioSocketChannel 的构造方法：</p><pre><code class="hljs reasonml">public <span class="hljs-constructor">NioSocketChannel(SelectorProvider <span class="hljs-params">provider</span>)</span> &#123;    this(<span class="hljs-keyword">new</span><span class="hljs-constructor">Socket(<span class="hljs-params">provider</span>)</span>);&#125;</code></pre><p>刚才我们看到这里，newSocket(provider) 创建了底层的 SocketChannel 实例，我们继续往下看构造方法：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioSocketChannel</span>(<span class="hljs-params">SocketChannel socket</span>)</span> &#123;        <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, socket);&#125;</code></pre><p>并传入参数 parent 为 null, socket 为刚才使用 newSocket 创建的 Java NIO SocketChannel, 因此生成的 NioSocketChannel 的 parent channel 是空的.</p><pre><code class="hljs reasonml">public <span class="hljs-constructor">NioSocketChannel(Channel <span class="hljs-params">parent</span>, SocketChannel <span class="hljs-params">socket</span>)</span> &#123;    super(parent, socket);    config = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NioSocketChannelConfig(<span class="hljs-params">this</span>, <span class="hljs-params">socket</span>.<span class="hljs-params">socket</span>()</span>);&#125;</code></pre><p>上面代码很简单，实例化了内部的 NioSocketChannelConfig 实例，它用于保存 channel 的配置信息，这里没有我们现在需要关心的内容，直接跳过。</p><p>调用父类构造器：</p><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">AbstractNioByteChannel</span>(<span class="hljs-params">Channel parent, SelectableChannel ch</span>)</span> &#123;    <span class="hljs-comment">// 客户端关心的是 OP_READ 事件，等待读取服务端返回数据</span>    <span class="hljs-built_in">super</span>(parent, ch, SelectionKey.OP_READ);&#125;</code></pre><p>因为客户端关心的是读事件，因此这里传入的是<code>SelectionKey.OP_READ</code>;</p><p>我们继续看下去：</p><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractNioChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-keyword">int</span> readInterestOp)</span> </span>&#123;    <span class="hljs-keyword">super</span>(parent);    <span class="hljs-keyword">this</span>.ch = ch;    <span class="hljs-comment">// 这里只是保存了 SelectionKey.OP_READ 这个信息</span>    <span class="hljs-keyword">this</span>.readInterestOp = readInterestOp;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//配置 Java NIO SocketChannel 为非阻塞的.</span>        ch.configureBlocking(<span class="hljs-keyword">false</span>);    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;        <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre><p><strong>设置了 SocketChannel 的非阻塞模式</strong></p><p>然后继续调用父类 AbstractChannel 的构造器:</p><pre><code class="hljs reasonml">protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;    this.parent = parent;    <span class="hljs-comment">//实例化 unsafe</span>    unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;        <span class="hljs-comment">//创建 pipeline,没有channel 都有一个pipeline</span>    pipeline = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPipeline(<span class="hljs-params">this</span>)</span>;&#125;</code></pre><p>到这里,  NioSocketChannel 就初始化完成了, 稍微总结一下构造一个 NioSocketChannel 所需要做的工作:</p><ul><li>通过 NioSocketChannel.newSocket(DEFAULT_SELECTOR_PROVIDER) 打开一个新的 Java NIO SocketChannel</li><li>AbstractChannel(Channel parent) 中初始化 AbstractChannel 的属性:<ul><li>parent 属性设置为 null</li><li>unsafe 通过newUnsafe() 实例化一个 unsafe 对象, 它的类型是 AbstractNioByteChannel.NioByteUnsafe 内部类</li><li>pipeline 是 new DefaultChannelPipeline(this) 新创建的实例. </li></ul></li><li>AbstractNioChannel 中的属性:<ul><li>SelectableChannel ch 被设置为 Java SocketChannel</li><li>readInterestOp 被设置为 SelectionKey.OP_READ</li><li>SelectableChannel ch 被配置为非阻塞的 <strong>ch.configureBlocking(false)</strong></li></ul></li><li>NioSocketChannel 中的属性:<ul><li>SocketChannelConfig config = new NioSocketChannelConfig(this, socket.socket())</li></ul></li></ul><p>对于NioServerSocketChannel 而言，其构造方法类似，也<strong>设置了非阻塞</strong>，然后<strong>设置服务端关心的 SelectionKey.OP_ACCEPT 事件</strong>：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">NioServerSocketChannel</span>(<span class="hljs-params">ServerSocketChannel channel</span>)</span> &#123;    <span class="hljs-comment">// 对于服务端来说，关心的是 SelectionKey.OP_ACCEPT 事件，等待客户端连接</span>    <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>, channel, SelectionKey.OP_ACCEPT);    config = <span class="hljs-keyword">new</span> NioServerSocketChannelConfig(<span class="hljs-built_in">this</span>, javaChannel().socket());&#125;</code></pre><p>这节关于 Channel 的内容我们先介绍这么多，主要就是实例化了 JDK 层的 SocketChannel 或 ServerSocketChannel，然后设置了非阻塞模式，对于客户端，关心的是读事件，对于服务端关心的是Accept 事件。</p><p>最后，回答一个问题：</p><p><strong>NioSocketChannel 或者 NioServerSocketChannel 是如何与JDK 中的SocketChannel 联系起来的？</strong></p>]]></content>
    
    
    <categories>
      
      <category>Netty基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.Netty基础知识-异步接口实现原理</title>
    <link href="/2020/09/03/clpqt1ixw00jd4cueevwn5qdn.html"/>
    <url>/2020/09/03/clpqt1ixw00jd4cueevwn5qdn.html</url>
    
    <content type="html"><![CDATA[<p>前面分析了Netty整体的流程 和 Channel的结构，我们看到 Netty 中有很多的异步调用，所以在介绍更多 NIO 相关的内容之前，我们来看看它的异步接口是怎么实现的。</p><span id="more"></span><blockquote><p>本文来源于：【<a href="https://github.com/ztgreat/blog-docs.git】">https://github.com/ztgreat/blog-docs.git】</a><br>编者仅仅做了简单排版和搬运收藏，非商业用途，最终知识版权归原作者所有。</p></blockquote><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前面我们在介绍 Echo 例子的时候，已经用过了 ChannelFuture 这个接口了，接下来我们就来看看 Netty 中的异步调用是如何实现的。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="hljs arduino"><span class="hljs-comment">// Start the client.</span>ChannelFuture future = b.<span class="hljs-built_in">connect</span>(HOST, PORT);future.<span class="hljs-built_in">sync</span>();<span class="hljs-comment">// Wait until the connection is closed.</span>Channel channel= future.<span class="hljs-built_in">channel</span>();ChannelFuture closeFuture=channel.<span class="hljs-built_in">closeFuture</span>();closeFuture.<span class="hljs-built_in">sync</span>();</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="hljs cpp"><span class="hljs-comment">// Start the server.</span>ChannelFuture future = b.<span class="hljs-built_in">bind</span>(PORT);future.<span class="hljs-built_in">sync</span>();<span class="hljs-comment">// Wait until the server socket is closed.</span>Channel channel = future.<span class="hljs-built_in">channel</span>();ChannelFuture closeFuture = channel.<span class="hljs-built_in">closeFuture</span>();closeFuture.<span class="hljs-built_in">sync</span>();</code></pre><p>特意把代码拆开，方便理解，可以看到 其实客户端和服务端 结构是差不多的，相信分析了Future 结构后，我们对上面的代码理解会更加的深刻。</p><h2 id="JDK-中的-Future"><a href="#JDK-中的-Future" class="headerlink" title="JDK 中的 Future"></a>JDK 中的 Future</h2><p>关于 Future 接口，常用的就是在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 submit 一个任务到线程池中的时候，返回的就是一个 <strong>Future</strong> 实例，通过它来获取提交的任务的执行状态和最终的执行结果。</p><p>下面是 JDK 中的 Future 接口 <code>java.util.concurrent.Future</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 取消该任务</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;    <span class="hljs-comment">// 任务是否已取消</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 任务是否已完成</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 阻塞获取任务执行结果</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;    <span class="hljs-comment">// 带超时参数的获取任务执行结果</span>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;&#125;</code></pre><p>Netty 中的 Future 接口继承了 JDK 中的 Future 接口，然后添加了一些方法：</p><h2 id="Netty-中的Future"><a href="#Netty-中的Future" class="headerlink" title="Netty 中的Future"></a>Netty 中的Future</h2><p><code>io.netty.util.concurrent.Future</code>:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">concurrent</span>.<span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-comment">// 是否成功</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuccess</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 是否可取消</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancellable</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 如果任务执行失败，这个方法返回异常信息</span>    <span class="hljs-function">Throwable <span class="hljs-title">cause</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 添加 Listener 来进行回调</span>    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">addListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; listener)</span></span>;    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">addListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt;... listeners)</span></span>;    <span class="hljs-comment">// 移除 Listener</span>    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">removeListener</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt; listener)</span></span>;    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">removeListeners</span><span class="hljs-params">(GenericFutureListener&lt;? extends Future&lt;? <span class="hljs-keyword">super</span> V&gt;&gt;... listeners)</span></span>;    <span class="hljs-comment">// 阻塞等待任务结束，如果任务失败，将“导致失败的异常”重新抛出来</span>    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-comment">// 不响应中断的 sync()</span>    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">syncUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 阻塞等待任务结束，和 sync() 功能是一样的，不过如果任务失败，它不会抛出执行过程中的异常</span>    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function">Future&lt;V&gt; <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutMillis)</span></span>;    <span class="hljs-comment">// 获取执行结果，不阻塞,如果没数据，返回 NULL。</span>    <span class="hljs-function">V <span class="hljs-title">getNow</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 取消任务执行</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;&#125;</code></pre><p>我们可以发现， Netty 的 Future 接口 扩展了 JDK 中 Future 接口，它加了 sync() 和 await() 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 们就可以了。</p><p>这里顺便说下 sync() 和 await() 的区别：sync() 内部会先调用 await() 方法，等 await() 方法返回后，会检查下<strong>这个任务是否失败</strong>，如果失败，重新将导致失败的异常抛出来，这个我们将在后面的实现类中看到。</p><h3 id="Future-体系"><a href="#Future-体系" class="headerlink" title="Future 体系"></a>Future 体系</h3><p><img src="http://img.blog.ztgreat.cn/document/netty/20190112153742.png" alt="Future 体系"></p><p>上面罗列了Future的部分结构，未全部列出来，稍后我们将分析 ChannelFuture,已经Promise。</p><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p> Future 接口的子接口 ChannelFuture，它将和 IO 操作中的 Channel 关联在一起了，用于异步处理 Channel 中的事件。</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelFuture</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-comment">// ChannelFuture 关联的 Channel</span>    <span class="hljs-function">Channel <span class="hljs-title">channel</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 覆写以下几个方法，使得它们返回值为 ChannelFuture 类型 </span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">addListener</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; listener)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">addListeners</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... listeners)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">removeListener</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; listener)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">removeListeners</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... listeners)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">syncUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelFuture <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isVoid</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>我们看到，ChannelFuture 接口相对于 Future 接口，除了将 channel 关联进来，没有增加什么东西，其他几个都是方法覆写，为了让返回值类型变为 ChannelFuture。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>接下来 我们来介绍下 Promise 接口，它和 ChannelFuture 接口无关，而是和前面的 Future 接口相关，也就是说Promise的和ChannelFuture是独立的，在js 或者 nodejs 中都有一个 Promise的概念。</p><p>Promise 这个接口其实可以算作是一个异步任务的抽象，这个我们在后面具体编程的时候，再来看。</p><p>Promise 接口和 ChannelFuture 一样，也继承了 Netty 的 Future 接口，然后加了一些 Promise 的内容：</p><pre><code class="hljs swift"><span class="hljs-keyword">public</span> interface <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; extends <span class="hljs-type">Future</span>&lt;<span class="hljs-type">V</span>&gt; &#123;    <span class="hljs-comment">// 设置 该 future 成功及设置其执行结果，然后通知所有的 listeners。</span>    <span class="hljs-comment">// 如果该操作失败，将抛出异常</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; setSuccess(<span class="hljs-type">V</span> result);    <span class="hljs-comment">// 和 setSuccess 方法一样，只不过如果失败，它不抛异常，返回 false</span>    boolean trySuccess(<span class="hljs-type">V</span> result);    <span class="hljs-comment">// 设置 该 future 失败，及其失败原因。</span>    <span class="hljs-comment">// 如果该操作失败，将抛出异常</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; setFailure(<span class="hljs-type">Throwable</span> cause);    <span class="hljs-comment">// 设置 该 future 失败，及其失败原因。</span>    <span class="hljs-comment">// 如果该操作失败，返回 false，不抛出异常</span>    boolean tryFailure(<span class="hljs-type">Throwable</span> cause);    <span class="hljs-comment">// 设置该 future 不可以被取消</span>    boolean setUncancellable();    <span class="hljs-comment">// 覆写，返回 Promise 类型的实例</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; addListener(<span class="hljs-type">GenericFutureListener</span>&lt;? extends <span class="hljs-type">Future</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">V</span>&gt;&gt; listener);    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; addListeners(<span class="hljs-type">GenericFutureListener</span>&lt;? extends <span class="hljs-type">Future</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">V</span>&gt;&gt;... listeners);    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; removeListener(<span class="hljs-type">GenericFutureListener</span>&lt;? extends <span class="hljs-type">Future</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">V</span>&gt;&gt; listener);    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; removeListeners(<span class="hljs-type">GenericFutureListener</span>&lt;? extends <span class="hljs-type">Future</span>&lt;? <span class="hljs-keyword">super</span> <span class="hljs-type">V</span>&gt;&gt;... listeners);    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; <span class="hljs-keyword">await</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; awaitUninterruptibly();    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; sync() <span class="hljs-keyword">throws</span> <span class="hljs-type">InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-type">Promise</span>&lt;<span class="hljs-type">V</span>&gt; syncUninterruptibly();&#125;</code></pre><h3 id="ChannelPromise"><a href="#ChannelPromise" class="headerlink" title="ChannelPromise"></a>ChannelPromise</h3><p>接下来，我们再来看下 <strong>ChannelPromise</strong>，它继承了前面介绍的 ChannelFuture 和 Promise 接口，这样ChannelPromise 就联系上了Chaneel了。</p><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Special &#123;<span class="hljs-doctag">@link</span> ChannelFuture&#125; which is writable.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ChannelPromise</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelFuture</span>, <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;    <span class="hljs-comment">//覆写 ChannelFuture 中的 channel() 方法</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Channel <span class="hljs-title">channel</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">//覆写，目的是为了返回值类型是 ChannelPromise</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">setSuccess</span><span class="hljs-params">(Void result)</span></span>;    <span class="hljs-function">ChannelPromise <span class="hljs-title">setSuccess</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">trySuccess</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">setFailure</span><span class="hljs-params">(Throwable cause)</span></span>;    <span class="hljs-comment">//覆写也是为了得到 ChannelPromise 类型的实例</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">addListener</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; listener)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">addListeners</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... listeners)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">removeListener</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt; listener)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">removeListeners</span><span class="hljs-params">(GenericFutureListener&lt;? <span class="hljs-keyword">extends</span> Future&lt;? <span class="hljs-keyword">super</span> Void&gt;&gt;... listeners)</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">syncUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Returns a new &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; if &#123;<span class="hljs-doctag">@link</span> #isVoid()&#125; returns &#123;<span class="hljs-doctag">@code</span> true&#125; otherwise itself.</span><span class="hljs-comment">     */</span>    <span class="hljs-function">ChannelPromise <span class="hljs-title">unvoid</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>我们可以看到，它综合了 ChannelFuture 和 Promise 中的方法，只不过通过覆写将返回值都变为 ChannelPromise 了而已，没有增加什么新的功能。</p><p>我们上面介绍了几个接口，Future 以及它的子接口 ChannelFuture 和 Promise，然后是 ChannelPromise 接口同时继承了 ChannelFuture 和 Promise。</p><p>接下来，我们需要来一个实现类，这样才能比较直观地看出它们是怎么使用的，因为上面的这些都是接口定义，具体还得看实现类是怎么工作的。</p><h3 id="DefaultPromise"><a href="#DefaultPromise" class="headerlink" title="DefaultPromise"></a><strong>DefaultPromise</strong></h3><p>下面，我们来介绍下 <strong>DefaultPromise</strong> 这个实现类，内容有点多，我们就介绍几个关键的内容。</p><p>首先，我们看下它有哪些属性：</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultPromise&lt;V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFuture&lt;V&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">Promise&lt;V&gt;</span> </span>&#123;    <span class="hljs-comment">// 任务的执行结果</span>    <span class="hljs-keyword">private</span> volatile <span class="hljs-type">Object</span> result;    <span class="hljs-comment">// 执行任务的线程池，promise 持有 executor 的引用</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EventExecutor</span> executor;    <span class="hljs-comment">// 监听者，回调函数</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> listeners;    <span class="hljs-comment">// 调用sync()/await()进行等待的线程数量</span>    <span class="hljs-keyword">private</span> short waiters;    <span class="hljs-comment">// 是否正在唤醒等待线程，用于防止重复执行唤醒，不然会重复执行 listeners 的回调方法</span>    <span class="hljs-keyword">private</span> boolean notifyingListeners;    ......&#125;</code></pre><blockquote><p>DefaultPromise 实现了 Promise，但是没有实现 ChannelFuture，所以它还没有和 Channel 联系起来。</p></blockquote><p>我们 看到 DefaultPromise 中持有了一个 线程池引用。</p><p>在 DefaultPromise  中 我们看到有如下注释：</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the executor used to notify listeners when this promise is complete.</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * It is assumed this executor will protect against &#123;<span class="hljs-doctag">@link</span> StackOverflowError&#125; exceptions.</span><span class="hljs-comment"> * The executor may be used to avoid &#123;<span class="hljs-doctag">@link</span> StackOverflowError&#125; by executing a &#123;<span class="hljs-doctag">@link</span> Runnable&#125; if the stack</span><span class="hljs-comment"> * depth exceeds a threshold.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> The executor used to notify listeners when this promise is complete.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">protected</span> EventExecutor executor() &#123;    <span class="hljs-keyword">return</span> executor;&#125;</code></pre><p>当任务执行后，会进行 <strong>Listener</strong>  的调用，而<strong>Listener</strong>  的调用逻辑 这个是不清楚的，有可能是同步的，也可能是异步的，因此用线程池去执行，这样将 <strong>回调任务</strong> 和 和 <strong>任务的执行</strong> 进行了分割。</p><p>我们来看看 DefaultPromise 中的一些方法：</p><h4 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h4><p>添加监听者（回调函数）</p><pre><code class="hljs reasonml">@Overridepublic Promise&lt;V&gt; add<span class="hljs-constructor">Listener(GenericFutureListener&lt;? <span class="hljs-params">extends</span> Future&lt;? <span class="hljs-params">super</span> V&gt;&gt; <span class="hljs-params">listener</span>)</span> &#123;    check<span class="hljs-constructor">NotNull(<span class="hljs-params">listener</span>, <span class="hljs-string">&quot;listener&quot;</span>)</span>;    <span class="hljs-comment">//同步处理</span>    synchronized (this) &#123;        add<span class="hljs-constructor">Listener0(<span class="hljs-params">listener</span>)</span>;    &#125;    <span class="hljs-comment">//添加完后，判断任务是否完成了，如果是，则需要进行通知 </span>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Done()</span>) &#123;        notify<span class="hljs-constructor">Listeners()</span>;    &#125;    return this;&#125;</code></pre><h4 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h4><p>判断任务是否执行完成了，这个判断 结果值类型就可以了，很简单。</p><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isDone</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> isDone0(result);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isDone0</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> result</span>)</span> &#123;    <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span> &amp;&amp; result != UNCANCELLABLE;&#125;</code></pre><h4 id="setSuccess"><a href="#setSuccess" class="headerlink" title="setSuccess"></a>setSuccess</h4><p>设置 该 future 成功及设置其执行结果，并且会通知所有的 listeners。</p><p>如果该操作失败，将抛出异常</p><pre><code class="hljs reasonml">@Overridepublic Promise&lt;V&gt; set<span class="hljs-constructor">Success(V <span class="hljs-params">result</span>)</span> &#123;    <span class="hljs-comment">//设置结果</span>    <span class="hljs-keyword">if</span> (set<span class="hljs-constructor">Success0(<span class="hljs-params">result</span>)</span>) &#123;        <span class="hljs-comment">// 如果设置成功，则开始进行回调处理</span>        notify<span class="hljs-constructor">Listeners()</span>;        return this;    &#125;    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalStateException(<span class="hljs-string">&quot;complete already: &quot;</span> + <span class="hljs-params">this</span>)</span>;&#125;<span class="hljs-keyword">private</span> boolean set<span class="hljs-constructor">Success0(V <span class="hljs-params">result</span>)</span> &#123;    return set<span class="hljs-constructor">Value0(<span class="hljs-params">result</span> <span class="hljs-operator">==</span> <span class="hljs-params">null</span> ? SUCCESS : <span class="hljs-params">result</span>)</span>;&#125;<span class="hljs-keyword">private</span> boolean set<span class="hljs-constructor">Value0(Object <span class="hljs-params">objResult</span>)</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RESULT_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, <span class="hljs-params">null</span>, <span class="hljs-params">objResult</span>)</span><span class="hljs-operator"> ||</span><span class="hljs-operator">        </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RESULT_UPDATER</span>.</span></span>compare<span class="hljs-constructor">AndSet(<span class="hljs-params">this</span>, UNCANCELLABLE, <span class="hljs-params">objResult</span>)</span>) &#123;        check<span class="hljs-constructor">NotifyWaiters()</span>;        return <span class="hljs-literal">true</span>;    &#125;    return <span class="hljs-literal">false</span>;&#125;</code></pre><h4 id="trySuccess"><a href="#trySuccess" class="headerlink" title="trySuccess"></a>trySuccess</h4><p>设置 该 future 成功及设置其执行结果，并且会通知所有的 listeners。</p><p>如果该操作失败，返回false，不抛出异常。</p><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">trySuccess</span>(<span class="hljs-params">V result</span>)</span> &#123;    <span class="hljs-keyword">if</span> (setSuccess0(result)) &#123;        notifyListeners();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h4 id="setFailure"><a href="#setFailure" class="headerlink" title="setFailure"></a>setFailure</h4><p>设置 该 future 失败，及其失败原因。</p><p>如果该操作失败，将抛出异常</p><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">Promise</span>&lt;V&gt; <span class="hljs-function"><span class="hljs-title">setFailure</span>(<span class="hljs-params">Throwable cause</span>)</span> &#123;    <span class="hljs-keyword">if</span> (setFailure0(cause)) &#123;        notifyListeners();        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;complete already: &quot;</span> + <span class="hljs-built_in">this</span>, cause);&#125;</code></pre><h4 id="tryFailure"><a href="#tryFailure" class="headerlink" title="tryFailure"></a>tryFailure</h4><p>设置 该 future 失败，及其失败原因。</p><p>如果该操作 失败，返回false，不抛出异常。</p><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">tryFailure</span>(<span class="hljs-params">Throwable cause</span>)</span> &#123;    <span class="hljs-keyword">if</span> (setFailure0(cause)) &#123;        notifyListeners();        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>上面几个方法都非常简单，先设置好值，然后执行监听者们的回调方法。notifyListeners() 方法感兴趣的读者也可以看一看，不过它还涉及到 Netty 线程池的一些内容，我们还没有介绍到线程池，这里就不展开了。上面的代码，在 setSuccess0 或 setFailure0 方法中都会唤醒阻塞在 sync() 或 await() 的线程</p><p>另外，就是可以看下 sync() 和 await() 的区别，其他的我觉得随便看看就好了。</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Promise&lt;V&gt; <span class="hljs-title">sync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    await();    <span class="hljs-comment">// 如果任务是失败的，重新抛出相应的异常</span>    rethrowIfFailed();    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>我们看到 sync 内部会调用await 方法，只是如果 await 执行失败，那么会再次抛出异常问题。</p><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><p>我们通过一个实例，来了解 Promise的使用，以及监听器的使用：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;   <span class="hljs-comment">// 构造线程池</span>   EventExecutor executor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DefaultEventExecutor</span>();   <span class="hljs-comment">// 创建 DefaultPromise 实例</span>   Promise promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DefaultPromise</span>(executor);   <span class="hljs-comment">// 添加 一个 listener</span>    promise.<span class="hljs-built_in">addListener</span>(<span class="hljs-keyword">new</span> GenericFutureListener&lt;Future&lt;<span class="hljs-keyword">String</span>&gt;&gt;() &#123;         @Override          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">operationComplete</span>(Future future) throws Exception &#123;                <span class="hljs-keyword">if</span> (future.<span class="hljs-built_in">isSuccess</span>()) &#123;                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;任务成功,结果：&quot;</span> + future.<span class="hljs-built_in">get</span>());                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;任务失败,异常：&quot;</span> + future.<span class="hljs-built_in">cause</span>());                &#125;           &#125;    &#125;);    <span class="hljs-comment">// 提交任务到线程池</span>    executor.<span class="hljs-built_in">submit</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Runnable</span>() &#123;         @Override          <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3000</span>);                &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;                &#125;                <span class="hljs-comment">// 设置 promise 的结果</span>                <span class="hljs-comment">// promise.setFailure(new RuntimeException());</span>                promise.<span class="hljs-built_in">setSuccess</span>(<span class="hljs-string">&quot;success&quot;</span>);           &#125;     &#125;);     <span class="hljs-comment">// 主线程线程阻塞等待执行结果</span>      <span class="hljs-keyword">try</span> &#123;           promise.<span class="hljs-built_in">sync</span>();      &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;      &#125;&#125;</code></pre><p>运行代码， 3 秒后将输出：</p><pre><code class="hljs">任务成功,结果：success</code></pre><p>这里我们也可以试一下 sync() 和 await() 的区别，开启  promise.setFailure(new RuntimeException()) 代码，同时最后调用await 方法，对比区别，这里就不展示了，读者可以自行去尝试。</p><h4 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h4><p>对比JDK 中的Future 如果我们需要获取结果，我们需要调用get 方法获取，或者通过isDone 来判断任务是否完成，这都是<strong>主动轮询</strong>的方式。</p><p>而Netty中的Future  我们 可以用 await()，等 await() 方法返回后，得到 promise 的执行结果，然后处理它；</p><p>另一种就是提供 <strong>Listener</strong> 实例，<strong>我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中我们定义的逻辑就可以了</strong>。</p><p>在 DefaultPromise 中以及 上面的代码中，我们看到promise  持有了 线程池引用，这个是为什么呢？</p><p>在 DefaultPromise  中 我们看到有如下注释：</p><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get the executor used to notify listeners when this promise is complete.</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * It is assumed this executor will protect against &#123;<span class="hljs-doctag">@link</span> StackOverflowError&#125; exceptions.</span><span class="hljs-comment"> * The executor may be used to avoid &#123;<span class="hljs-doctag">@link</span> StackOverflowError&#125; by executing a &#123;<span class="hljs-doctag">@link</span> Runnable&#125; if the stack</span><span class="hljs-comment"> * depth exceeds a threshold.</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> The executor used to notify listeners when this promise is complete.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">protected</span> EventExecutor executor() &#123;    <span class="hljs-keyword">return</span> executor;&#125;</code></pre><p>当任务执行后，会进行 <strong>Listener</strong>  的调用，而<strong>Listener</strong>  的调用逻辑 这个是不清楚的，有可能是同步的，也可能是异步的，因此用线程池去执行，这样将 <strong>回调任务</strong> 和 和 <strong>任务的执行</strong> 进行了分割。</p><h3 id="DefaultChannelPromise"><a href="#DefaultChannelPromise" class="headerlink" title="DefaultChannelPromise"></a>DefaultChannelPromise</h3><p>DefaultChannelPromise 基本上都是调用 DefaultPromise的方法 ,实现了ChannelPromise 接口，将Channle 关联了进来。</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultChannelPromise</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultPromise&lt;Void&gt;</span> <span class="hljs-title">implements</span> <span class="hljs-title">ChannelPromise</span>, <span class="hljs-title">FlushCheckpoint</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> channel;  <span class="hljs-keyword">private</span> long checkpoint;  <span class="hljs-comment">/**</span><span class="hljs-comment">  * Creates a new instance.</span><span class="hljs-comment">  *</span><span class="hljs-comment">  * @param channel</span><span class="hljs-comment">  *        the &#123;@link Channel&#125; associated with this future</span><span class="hljs-comment">  */</span>  public <span class="hljs-type">DefaultChannelPromise</span>(<span class="hljs-type">Channel</span> channel) &#123;      <span class="hljs-keyword">this</span>.channel = checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);  &#125;  <span class="hljs-comment">//... 省略其它方法</span>&#125;</code></pre><p>有了上面的认识，下面 我们回过头来再看<strong>客户端中Future</strong>的调用：</p><pre><code class="hljs arduino"><span class="hljs-comment">// Start the client.</span>ChannelFuture future = b.<span class="hljs-built_in">connect</span>(HOST, PORT);future.<span class="hljs-built_in">sync</span>();<span class="hljs-comment">// Wait until the connection is closed.</span>Channel channel= future.<span class="hljs-built_in">channel</span>();ChannelFuture closeFuture=channel.<span class="hljs-built_in">closeFuture</span>();closeFuture.<span class="hljs-built_in">sync</span>();</code></pre><p>当客户端进行 connect 后，返回了一个 Future，这个connect 是异步的，因此还不知道任务执行如何，因此这里我们调用 future的sync，等待connect 完成。</p><p>当connect 后，我们从future 中获取 Channel, 再从这个 Channle 获取一个 Future,而这个Future 是监听 Channle 是否关闭的，通过sync 方法，我们可以一直等待Channle的关闭，因此如果不进行<code>closeFuture.sync()</code>,那么主线程就会直接执行完毕，不会阻塞在最后。</p>]]></content>
    
    
    <categories>
      
      <category>Netty基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Netty基础知识-Netty深度解析</title>
    <link href="/2020/09/03/clpqt1ixx00je4cuec1wwabsi.html"/>
    <url>/2020/09/03/clpqt1ixx00je4cuec1wwabsi.html</url>
    
    <content type="html"><![CDATA[<p>Netty深度解析:在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应</p><span id="more"></span><blockquote><p>本文来源于：【<a href="https://github.com/ztgreat/blog-docs.git】">https://github.com/ztgreat/blog-docs.git】</a><br>编者仅仅做了简单排版和搬运收藏，非商业用途，最终知识版权归原作者所有。</p></blockquote><h2 id="Channel-与-ChannelPipeline"><a href="#Channel-与-ChannelPipeline" class="headerlink" title="Channel 与 ChannelPipeline"></a>Channel 与 ChannelPipeline</h2><p>相信大家都知道了, 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121175150.png" alt="ChannelPipeline"></p><p>通过上图我们可以看到, <strong>一个 Channel 包含了一个 ChannelPipeline</strong>, 而 ChannelPipeline 中又维护了一个由 <strong>ChannelHandlerContext</strong> 组成的双向链表。</p><p>这个链表的头是 HeadContext, 链表的尾是 TailContext, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler.<br>上面的图示给了我们一个对 ChannelPipeline 的直观认识, 但是实际上 Netty 实现的 Channel 是否真的是这样的呢? 我们继续用源码说话.</p><p>关于pipeline的实例化，这个我们需要回顾一下Channel的初始化过程</p><h3 id="回顾Channel-初始化"><a href="#回顾Channel-初始化" class="headerlink" title="回顾Channel 初始化"></a>回顾Channel 初始化</h3><p>下面的代码是 AbstractChannel 构造器:</p><pre><code class="hljs reasonml">protected <span class="hljs-constructor">AbstractChannel(Channel <span class="hljs-params">parent</span>)</span> &#123;    this.parent = parent;    unsafe = <span class="hljs-keyword">new</span><span class="hljs-constructor">Unsafe()</span>;    pipeline = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelPipeline(<span class="hljs-params">this</span>)</span>;&#125;</code></pre><p>AbstractChannel 有一个 pipeline 字段, 在构造器中会初始化它为 <code>DefaultChannelPipeline</code>的实例. 这里的代码就印证了一点: <code>每个 Channel 都有一个 ChannelPipeline</code>.</p><h3 id="DefaultChannelPipeline"><a href="#DefaultChannelPipeline" class="headerlink" title="DefaultChannelPipeline"></a>DefaultChannelPipeline</h3><p>接着我们跟踪一下 DefaultChannelPipeline 的初始化过程.<br>首先进入到 DefaultChannelPipeline 构造器中:</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> DefaultChannelPipeline(AbstractChannel channel) &#123;    <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>(<span class="hljs-string">&quot;channel&quot;</span>);    &#125;    <span class="hljs-built_in">this</span>.channel = channel;    tail = <span class="hljs-keyword">new</span> <span class="hljs-type">TailContext</span>(<span class="hljs-built_in">this</span>);    head = <span class="hljs-keyword">new</span> <span class="hljs-type">HeadContext</span>(<span class="hljs-built_in">this</span>);    head.next = tail;    tail.prev = head;&#125;</code></pre><p>在 DefaultChannelPipeline 构造器中, 首先将与之关联的 Channel 保存到字段 channel 中, 然后实例化两个 ChannelHandlerContext, 一个是 HeadContext 实例 head, 另一个是 TailContext 实例 tail. 接着将 head 和 tail 互相指向, 构成一个双向链表.</p><h4 id="head-handler-与taile-handler"><a href="#head-handler-与taile-handler" class="headerlink" title="head handler 与taile handler"></a>head handler 与taile handler</h4><p>我们再来看看 这个 head和tail的结构：</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190119184358.png" alt="headContext"></p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190119184541.png" alt="tailContext"></p><p>从类层次结构图中可以很清楚地看到, head 实现了 <strong>ChannelInboundHandler</strong>和 <strong>ChannelOutboundHandler</strong>, 而 tail 实现了 <strong>ChannelInboundHandler</strong>接口, 并且它们都实现了 <strong>ChannelHandlerContext</strong> 接口, 因此可以说 <strong>head 和 tail 即是一个 ChannelHandler, 又是一个 ChannelHandlerContext.</strong></p><p>接着看一下 HeadContext 和 TailContext的构造器:</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">HeadContext</span>(<span class="hljs-params">DefaultChannelPipeline pipeline</span>)</span> &#123;    <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, HEAD_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);    unsafe = pipeline.channel().unsafe();    setAddComplete();&#125;<span class="hljs-function"><span class="hljs-title">TailContext</span>(<span class="hljs-params">DefaultChannelPipeline pipeline</span>)</span> &#123;    <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, TAIL_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);    setAddComplete();&#125;</code></pre><p>它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = true, outbound = true.<br>TailContext 它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = true, outbound = false.<br><strong>即 header 既是一个 outboundHandler又是一个inboundHandler , 而 tail 只是一个inboundHandler</strong>。</p><h3 id="ChannelInitializer-的添加"><a href="#ChannelInitializer-的添加" class="headerlink" title="ChannelInitializer 的添加"></a>ChannelInitializer 的添加</h3><p>我们已经分析了 Channel 的组成, 其中我们了解到, 最开始的时候 ChannelPipeline 中含有两个 ChannelHandlerContext(同时也是 ChannelHandler), 但是这个 Pipeline并不能实现什么特殊的功能, 因为我们还没有给它添加自定义的 ChannelHandler.<br>通常来说, 我们在初始化 Bootstrap, 会添加我们自定义的 ChannelHandler, 就以我们熟悉的 EchoClient 来举例吧:</p><pre><code class="hljs pgsql">Bootstrap b = <span class="hljs-built_in">new</span> Bootstrap();b.<span class="hljs-keyword">group</span>(<span class="hljs-keyword">group</span>) .channel(NioSocketChannel.<span class="hljs-keyword">class</span>) .<span class="hljs-keyword">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>) .<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;     @Override     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;         ChannelPipeline p = ch.pipeline();         p.addLast(<span class="hljs-built_in">new</span> EchoClientHandler());     &#125; &#125;);</code></pre><p>上面代码的初始化过程, 相信大家都不陌生. 在调用 handler 时, 传入了 ChannelInitializer 对象, 它提供了一个 initChannel 方法供我们初始化 ChannelHandler. 那么这个初始化过程是怎样的呢? 下面我们就来揭开它的神秘面纱.</p><p>ChannelInitializer 实现了 ChannelHandler, 那么它是在什么时候添加到 ChannelPipeline 中的呢? 进行了一番搜索后, 我们发现它是在 Bootstrap.init 方法中添加到 ChannelPipeline 中的.<br>其代码如下:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ChannelPipeline p = channel.pipeline();    p.addLast(config.<span class="hljs-keyword">handler</span>());    ...&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">ChannelHandler <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> bootstrap.<span class="hljs-title">handler</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">final</span> <span class="hljs-function">ChannelHandler <span class="hljs-title">handler</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span>;&#125;</code></pre><p>上面的代码将 handler() 返回的 ChannelHandler 添加到 Pipeline 中, 而 handler() 返回的是handler 其实就是我们在初始化 Bootstrap 调用 handler 设置的 ChannelInitializer 实例, 因此这里就是将 ChannelInitializer 插入到了 Pipeline 的末端.<br>此时 Pipeline 的结构如下图所示:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184340.png" alt="ChannelPipline"></p><p>有朋友可能就有疑惑了, 我明明插入的是一个 ChannelInitializer 实例, 为什么在 ChannelPipeline 中的双向链表中的元素却是一个 ChannelHandlerContext? 为了解答这个问题, 我们继续在代码中寻找答案吧.<br>我们刚才提到, 在 Bootstrap.init 中会调用 p.addLast() 方法, 将 ChannelInitializer 插入到链表末端:</p><pre><code class="hljs reasonml">@Overridepublic ChannelPipeline add<span class="hljs-constructor">Last(EventExecutorGroup <span class="hljs-params">group</span>, <span class="hljs-params">final</span> String <span class="hljs-params">name</span>, ChannelHandler <span class="hljs-params">handler</span>)</span> &#123;    synchronized (this) &#123;        check<span class="hljs-constructor">DuplicateName(<span class="hljs-params">name</span>)</span>; <span class="hljs-comment">// 检查此 handler 是否有重复的名字</span>        AbstractChannelHandlerContext newCtx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DefaultChannelHandlerContext(<span class="hljs-params">this</span>, <span class="hljs-params">group</span>, <span class="hljs-params">name</span>, <span class="hljs-params">handler</span>)</span>;        add<span class="hljs-constructor">Last0(<span class="hljs-params">name</span>, <span class="hljs-params">newCtx</span>)</span>;    &#125;    return this;&#125;</code></pre><p>addLast 有很多重载的方法, 我们关注这个比较重要的方法就可以了.<br>上面的 addLast 方法中, 首先检查这个 ChannelHandler 的名字是否是重复的, 如果不重复的话, 则为这个 Handler 创建一个对应的 DefaultChannelHandlerContext 实例, 并与之关联起来(Context 中有一个 handler 属性保存着对应的 Handler 实例). 判断此 Handler 是否重名的方法很简单: Netty 中有一个 <strong>name2ctx</strong> Map 字段, key 是 handler 的名字, 而 value 则是 handler 本身. 因此通过如下代码就可以判断一个 handler 是否重名了:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void check<span class="hljs-constructor">DuplicateName(String <span class="hljs-params">name</span>)</span> &#123;    <span class="hljs-keyword">if</span> (name2ctx.contains<span class="hljs-constructor">Key(<span class="hljs-params">name</span>)</span>) &#123;        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalArgumentException(<span class="hljs-string">&quot;Duplicate handler name: &quot;</span> + <span class="hljs-params">name</span>)</span>;    &#125;&#125;</code></pre><p>为了添加一个 handler 到 pipeline 中, 必须<strong>把此 handler 包装成 ChannelHandlerContext</strong>. 因此在上面的代码中我们可以看到新实例化了一个 newCtx 对象, 并将 handler 作为参数传递到构造方法中. 那么我们来看一下实例化的 DefaultChannelHandlerContext 到底有什么玄机吧.<br>首先看它的构造器:</p><pre><code class="hljs pgsql">DefaultChannelHandlerContext(        DefaultChannelPipeline pipeline, EventExecutorGroup <span class="hljs-keyword">group</span>, String <span class="hljs-type">name</span>, ChannelHandler <span class="hljs-keyword">handler</span>) &#123;    super(pipeline, <span class="hljs-keyword">group</span>, <span class="hljs-type">name</span>, isInbound(<span class="hljs-keyword">handler</span>), isOutbound(<span class="hljs-keyword">handler</span>));    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>) &#123;        throw <span class="hljs-built_in">new</span> NullPointerException(&quot;handler&quot;);    &#125;    this.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;&#125;</code></pre><p>DefaultChannelHandlerContext 的构造器中, 调用了两个很有意思的方法: <strong>isInbound</strong> 与 <strong>isOutbound</strong>, 这两个方法是做什么的呢?</p><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInbound</span><span class="hljs-params">(ChannelHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span> <span class="hljs-keyword">instanceof</span> ChannelInboundHandler;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isOutbound</span><span class="hljs-params">(ChannelHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">handler</span> <span class="hljs-keyword">instanceof</span> ChannelOutboundHandler;&#125;</code></pre><p>从源码中可以看到, 当一个 handler 实现了 ChannelInboundHandler 接口, 则 isInbound 返回真; 相似地, 当一个 handler 实现了 ChannelOutboundHandler 接口, 则 isOutbound 就返回真.<br>而这两个 boolean 变量会传递到父类 AbstractChannelHandlerContext 中, 并初始化父类的两个字段: <strong>inbound</strong> 与 <strong>outbound</strong>.<br>那么这里的 ChannelInitializer 所对应的 DefaultChannelHandlerContext 的 inbound 与 inbound 字段分别是什么呢? 那就看一下 ChannelInitializer 到底实现了哪个接口不就行了? 如下是 ChannelInitializer 的类层次结构图:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184503.png" alt="ChannelInitializer"></p><p>可以清楚地看到, <strong>ChannelInitializer 仅仅实现了 ChannelInboundHandler 接口</strong>, 因此这里实例化的 DefaultChannelHandlerContext 的 inbound = true, outbound = false.<br>不就是 inbound 和 outbound 两个字段嘛, 为什么需要这么大费周章地分析一番? 其实这两个字段关系到 pipeline 的事件的流向与分类, 因此是十分关键的。</p><p>当创建好 Context 后, 就将这个 Context 插入到 Pipeline 的双向链表中:</p><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void addLast0(final <span class="hljs-keyword">String</span> name, AbstractChannelHandlerContext <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>) &#123;    checkMultiplicity(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);    AbstractChannelHandlerContext prev = tail.prev;    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.prev = prev;    <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>.next = tail;    prev.next = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;    tail.prev = <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>;    name2ctx.put(name, <span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);    callHandlerAdded(<span class="hljs-keyword">new</span><span class="hljs-type">Ctx</span>);&#125;</code></pre><p>显然, 这个代码就是典型的双向链表的插入操作了. 当调用了 addLast 方法后, Netty 就会将此 handler 添加到双向链表中 tail 元素之前的位置.</p><h3 id="自定义-ChannelHandler-的添加过程"><a href="#自定义-ChannelHandler-的添加过程" class="headerlink" title="自定义 ChannelHandler 的添加过程"></a>自定义 ChannelHandler 的添加过程</h3><p>接下来就来探讨一下 ChannelInitializer 在哪里被调用, ChannelInitializer 的作用, 以及我们自定义的 ChannelHandler 是如何插入到 Pipeline 中的.</p><pre><code class="hljs pgsql">Bootstrap b = <span class="hljs-built_in">new</span> Bootstrap();b.<span class="hljs-keyword">group</span>(<span class="hljs-keyword">group</span>) .channel(NioSocketChannel.<span class="hljs-keyword">class</span>) .<span class="hljs-keyword">option</span>(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>) .<span class="hljs-keyword">handler</span>(<span class="hljs-built_in">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;     @Override     <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> initChannel(SocketChannel ch) throws <span class="hljs-keyword">Exception</span> &#123;         ChannelPipeline p = ch.pipeline();         p.addLast(<span class="hljs-built_in">new</span> EchoClientHandler());     &#125; &#125;);</code></pre><p>最简单的方式便是在 initChannel 方法中设置断点，然后查看调用栈，这样方式可以很快的找到切入点，对于我不是很熟悉的框架，我个人便是采用的这种方式，下面是一个调用栈，这个可以自己尝试一下：</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190119190129.png" alt="20190119190129"></p><p>先不管在什么时候调用，我们知道会先调用 ChannelInitializer 中的 一个 initChannel</p><h4 id="initChannel"><a href="#initChannel" class="headerlink" title="initChannel"></a>initChannel</h4><p>ChannelInitializer -&gt; initChannel：</p><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Guard against re-entrance.</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//调用我们自定义的handler 添加方法</span>            initChannel((C) ctx.channel());        &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;            exceptionCaught(ctx, cause);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//注意这里</span>            remove(ctx);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;     <span class="hljs-keyword">try</span> &#123;         ChannelPipeline pipeline = ctx.pipeline();         <span class="hljs-keyword">if</span> (pipeline.context(<span class="hljs-keyword">this</span>) != <span class="hljs-keyword">null</span>) &#123;             <span class="hljs-comment">//从pipeline 中删除 该 Context</span>             pipeline.remove(<span class="hljs-keyword">this</span>);          &#125;      &#125; <span class="hljs-keyword">finally</span> &#123;         initMap.remove(ctx);      &#125;&#125;</code></pre><p>initChannel 方法内容会调用 我们另一个 initChannel 方法（重载），而这个方法就是用户端实现的handler 添加逻辑，也就是我们在初始化 Bootstrap 时, 调用 handler 方法传入的匿名内部类所实现的方法:</p><pre><code class="hljs aspectj">.<span class="hljs-keyword">handler</span>(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;     <span class="hljs-meta">@Override</span>     <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;         ChannelPipeline p = ch.pipeline();         p.addLast(<span class="hljs-keyword">new</span> EchoClientHandler());     &#125; &#125;);</code></pre><p>因此当调用了这个方法后, 我们自定义的 ChannelHandler 就插入到 Pipeline 了, 此时的 Pipeline 如下图所示:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121195152.png" alt="ChannelPipeline"></p><h4 id="ChannelInitializer的移除"><a href="#ChannelInitializer的移除" class="headerlink" title="ChannelInitializer的移除"></a>ChannelInitializer的移除</h4><p>当添加了自定义的 ChannelHandler 后, <strong>会删除 ChannelInitializer 这个 ChannelHandler</strong>, 即 “ctx.pipeline().remove(this)”, 因此最后的 Pipeline 如下:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121193057.png" alt="ChannelPipeline"></p><p>好了, 到了这里, 我们的 <strong>自定义 ChannelHandler 的添加过程</strong> 也分析的查不多了.</p><h2 id="Pipeline-的事件传输机制"><a href="#Pipeline-的事件传输机制" class="headerlink" title="Pipeline 的事件传输机制"></a>Pipeline 的事件传输机制</h2><p>从前面我们知道 AbstractChannelHandlerContext 中有 inbound 和 outbound 两个 boolean 变量, 分别用于标识 Context 所对应的 handler 的类型, 即:</p><ul><li>inbound 为真时, 表示对应的 ChannelHandler 实现了 ChannelInboundHandler 方法.</li><li>outbound 为真时, 表示对应的 ChannelHandler 实现了 ChannelOutboundHandler 方法.</li></ul><p>读者朋友肯定很疑惑了吧: 那究竟这两个字段有什么作用呢? 其实这还要从 ChannelPipeline 的传输的事件类型说起.<br><strong>Netty 的事件可以分为 Inbound 和 Outbound 事件.</strong></p><p>如下是从 Netty 官网上拷贝的一个图示:</p><pre><code class="hljs gherkin">                          I/O Request                         via Channel or                         ChannelHandlerContext                                |<span class="hljs-string"></span><span class="hljs-string">+---------------------------------------------------+---------------+</span><span class="hljs-string"></span>|<span class="hljs-string">                           ChannelPipeline         </span>|<span class="hljs-string">               </span>||<span class="hljs-string">                                                  \</span>|<span class="hljs-string">/              </span>||<span class="hljs-string">    +---------------------+            +-----------+----------+    </span>||<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  N  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  1  </span>|<span class="hljs-string">    </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>||<span class="hljs-string">               </span>|<span class="hljs-string">                                  \</span>|<span class="hljs-string">/              </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler N-1 </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  2  </span>|<span class="hljs-string">    </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  .               </span>||<span class="hljs-string">               .                                   .               </span>||<span class="hljs-string"> ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()</span>||<span class="hljs-string">        [ method call]                       [method call]         </span>||<span class="hljs-string">               .                                   .               </span>||<span class="hljs-string">               .                                  \</span>|<span class="hljs-string">/              </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  2  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler M-1 </span>|<span class="hljs-string">    </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>||<span class="hljs-string">               </span>|<span class="hljs-string">                                  \</span>|<span class="hljs-string">/              </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">    </span>|<span class="hljs-string"> Inbound Handler  1  </span>|<span class="hljs-string">            </span>|<span class="hljs-string"> Outbound Handler  M  </span>|<span class="hljs-string">    </span>||<span class="hljs-string">    +----------+----------+            +-----------+----------+    </span>||<span class="hljs-string">              /</span>|<span class="hljs-string">\                                  </span>|<span class="hljs-string">               </span>|+---------------+-----------------------------------+---------------+              |<span class="hljs-string">                                  \</span>|<span class="hljs-string">/</span><span class="hljs-string">+---------------+-----------------------------------+---------------+</span><span class="hljs-string"></span>|<span class="hljs-string">               </span>|<span class="hljs-string">                                   </span>|<span class="hljs-string">               </span>||<span class="hljs-string">       [ Socket.read() ]                    [ Socket.write() ]     </span>||<span class="hljs-string">                                                                   </span>||<span class="hljs-string">  Netty Internal I/O Threads (Transport Implementation)            </span>|+-------------------------------------------------------------------+</code></pre><p>从上图可以看出, inbound 事件和 outbound 事件的流向是不一样的:</p><ul><li>inbound 事件的流行是从下至上</li><li>outbound 事件的流行 是从上到下</li></ul><p>inbound 的传递方式是通过调用相应的 <strong>ChannelHandlerContext.fireIN_EVT()</strong> 方法。</p><p> outbound 方法的的传递方式是通过调用 <strong>ChannelHandlerContext.OUT_EVT()</strong> 方法. </p><p>例如 <strong>ChannelHandlerContext.fireChannelRegistered()</strong> 调用会发送一个 <strong>ChannelRegistered</strong> 的 inbound 给下一个ChannelHandlerContext, 而 <strong>ChannelHandlerContext.bind</strong> 调用会发送一个 <strong>bind</strong> 的 outbound 事件给 下一个 ChannelHandlerContext.</p><p>Inbound 事件传播方法有:</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelRegistered()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelActive()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelRead(Object)</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelReadComplete()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ExceptionCaught(Throwable)</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">UserEventTriggered(Object)</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelWritabilityChanged()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelInactive()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>fire<span class="hljs-constructor">ChannelUnregistered()</span></code></pre><p>Oubound 事件传输方法有:</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>bind(SocketAddress, ChannelPromise)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>connect(SocketAddress, SocketAddress, ChannelPromise)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>write(Object, ChannelPromise)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>flush<span class="hljs-literal">()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>read<span class="hljs-literal">()</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>disconnect(ChannelPromise)<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChannelHandlerContext</span>.</span></span>close(ChannelPromise)</code></pre><p><code>注意, 如果我们捕获了一个事件, 并且想让这个事件继续传递下去, 那么需要调用 Context 相应的传播方法.</code><br>例如:</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public void channelActive(<span class="hljs-type">ChannelHandlerContext</span> ctx) &#123;        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Connected!&quot;</span>);        ctx.fireChannelActive();    &#125;&#125;public clas <span class="hljs-type">MyOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">ChannelOutboundHandlerAdapter</span> &#123;    <span class="hljs-meta">@Override</span>    public void close(<span class="hljs-type">ChannelHandlerContext</span> ctx, <span class="hljs-type">ChannelPromise</span> promise) &#123;        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Closing ..&quot;</span>);        ctx.close(promise);    &#125;&#125;</code></pre><p>上面的例子中, MyInboundHandler 收到了一个 channelActive 事件, 它在处理后, 如果希望将事件继续传播下去, 那么需要接着调用 ctx.fireChannelActive().</p><h3 id="Outbound-操作"><a href="#Outbound-操作" class="headerlink" title="Outbound 操作"></a>Outbound 操作</h3><p><code>Outbound 事件都是请求事件(request event)</code>, 即请求某件事情的发生, 然后通过 Outbound 事件进行通知.<br>Outbound 事件的传播方向是 tail -&gt; customContext -&gt; head.</p><h4 id="connect-事件传播"><a href="#connect-事件传播" class="headerlink" title="connect 事件传播"></a>connect 事件传播</h4><p>我们接下来以 connect 事件为例, 分析一下 Outbound 事件的传播机制.<br>首先, 当用户调用了 Bootstrap.connect 方法时, 就会触发一个 <strong>Connect 请求事件</strong>, 此调用会触发如下调用链:</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bootstrap</span>.</span></span>connect -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bootstrap</span>.</span></span>doConnect  -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractChannel</span>.</span></span>connect</code></pre><p>继续跟踪的话, 我们就发现, AbstractChannel.connect 其实由调用了 DefaultChannelPipeline.connect 方法:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> pipeline.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, promise)</span></span>;&#125;</code></pre><p>而 pipeline.connect 的实现如下:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function">ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> tail.<span class="hljs-title">connect</span><span class="hljs-params">(remoteAddress, promise)</span></span>;&#125;</code></pre><p>可以看到, 当 outbound 事件(这里是 connect 事件)传递到 Pipeline 后, 它其实是以 tail 为起点开始传播的.<br>而 tail.connect 其实调用的是 AbstractChannelHandlerContext.connect 方法:</p><pre><code class="hljs axapta">@Override<span class="hljs-keyword">public</span> ChannelFuture connect(        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise) &#123;    ...    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextOutbound();    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();    ...    <span class="hljs-keyword">next</span>.invokeConnect(remoteAddress, localAddress, promise);    ...    <span class="hljs-keyword">return</span> promise;&#125;</code></pre><p>findContextOutbound() 顾名思义, 它的作用是以当前 Context 为起点, 向 Pipeline 中的 Context 双向链表的前端寻找第一个 <strong>outbound</strong> 属性为真的 Context(即关联着 ChannelOutboundHandler 的 Context), 然后返回.<br>它的实现如下:</p><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext findContextOutbound() &#123;    AbstractChannelHandlerContext ctx = <span class="hljs-keyword">this</span>;    <span class="hljs-keyword">do</span> &#123;        ctx = ctx.prev;    &#125; <span class="hljs-keyword">while</span> (!ctx.outbound);    <span class="hljs-keyword">return</span> ctx;&#125;</code></pre><p>当我们找到了一个 outbound 的 Context 后, 就调用它的 invokeConnect 方法, 这个方法中会调用 Context 所关联着的 ChannelHandler 的 connect 方法:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void invoke<span class="hljs-constructor">Connect(SocketAddress <span class="hljs-params">remoteAddress</span>, SocketAddress <span class="hljs-params">localAddress</span>, ChannelPromise <span class="hljs-params">promise</span>)</span> &#123;    <span class="hljs-keyword">try</span> &#123;        ((ChannelOutboundHandler) handler<span class="hljs-literal">()</span>).connect(this, remoteAddress, localAddress, promise);    &#125; catch (Throwable t) &#123;        notify<span class="hljs-constructor">OutboundHandlerException(<span class="hljs-params">t</span>, <span class="hljs-params">promise</span>)</span>;    &#125;&#125;</code></pre><p>如果用户没有重写 ChannelHandler 的 connect 方法, 那么会调用 ChannelOutboundHandlerAdapter 所实现的方法:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><span class="hljs-params"><span class="hljs-function">        SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ctx.connect(remoteAddress, localAddress, promise);&#125;</code></pre><p>我们看到, ChannelOutboundHandlerAdapter.connect 仅仅调用了 ctx.connect, 而这个调用又回到了:</p><pre><code class="hljs xl">C<span class="hljs-function"><span class="hljs-title">ontext</span>.connect -&gt;</span> C<span class="hljs-function"><span class="hljs-title">onnect</span>.findContextOutbound -&gt;</span> <span class="hljs-function"><span class="hljs-title">next</span>.invokeConnect -&gt;</span> <span class="hljs-function"><span class="hljs-title">handler</span>.connect -&gt;</span> Context.connect</code></pre><p>这样的循环中, 直到 connect 事件传递到DefaultChannelPipeline 的双向链表的头节点, 即 head 中. 为什么会传递到 head 中呢? 回想一下, head 实现了 ChannelOutboundHandler, 因此它的 outbound 属性是 true.<br><code>因为 head 本身既是一个 ChannelHandlerContext, 又实现了 ChannelOutboundHandler 接口</code>, 因此当 connect 消息传递到 head 后, 会将消息转递到对应的 ChannelHandler 中处理, 而恰好, head 的 handler() 返回的就是 head 本身:</p><p><code>HeadContext</code>-&gt;<code>handler</code></p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> ChannelHandler handler() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>因此最终 connect 事件是在 head 中处理的. head 的 connect 事件处理方法如下:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">        ChannelHandlerContext ctx,</span></span><span class="hljs-params"><span class="hljs-function">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span><span class="hljs-params"><span class="hljs-function">        ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    unsafe.connect(remoteAddress, localAddress, promise);&#125;</code></pre><p>到这里, 整个 Connect 请求事件就结束了.<br>下面以一幅图来描述一个整个 Connect 请求事件的处理过程:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184504.png" alt="ChannelPipeline"></p><p>我们仅仅以 Connect 请求事件为例, 分析了 Outbound 事件的传播过程, 但是其实所有的 outbound 的事件传播都遵循着一样的传播规律, 读者可以试着分析一下其他的 outbound 事件, 体会一下它们的传播过程.</p><h3 id="Inbound-事件"><a href="#Inbound-事件" class="headerlink" title="Inbound 事件"></a>Inbound 事件</h3><p>Inbound 事件和 Outbound 事件的处理过程有点镜像.<br><code>Inbound 事件是一个通知事件</code>, 即某件事已经发生了, 然后通过 Inbound 事件进行通知. Inbound 通常发生在 Channel 的状态的改变或 IO 事件就绪.<br>Inbound 的特点是它传播方向是 head -&gt; customContext -&gt; tail.</p><p>既然上面我们分析了 Connect 这个 Outbound 事件, 那么接着分析 Connect 事件后会发生什么 Inbound 事件, 并最终找到 Outbound 和 Inbound 事件之间的联系.</p><h4 id="ChannelActive-事件传播"><a href="#ChannelActive-事件传播" class="headerlink" title="ChannelActive 事件传播"></a>ChannelActive 事件传播</h4><p>当 Connect 这个 Outbound 传播到 unsafe 后, 其实是在 AbstractNioUnsafe.connect 方法中进行处理的:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> </span>&#123;    ...    <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;        fulfillConnectPromise(promise, wasActive);    &#125; <span class="hljs-keyword">else</span> &#123;        ...    &#125;    ...&#125;</code></pre><p>在 AbstractNioUnsafe.connect 中, 首先调用 doConnect 方法进行实际上的 Socket 连接, 当连接上后, 会调用 fulfillConnectPromise 方法:</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void fulfill<span class="hljs-constructor">ConnectPromise(ChannelPromise <span class="hljs-params">promise</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">wasActive</span>)</span> &#123;<span class="hljs-operator"></span><span class="hljs-operator">    ...</span><span class="hljs-operator">    </span><span class="hljs-comment">// Regardless if the connection attempt was cancelled, channelActive() event should be triggered,</span>    <span class="hljs-comment">// because what happened is what happened.</span>    <span class="hljs-keyword">if</span> (!wasActive<span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">Active()</span>) &#123;        pipeline<span class="hljs-literal">()</span>.fire<span class="hljs-constructor">ChannelActive()</span>;    &#125;<span class="hljs-operator"></span><span class="hljs-operator">    ...</span><span class="hljs-operator"></span>&#125;</code></pre><p>我们看到, 在 fulfillConnectPromise 中, 会通过调用 pipeline().fireChannelActive() 将通道激活的消息(即 Socket 连接成功)发送出去.<br><code>而这里, 当调用 pipeline.fireXXX 后, 就是 Inbound 事件的起点.</code><br>因此当调用了 pipeline().fireChannelActive() 后, 就产生了一个 ChannelActive Inbound 事件, 我们就从这里开始看看这个 Inbound 事件是怎么传播的吧.</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline fireChannelActive() &#123;AbstractChannelHandlerContext.invokeChannelActive(head);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>继续看看里面在干什么？（<strong>注意这里传入了head</strong>）</p><pre><code class="hljs axapta">@Override<span class="hljs-keyword">public</span> ChannelHandlerContext fireChannelActive() &#123;    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext <span class="hljs-keyword">next</span> = findContextInbound();    EventExecutor executor = <span class="hljs-keyword">next</span>.executor();    ...    <span class="hljs-keyword">next</span>.invokeChannelActive();    ...    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>这个方法和 Outbound 的对应方法(例如 invokeConnect) 如出一辙. </p><p>invokeChannelActive 方法如下:</p><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invokeChannelActive</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        ((ChannelInboundHandler) <span class="hljs-keyword">handler</span>()).channelActive(<span class="hljs-keyword">this</span>);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        notifyHandlerException(t);    &#125;&#125;</code></pre><p>同 Outbound 一样, 如果用户没有重写 channelActive 方法, 那么会调用 ChannelInboundHandler 的 channelActive 方法:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ctx.fireChannelActive();    readIfIsAutoRead();&#125;</code></pre><p>哈哈, 果然, 调用的是 fireChannelActive() 方法, <code>因此可以证明了, Inbound 事件在 Pipeline 中传输的起点是 head.</code></p><p>同理, tail 本身 实现了 <strong>ChannelInboundHandler</strong> 接口, 因此当 channelActive 消息传递到 tail 后, 会将消息转递到对应的 ChannelHandler 中处理, 而恰好, tail 的 handler() 返回的就是 tail 本身:</p><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> ChannelHandler handler() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>因此 channelActive Inbound 事件最终是在 tail 中处理的, 我们看一下它的处理方法:</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;onUnhandledInboundChannelActive();&#125;<span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundChannelActive</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><p>TailContext.channelActive  会调用onUnhandledInboundChannelActive()方法 . 默认情况下 它的实现都是空的. 可见, 如果是 Inbound, 当用户没有实现自定义的处理器时, 那么默认是不处理的.</p><p>用一幅图来总结一下 Inbound 的传输过程吧:</p><p><img src="http://img.blog.ztgreat.cn/document/netty/20190121184505.png" alt="ChannelPipeline"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 Outbound事件:</p><ul><li>Outbound 事件是请求事件(由 Connect 发起一个请求, 并最终由 unsafe 处理这个请求)</li><li>Outbound 事件的发起者是 Channel</li><li>Outbound 事件的处理者是 unsafe</li><li>Outbound 事件在 Pipeline 中的传输方向是 tail -&gt; head.</li><li>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Hnalder, 则需要调用 ctx.xxx (例如 ctx.connect) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</li><li>Outbound 事件流: Context.OUT_EVT -&gt; Connect.findContextOutbound -&gt; nextContext.invokeOUT_EVT -&gt; nextHandler.OUT_EVT -&gt; nextContext.OUT_EVT</li></ul><p>对于 Inbound 事件:</p><ul><li>Inbound 事件是通知事件, 当某件事情已经就绪后, 通知上层.</li><li>Inbound 事件发起者是 unsafe</li><li>Inbound 事件的处理者是 Channel, 如果用户没有实现自定义的处理方法, 那么Inbound 事件默认的处理者是 TailContext, 并且其处理方法是空实现.</li><li>Inbound 事件在 Pipeline 中传输方向是 head -&gt; tail</li><li>在 ChannelHandler 中处理事件时, 如果这个 Handler 不是最后一个 Hnalder, 则需要调用 ctx.fireIN_EVT (例如 ctx.fireChannelActive) 将此事件继续传播下去. 如果不这样做, 那么此事件的传播会提前终止.</li><li>Outbound 事件流: Context.fireIN_EVT -&gt; Connect.findContextInbound -&gt; nextContext.invokeIN_EVT -&gt; nextHandler.IN_EVT -&gt; nextContext.fireIN_EVT</li></ul><p>outbound 和 inbound 事件十分的镜像, 并且 Context 与 Handler 直接的调用关系是否容易混淆, 因此读者在阅读这里的源码时, 需要特别的注意.</p>]]></content>
    
    
    <categories>
      
      <category>Netty基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在闽回忆录</title>
    <link href="/2020/08/13/clpqt1ivj006w4cue5pkzelfz.html"/>
    <url>/2020/08/13/clpqt1ivj006w4cue5pkzelfz.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：在福建6年回忆。</p><span id="more"></span><p>这是我之前写的一篇回忆记录文，Hexo可以直接显示PDF，于是直接挂上来了。<br><object data="/pdf/zaimin.pdf" type="application/pdf" width="100%" height="877px"></p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远离垃圾人群</title>
    <link href="/2020/07/16/clpqt1ivf006f4cuehmdq6k2z.html"/>
    <url>/2020/07/16/clpqt1ivf006f4cuehmdq6k2z.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：分享一下刚毕业被一家垃圾公司坑的经历</p><span id="more"></span><blockquote><p>想起大学刚毕业被一群骗子骗的经历，历历在目，成为我职业生涯中难忘的一课。</p></blockquote><hr><p>我2018年8.27号入职那家公司的，至11-19号辞职。</p><p>在此期间我认真工作，完成他们的任务，而且他们公司唯一一个能上线的项目还是我做的，(所有同事作证)期间有加班到临晨，还有周末强制加班，没有任何补偿。在整个九月一个月，我几乎没有按时回过家几次，全部在加班做他们的项目。他们的项目没有任何需求，全靠我们下面的人自己猜着做，因为没有需求，所以做起来非常慢，甚至公司负责人说“先摸索着做”这样的话（我有同事可以作证）。管理者经常侮辱员工，经常说垃圾，傻逼，**都是垃圾这种话（我有同事可以作证），因此我干的不愉快。</p><p>在此期间，这个公司前前后后被开除了30多人，他们打着招聘的名义让人来维护以前的烂尾项目，交付给客户以后收钱，然后把人赶走，开除了事，没有任何补偿。去大学招聘，Offer都发了却通知：你们不用来了。在达内等培训机构招了一批人，玩了几周全部被赶走了，和赶走狗一样。 所谓的技术主管，也是个嘴炮，其实什么都不会，喷子技术天下无敌，所有人，所有技术都被喷:<p style = "color:red">号称三天精通C++，网吧一小时写编译器，一秒写5行代码（笑死我了），说阿里巴巴是个垃圾公司，科大讯飞是个垃圾公司。Java是垃圾，C++是垃圾，精通Intel汇编，还说360花10W一月求着他去上班。腾讯求他写代码，都不去。但是又说只有kotlin才是天下无敌(因为我们没人会，他其实不会写代码，还没上完高中）。然后不知道哪里找了个写的非常垃圾的框架（其实就是个工具集合，然后所有依赖都打包进去，大概有70M，说是自己写的，没错，他说org.json这个项目是他写的，我只能用666来形容），逼着公司的员工”学习”，说实话我们每一个接触的人都觉得那是个垃圾工具，都不想用，其实他自己都说是垃圾，就是想在员工面前装逼，之前有个架构师带我的，他也被恶心走了。所有不服从他的员工全部被威胁开除。</p></p><p>转眼十一月了，好几个同事全部被开除了，我自己也被骂傻逼垃圾，我心里不舒服，于是再三思考决定辞职，然后我在11-11号提出辞职，但是被驳回，理由是：我必须要给公司招聘接班人。当时几个比我技术好的同事全部被无故开除了，因此一时半会找不到接班人，他们不允许我辞职。晚上还打电话说我必须要介绍人才能走。我按照他们的要求，在他们的平台上把资料，源代码，甚至还写了几个文档（这些文档我还有保存，全部是证据），全部给他提交了，移交给他们新来的同事阮XX（此人我还有联系方式，可以作证）。期间没有做任何对他们公司有害的事情。直到11-19号，公司负责人突然给我打电话说X总说了我可以走了，让后在钉钉上给我审批离职（人事可以给我作证）。但是工资没有结算，说是下个月也就是12-15号领取工资，我的工资是4000RMB，当时我就同意了。</p><p>到了十二月以后，临近发工资的日子，该公司突然又给我打电话，说是没人负责我自己的那个项目，要我继续帮助他们完成几个新需求，不然就“吊销你的毕业证”“把你送进监狱”“让你陪几十万”“我们只手遮天”这种恐吓的话，威胁我继续帮他们处理事情。还说我写的代码不见了，没有提交。其实是我离职以后，他们操作不当把我的账户删除了，然后嫁祸于我说是我没有给他们上传代码。我当时处于责任，把我自己的硬盘恢复起来了，帮他们找到了离职的时候删除的代码。我的代码用git版本管理，从2018-9月开始，每一次都有记录，我有证据证明我期间都有提交，我的同事，我的实习生也可以作证。我把代码恢复了以后还继续威胁我说要配合他们继续工作，不然就报警。</p><p>当时我畏惧，于是继续帮他们处理，配合一个实习生和XX的员工（他们全部可以给我作证）。然后过了两天，每天给我打电话让我去处理问题，我已经在新公司工作一个月了，还是强烈态度要求我“必须负责”，处于责任和畏惧，我继续给他们协助。然后相关负责人跟我说，15号去领工资，但是到15号又说是16号。16号那天我去了，负责人见到我，先给我下马威说是我给公司造成了损失，什么领导看了我的项目以后大发雷霆，我给公司造成了很严重的后果，我问什么问题，他说有两个需求没有实现（这个需求是当时新来的同事负责的，但是被开除了，所以没有做）。因为我的过失，有可能要把我送进监狱，还有扬言给我女朋友、老师 、学校发通知，甚至要吊销我的学位证（有录音为证）。然后公司决定从我的工资里面扣2500，只给我1500工资，然后该负责人说他私自给我加了500，刚好是2000.当时我想多一事不如少一事，2000就2000吧。但是突然跟我说今天不能领工资，因为过了国家的对账时期，下个月来吧。然后我签了字拿了离职证明，给了我一个空头工资条，就回家了。</p><p>今天是1-4号，距离我辞职（2018-11-19）已经很久了，整个12月我都在想他们威胁我的话，每天睡不好觉，对我的生活造成了很大的影响。<br>离职快2个月但是我还是没有拿到自己的工资。（2019-1-4）在一个QQ群遇到了该公司负责人，提起了工资的事情，结果该负责人扬言不给我发工资还要威胁我，态度很恶劣，而且言论攻击学校。</p><p><img src="/uploads/image-20200526224229628.png" alt="image-20200526224229628"></p><p>补上后来：我老师帮助我申请了法律援助，他们知道后秒怂，给我补发剩下的2000工资然后赔礼道歉。</p><p>希望各位朋友，遇到坑的时候勇敢的站出来，那些恶势力分子最怕曝光，只要我们敢于维护自己的权利，他们就不会那么猖狂！</p><h1 id="这群人做的恶：-每一个人入职到辞职，没有加班福利，没有医社保，这些都没有享受到，而且还经历了很多匪夷所思的恶心事。为了让大家避免被骗，我曝光这家公司相关的天眼信息，底层年轻人们生活不易，希望这些骗子们，有点良心，不要再去欺负这些弱势群体。"><a href="#这群人做的恶：-每一个人入职到辞职，没有加班福利，没有医社保，这些都没有享受到，而且还经历了很多匪夷所思的恶心事。为了让大家避免被骗，我曝光这家公司相关的天眼信息，底层年轻人们生活不易，希望这些骗子们，有点良心，不要再去欺负这些弱势群体。" class="headerlink" title="这群人做的恶： 每一个人入职到辞职，没有加班福利，没有医社保，这些都没有享受到，而且还经历了很多匪夷所思的恶心事。为了让大家避免被骗，我曝光这家公司相关的天眼信息，底层年轻人们生活不易，希望这些骗子们，有点良心，不要再去欺负这些弱势群体。"></a>这群人做的恶： 每一个人入职到辞职，没有加班福利，没有医社保，这些都没有享受到，而且还经历了很多匪夷所思的恶心事。为了让大家避免被骗，我曝光这家公司相关的天眼信息，底层年轻人们生活不易，希望这些骗子们，有点良心，不要再去欺负这些弱势群体。</h1><ul><li><a href="https://www.tianyancha.com/company/3019068015">https://www.tianyancha.com/company/3019068015</a></li><li><a href="https://www.tianyancha.com/company/672969176">https://www.tianyancha.com/company/672969176</a></li><li><a href="https://www.tianyancha.com/company/3161936849">https://www.tianyancha.com/company/3161936849</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生一次失败创业</title>
    <link href="/2020/07/14/clpqt1ivk006y4cuef5bkcfoi.html"/>
    <url>/2020/07/14/clpqt1ivk006y4cuef5bkcfoi.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：纪念我人生第一次合伙创业失败的狗血经历。</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的外公</title>
    <link href="/2020/07/13/clpqt1ivy008n4cue4na8dr09.html"/>
    <url>/2020/07/13/clpqt1ivy008n4cue4na8dr09.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：外公于2020年2越28日晚上离世。</p><span id="more"></span><h2 id="关于我的外公"><a href="#关于我的外公" class="headerlink" title="关于我的外公"></a>关于我的外公</h2><p>我的外公是2019年春节期间去世的，我因为要去上班，没来得及参加他的葬礼。外公生前对我很好，我很想念他。后面有时间了给外公写一个纪念文。</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
      <tag>回忆录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019一年职场趣味经历</title>
    <link href="/2020/07/13/clpqt1ivi006r4cuegswtfaq3.html"/>
    <url>/2020/07/13/clpqt1ivi006r4cuegswtfaq3.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2019年工作经历。</p><span id="more"></span><h2 id="1-选择"><a href="#1-选择" class="headerlink" title="1.选择"></a>1.选择</h2><p><img src="/uploads/image-20200810194003404.png" alt="image-20200810194003404"></p><p>我在2020年5月月底离职，开启了我全新的一段路程。<br>        我工作的地方是某个研究机构下面的孵化公司，主要研究领域是工业机器人。我在这里负责的主要是做物联网终端设备的接入和业务系统。本想到可以在这里能做出来点成就，不想到却慢慢的被煮了青蛙。<br>        这边的工作过于轻松，以至于领导和同事全部是外行。是的，公司几个做软件开发的全部是外行，甚至有没上过大学的担任要职。经历过太多匪夷所思的事情了，比如自己研发操作系统，自己研发Nginx，自己开发一个Tensorflow等等，这里就不列举了。<br>        但是上面说的一件都没做，因为整体研发团队属于“养老系”，技术水平完全和2020年毕业的应届生都没法比，每天就是开开会，做做样子，假装在工作。<br>        但是日子过得真的舒服啊，每天按时上班，按时下班，一年了，记忆中没加过班，一直定着闹钟下班。6点下班，6:02就出公司大楼， 每天的工作强度几乎可以说是公务员的那种感觉。这种地方不求产出也没有产品责任，所以几乎是0压力。<br>        这简直就是我爸妈心目中的神圣地：“阴凉房”。可是我那段时间却失眠了。就因为这种太过安逸的生活，给我造成了危机感。<br>        进入5月以后，突然发现，很多东西我已经不会了，前段时间，写个单片机的固件，突然发现不会写C++的构造函数，写个SDK连最基础的Activemq消息队列的使用都玩不转。同期对比了一下进了大公司的学弟，我发现我在退步。很有可能会被淘汰。一点时间有些失眠，焦虑，心态也慢慢的不好了。我知道这是舒适生活带来的迷茫困扰自己。于是我做了思想斗争：离职。去大公司从底层干，重新见世面。放弃舒适环境和优越薪资，真的是非常的难，想起来可能本来一无所有，又何必在乎多拿一两万块钱。也许这两年我真不需要太多的钱吧。如果两年前从厦门离职是一个转折点，我想如今也会是我的一个转折点。</p><p>于是我头也不回的辞职了，然后上了去北方的火车。</p><h2 id="2-趣闻之老板"><a href="#2-趣闻之老板" class="headerlink" title="2.趣闻之老板"></a>2.趣闻之老板</h2><p><img src="/uploads/image-20200810194043952.png" alt="image-20200810194043952"></p><p>之前我经历了一系列匪夷所思的事情，以至于现在难以忘怀。大家一再想让我讲讲故事，我也一直推脱着，到现在抽点时间，来写点东西。</p><p>首先说说我前面的老板吧。</p><p>我之前的老板是大学老师出身，70后中年男。在创业之前是XX大学的一个CAD老师，计算机知识略懂皮毛，几乎都来自CSDN或者是百度。</p><p>就因为看了不少CSDN，他一直以为自己精通了所有计算机技术。于是逢人就说：我是10年技术专家。见到高软件的就说自己是10年架构师；见到高硬件的就说自己是10年硬件工程师；见到搞模型的就说自己是10年模型设计师。反正无所不会。我想他是为了和搞IT的人找点共同话题吧，可是每次都闹笑话。比如说：Java在Linux上有问题，我某年月开发的系统在windows上能运行，在Ubuntu上运行不了；亦或者说：SHA算法不安全，我们自己造一个ECC算法；又或者看了一眼Mongodb的CSDN技术教程，就觉得已经精通了MongoDB，其实他连索引是啥都不懂。于是我那段时间像给文盲上课一样给他普及基础知识。从JDK环境怎么搭建开始。看到什么都想问为什么，为什么你这个界面（IDEA）长得和我的不一样，我们建议用Eclipse开发。为什么Springboot脚微服务等等，因为看的都是CSDN上相对基础的东西，加上英文比较差不愿意看原本文档，导致他只会说技术的出名字来。所以刚开始我们用前后端分离的形式做界面的时候，他还质问我怎么不用JSP和Session，不然系统 不安全。<br>        因为老板是老师出身，所以把我们所有人都当成学生一样，不论别人做什么都喜欢过来指导一下，看到别人看手机也要问他看什么，而且喜欢突然跑过去看你微信。当时公司有软件研发部和硬件结构部，老板最喜欢的事情就是和我们讨论基础问题，比如编程语言，还有哪个框架怎么样，其实这些全部来自于他看的CSDN。然后跑去指挥一下某同事：你应该这么做。</p><p>那段时间我真的是被搞的精疲力尽，老板喜欢发明一些名词。他把API接口，叫微服务；把Web服务器组件叫模组；把网关叫一个奇怪的英文名字，反正不是Gateway，诸如此类等等，美其名曰：创新。甚至让我们写Java代码的时候，用下划线替代驼峰，比如<code>class UserMessage</code>，要写成<code>class user_message</code>，让人忍俊不禁。老板还喜欢坐在办公室看着所有人，动不动问一句：XXX你在做什么，仿佛小学的点名抽查一样。</p><p>后来某天不知道从哪里学来的，每天不做正事，就喜欢”搞创新，抓公司的效率“。然后就是让我们开发人员“写文档”，让我们画UML图，还得必须制定用Viso2007，用别的还不行。让产品经理用Word画原型图，他曾经敲着白板跟产品经理说：“一个合格的产品经理要学会用Word画原型图”。产品经理大姐气的无言以对，我当时 差点笑出来。</p><p>还喜欢要求我们在代码里面写上需求，比如我们写用户列表，他要求我们：”用户列表的需求是什么，我们为什么做这个功能，写代码的过程中你是怎么想的？全部写到代码里面“。然后让我们“写文档”，写的和大学的课设一样，废话连篇，比如：整体设计，整体考虑，功能考虑，创新考虑，功能亮点。。。。等等等，浓浓的忽悠凑字数风格。老关注的问题：“你这个标题应该是3号字体”。当他知道HTTP的Mehod有很多种的时候，还坚持自己“HTTP就是个协议，和方法没关系“的观点不肯下台。</p><p>我入职一年了，因为老板是个半桶水，加上其他同事档次不高，其实全公司的人都围着老板转，凸显老板的”学识渊博“。于是就没人干活了，大家都在假装上班。每天就上班下班，等着发工资。也许你们比较好奇工资怎么能发？前面我说了是XX研究院，大家懂了吧。</p><h2 id="3-大佬同事"><a href="#3-大佬同事" class="headerlink" title="3.大佬同事"></a>3.大佬同事</h2><p>不得不说一下之前的同事，因为他是我两年职业生涯中遇到最让我眼前一亮留下深刻印象的人。</p><p>同事是老板的老乡，两个人很早就认识，然后被老板叫过来当“CTO”。这个同事之前在其他地方工作了据说是7年，我也没问过，老板说：“XXX技术很好，你们多向他学习”。</p><p>大佬来就是我的领导，我叫他X经理。结果这个神人真的是牛逼，真是7年的大佬，摸鱼技术前所未见，每天上班就坐在那里一动不动，然后打开腾讯新闻看新闻，老板过来了，然后打开Word写写“整体设计，整体考虑，功能考虑。。。。”，老板走了就开始发呆，以至于从2019年4月到2020年5月我离职，一年时间，大神写了200多行代码。</p><p>大神有小儿麻痹，坐在凳子上很不稳，时不时会抽，然后全程在晃，坐在办公室让人担心随时倒下去。大神还有言语障碍症，讨论问题的时候突然小儿麻痹发作，然后开始抽，有几次我说话的时候，他瞎扯，我没忍住屌了一句：“你不懂就别乱扯”。突然大佬就开始抽，话都说不出来，吓得我汗都出来了。</p><p>大神另一个牛逼的能力：凡是老板的话，一律答应。比如老板让他实现一个比Springboot和SpringCloud还强大的“网关”，他二话不说接了；老板让他实现“高并发服务器”；他也接了。结果就是每天混，反正你让我做什么我都做，不管能不能，行不行，我混了再说。</p><p>大神不太会java，语法也不太熟；计算机基础也很差，比如连ABC类网络都分不清，在家里使劲ping公司的主机：<code>10.168.1.1</code>。大神也不会用git，提交代码能把IDEA的工程文件一起搞上去。记得某天我给大神分了2个功能，都是查询列表，结果大神说：我最近任务比较多，你做一下吧。其实他一年了，大部分时间都在磨洋工。代码量和提交记录就可以证明一切：一年，6次提交，200多行Java代码。</p><p>但是他会逗哏，把老板哄的很开心，所以深得老板喜欢，能在公司一直混下去，以至于我离职的时候，老板貌似还给他涨工资了。</p><p>不过我离职后想：这位大佬不是30了吗，35以后还能这么摸鱼吗？</p><h2 id="3-我的经历"><a href="#3-我的经历" class="headerlink" title="3.我的经历"></a>3.我的经历</h2><p>我在那段时间，除了日常陪老板玩，大部分时间在学习Java。Docker还有Kubernates，都是那段时间学会的。2019年10月开始，学了点erlang（其实直到我到这个明星公司之前，我是不会erlang的）；学了些单片机基础知识。没事干的时候写写Demo。平时偶尔出去和外面的老板们聊聊，也拿了几个小单子，赚了点零花钱。基本就这样过了一年。好的一点是一年了我看了很多书，补了很多大学欠缺的知识，算是另一方面的收获。</p><p>辞职以后老板以“离职期间工资是60%“，”你的文档写的不完善“为理由，冒着违法行为扣了我四千多工资，大家劝我去申诉仲裁，我想了一下，好聚好散，有什么必要，明天我就要上车了，影响心情不好，不知道四千多老板能干点啥，真让人想不通。</p><p>我收拾东西的那天，连招呼都没打就走了，出门以后就删除了所有老板和同事，一年了我确实太压抑了吧。</p><h2 id="4-末尾"><a href="#4-末尾" class="headerlink" title="4.末尾"></a>4.末尾</h2><p>我辞职后，问我媳妇儿：”我们在这里没啥前途了，愿意跟我往北走吗“？我那个傻傻的小可爱想都没想就说：</p><p>“好啊，你走到哪，我就跟到哪，你过什么生活，我就陪你过什么生活。”</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一个角度解释程序运行原理</title>
    <link href="/2020/07/13/clpqt1iv5005c4cue05bzddxx.html"/>
    <url>/2020/07/13/clpqt1iv5005c4cue05bzddxx.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：概要-&gt;<br> <span id="more"></span></p>]]></content>
    
    
    <categories>
      
      <category>CS基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一些有趣的项目</title>
    <link href="/2020/07/13/clpqt1iv7005g4cue5b24h0tt.html"/>
    <url>/2020/07/13/clpqt1iv7005g4cue5b24h0tt.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：概要-&gt;<br> <span id="more"></span></p>]]></content>
    
    
    <categories>
      
      <category>CS基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年以后技术路线调整</title>
    <link href="/2020/07/13/clpqt1ivx008j4cue9aur2vam.html"/>
    <url>/2020/07/13/clpqt1ivx008j4cue9aur2vam.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2020以后技术路线调整。</p><span id="more"></span><p>2020秋天到了，转眼我在Java行业做了2年。今年夏天是我人生新的转折点，因为我做了个决定：转行不做Java了。<br>回忆起这两年的点滴，确实感慨万千，在福建省厦门和福州之间来回奔波，辗转多地，搬家都好几次了，中途遇到了好老板，也被骗过，也被忽悠过，仿佛都是过眼云烟一样。</p><h2 id="1-新的决定"><a href="#1-新的决定" class="headerlink" title="1.新的决定"></a>1.新的决定</h2><p>Java做了两年，没什么成就感，一直在做业务，总是觉得欠缺些东西。每天写CURD确实让人心累疲倦，于是我换了小众领域的Erlang。Erlang的并发编程和容错系统深深吸引了我。<br>也不是自废武功，我想我一直在找最适合自己的方向吧。</p><h2 id="2-未来规划"><a href="#2-未来规划" class="headerlink" title="2.未来规划"></a>2.未来规划</h2><p>未来规划我总结了职业规划和事业规划，还有爱好培养</p><ol><li><p>职业规划</p><p> 不断的熟悉Erlang和C语言，在并发编程和物联网领域取得一定成就；</p></li><li><p>事业规划</p><p> 争取做一款自己的开源产品，长期维护下去。</p></li><li><p>兴趣爱好</p><p>后期出一些博客和视频教程，主要讲服务器编程和计算机理论基础，同时伴随出一些高级物联网项目实战项目。</p></li></ol><h2 id="3-反思自己"><a href="#3-反思自己" class="headerlink" title="3.反思自己"></a>3.反思自己</h2><p>我个人当前还存在一些问题：</p><ol><li>情绪化，容易被惹生气，或者容易自己生气；</li><li>还是太懒了，不能高效率的严格要求自己；</li><li>玩手机的毛病还是戒不了。</li></ol><hr><p>加油，2020.</p>]]></content>
    
    
    <categories>
      
      <category>职场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
      <tag>职场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么样的企业算是合格</title>
    <link href="/2020/07/13/clpqt1ivi006s4cue4ksi03hl.html"/>
    <url>/2020/07/13/clpqt1ivi006s4cue4ksi03hl.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：大概回忆一下自己这几年经历的一些公司吧</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2基础操作</title>
    <link href="/2020/05/26/clpqt1iu5001w4cueftmn0zmy.html"/>
    <url>/2020/05/26/clpqt1iu5001w4cueftmn0zmy.html</url>
    
    <content type="html"><![CDATA[<p>概要：Erlang程序设计基础知识讲解</p><span id="more"></span><p>申明:此系列文章来源于【<a href="https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。">https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。</a></p><hr><p>在unix终端中输入erl来打开Erlang终端。Erlang终端简称（Eshell)<br>在windows中我们可以通过单击”开始”菜单中的Erlang运行图标来打开。<br>当进入Eshell中，请尝试输入一些整数，在表达式的最后需要使用英文句号(句点)来终止，然后按回车键执行：</p><pre><code class="hljs erlang"><span class="hljs-number">1</span>&gt; -<span class="hljs-number">234</span>.-2342&gt; 2#1010.<span class="hljs-number">10</span><span class="hljs-number">3</span>&gt; $A.<span class="hljs-number">65</span></code></pre><p>如果在输入结束时没有输入句点，那么Eshell就不会对你的输入值进行求值，并会继续接收你后续输入的信息，知道输入句点并且按下回车键执行</p><pre><code class="hljs erlang"><span class="hljs-number">4</span>&gt; <span class="hljs-number">5</span>-<span class="hljs-number">4</span>&gt;<span class="hljs-number">4</span>&gt; <span class="hljs-number">4</span>.<span class="hljs-number">1</span></code></pre><p>1&gt; 和 2&gt; 都是命令提示符，这表明Erlang已经准备好接受输入。当你按下回车键且结束行也使用了句点，那么Erlang就会对你所输人的内容进行求值，如果成功的话，就会显示出结果。请注意各种不同的整数表达式都转换和显示为十进制形式。如果你输人一个无效的表达式，你会得到一个错误，比如:</p><pre><code class="hljs erlang"><span class="hljs-number">4</span>&gt; <span class="hljs-number">5</span>-.* <span class="hljs-number">5</span>: syntax error before: &#x27;.&#x27;<span class="hljs-number">5</span>&gt; q().</code></pre><p>要从一个错误中故复，只需要多按几次回车键，海加上句点，最后再按下回车键。如果你想退出Erlang终端窗口，那么请输入并加上句点:<code>.</code></p><pre><code class="hljs erlang"><span class="hljs-number">5</span>&gt; q().</code></pre><p>注意事项：</p><ul><li><p>在Erlang Shell中可以方便的做进制转换:Base#Value Base的范围2~16 2#101011</p></li><li><p>Erlang Shell中查询ASCII码 $1 $a $A $\n $}</p></li><li><p>Erlang Shell中释放变量使用f() 定义record使用rd(),读取shell输入使用io:read/1可以接受输入Erlang term</p></li><li><p>Erlang Shell中接受消息使用flush() 自己的Pid是self() 查看进程信息使用processes() i() 但是不要在进程非常多的场景使用,会消耗大量内存</p></li><li><p>使用 CTRL ＋ \ 或 init:stop()， 可以退出Erlang， </p></li><li><p>使用CTRL ＋ G 及 CTRL + C 弹出菜单选项，可以选择是否退出Erlang。</p></li><li><p>其中CTRL ＋ G可以用来连接其他的shell， </p></li><li><p>CTRL ＋ C可以查看其他一些系统信息</p></li><li><p>Ctrl + C abort 是野蛮的退出方式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1安装与运行环境</title>
    <link href="/2020/05/26/clpqt1iu600204cue7iwb77e0.html"/>
    <url>/2020/05/26/clpqt1iu600204cue7iwb77e0.html</url>
    
    <content type="html"><![CDATA[<p>概要：Erlang程序设计基础知识讲解</p><span id="more"></span><p>申明:此系列文章来源于【<a href="https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。">https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。</a></p><hr><h2 id="1-ubuntu安装"><a href="#1-ubuntu安装" class="headerlink" title="1. ubuntu安装"></a>1. ubuntu安装</h2><pre><code class="hljs shell">sudo apt-get install make gcc openssl libssl-dev libncurses-dev libwxgtk3.0-dev m4 glibc-devel build autoconf./configure --enable-native-libsmake &amp;&amp; make install</code></pre><h2 id="2-CentOS安装"><a href="#2-CentOS安装" class="headerlink" title="2. CentOS安装"></a>2. CentOS安装</h2><pre><code class="hljs shell">yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel</code></pre><p>描述</p><table><thead><tr><th>lib库</th><th>功能</th></tr></thead><tbody><tr><td>libncurses-dev</td><td>系统的必备库,基础库</td></tr><tr><td>build-essential</td><td>提供编译程序必须软件包的列表信息</td></tr><tr><td>libwxgtk3.0-dev</td><td>图形库</td></tr><tr><td>libssl-dev</td><td>加密库</td></tr><tr><td>m4</td><td>native 模式 hipe</td></tr><tr><td>hipe</td><td>erlang-base-hipe</td></tr><tr><td>fop</td><td>Apache FOP print formatter (requires Java).</td></tr><tr><td>xsltproc</td><td>A command line XSLT processor</td></tr><tr><td>Xmllint</td><td>libxml2-utils</td></tr><tr><td>libpam0g-dev</td><td>PAM开发文件</td></tr><tr><td>unixodbc-dev</td><td>odbc支持mysql</td></tr><tr><td>freeglut3-dev</td><td>允许用户在众多的平台的创建和管理窗口中OpenGL容器，以及相关的鼠标、键盘和游戏杆功能</td></tr><tr><td>openjdk-8-jdk</td><td>jdk</td></tr></tbody></table><h2 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h2><p>在/etc/profile的最下面添加</p><pre><code class="hljs shell">export ERL_HOME=/usr/local/erlangexport PATH=$ERL_HOME/bin:$PATH  #PS：注意是冒号隔开而不是分号source /etc/profileln /usr/local/erlang/lib/erlang/bin/erl /usr/sbin/erl</code></pre><h2 id="4-安装问题"><a href="#4-安装问题" class="headerlink" title="4. 安装问题"></a>4. 安装问题</h2><table><thead><tr><th>描述</th><th>解决方案</th></tr></thead><tbody><tr><td>configure: error: No curses library functions found</td><td>yum list|grep ncurses<br/>yum -y install ncurses-devel</td></tr><tr><td>jinterface     : No Java compiler found</td><td></td></tr><tr><td>odbc           : ODBC library - link check failed</td><td>yum install unixODBC-devel</td></tr><tr><td>crypto         : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr><tr><td>ssh            : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr><tr><td>ssl            : No usable OpenSSL found</td><td>yum install openssl-devel</td></tr><tr><td>No C++ compiler found</td><td>yum install gcc-c++</td></tr></tbody></table><h2 id="5-开发工具"><a href="#5-开发工具" class="headerlink" title="5. 开发工具"></a>5. 开发工具</h2><ul><li><a href="https://www.jetbrains.com/idea/">IDEA</a></li><li><a href="https://www.vim.org/">VIM</a></li><li><a href="https://code.visualstudio.com/">VSCode</a></li><li><a href="http://www.sublimetext.com/"> Sublime Text 3</a></li></ul><h2 id="6-在Eshell中编译运行"><a href="#6-在Eshell中编译运行" class="headerlink" title="6. 在Eshell中编译运行"></a>6. 在Eshell中编译运行</h2><h3 id="1-ErlangShell"><a href="#1-ErlangShell" class="headerlink" title="1. ErlangShell"></a>1. ErlangShell</h3><pre><code class="hljs erlang">$erlErlang (BEAM) emulator version <span class="hljs-number">5.5</span>.<span class="hljs-number">1</span> [source] [async一threads:<span class="hljs-number">0</span>] [hipe]Eshell V5.<span class="hljs-number">5.1</span>  (abort with &#125;G)<span class="hljs-number">1</span>&gt; c(hello).&#123;ok，hello&#125;<span class="hljs-number">2</span>&gt; hello:start().Hello worldok<span class="hljs-number">3</span>&gt; c(<span class="hljs-string">&quot;test.erl&quot;</span>, [to_core]).   <span class="hljs-number">4</span>&gt; c(test).   <span class="hljs-comment">%编译</span>&#123;ok,test&#125;   <span class="hljs-number">5</span>&gt; erts_debug:df(test).   <span class="hljs-comment">%生成opcode </span>ok</code></pre><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h3><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> erlc hello.erl</span><span class="hljs-meta">$</span><span class="bash"> erlc -h</span>  <span class="hljs-meta">$</span><span class="bash"> erlc -o ebin -I include/ src/*.erl</span>  <span class="hljs-meta">$</span><span class="bash"> erlc +<span class="hljs-string">&quot;&#x27;S&#x27;&quot;</span> mod.erl %产生自解码 .S汇编代码</span> <span class="hljs-meta">$</span><span class="bash"> erlc +<span class="hljs-string">&quot;&#x27;P&#x27;&quot;</span> mod.erl</span>  <span class="hljs-meta">$</span><span class="bash"> erlc +<span class="hljs-string">&quot;&#x27;E&#x27;&quot;</span> mod.erl</span>  <span class="hljs-meta">$</span><span class="bash"> erl -noshell -s hello start -s init stop</span>Hello world<span class="hljs-meta"></span><span class="hljs-meta">$</span><span class="bash">erl -<span class="hljs-built_in">eval</span> <span class="hljs-string">&#x27;io:format(&quot;Memory:~p~n&quot;, [erlang:memory(total)]).&#x27;</span> -s init stop</span></code></pre><h3 id="3-MakeFile"><a href="#3-MakeFile" class="headerlink" title="3. MakeFile"></a>3. MakeFile</h3><pre><code class="hljs text">&#123;&#x27;file1&#x27;,[debug_info,&#123;i,&quot;../foo&quot;&#125;]&#125;. &#123;&#x27;*&#x27;,[debug_info]&#125;.&#123;&quot;src/erlyweb/*&quot;,  [debug_info, &#123;outdir, &quot;ebin&quot;&#125;, &#123;i,&quot;/opt/local/lib/yaws/include&quot;&#125;]&#125;.  &#123;&quot;src/erlydb/*&quot;, [debug_info, &#123;outdir, &quot;ebin&quot;&#125;]&#125;. &#123;&quot;src/erlang-psql-driver/*&quot;, [debug_info, strict_record_tests, &#123;outdir, &quot;ebin&quot;&#125;]&#125;. &#123;&quot;src/lib/*&quot;, [debug_info, strict_record_tests, &#123;outdir, &quot;ebin&quot;&#125;]&#125;. &#123; [ &#x27;*&#x27; ],  [ debug_info,  % native,  % &#123;d,product&#125;,  % &#123;i, [&quot;include&quot;]&#125;,  % &#123;i,&quot;include/mysql_statements&quot;&#125;,  % &#123;i,&quot;include/section&quot;&#125;,  % &#123;i, &quot;priv/src/mochiweb/include&quot;&#125;,  &#123;outdir, &quot;ebin&quot;&#125; ] &#125;.</code></pre><p>make：</p><pre><code class="hljs erlang">make:all().make:all(Options). <span class="hljs-comment">%根据当前目录下的Emakefile配置文件进行编译</span>$ erl -make <span class="hljs-comment">%自动查找当前目录下的Emakefile</span></code></pre><h3 id="4-脚本运行"><a href="#4-脚本运行" class="headerlink" title="4. 脚本运行"></a>4. 脚本运行</h3><ol><li>Linux shell<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>erl -noshell -pa /home/joe/code -s hello start -s init stop</code></pre></li><li>windows bat<pre><code class="hljs shell">&quot;C:\Program Files\erl5.5.3\bin\erl.exe&quot; -pa joe/code -noshell -s hello start -s init stop</code></pre></li></ol><h3 id="5-escript运行"><a href="#5-escript运行" class="headerlink" title="5. escript运行"></a>5. escript运行</h3><p>vim factorial.escript</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/env escript</span>main([A]) -&gt;    I = list_to_integer(A),    F = fac(I),    io:format(&quot;factorial~w=~w~n&quot;, [I, F]).fac(0) -&gt; 1;fac(N) -&gt; N * fac(N - 1).</code></pre>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3基础语法</title>
    <link href="/2020/05/26/clpqt1iu700224cuegvr34csn.html"/>
    <url>/2020/05/26/clpqt1iu700224cuegvr34csn.html</url>
    
    <content type="html"><![CDATA[<p>概要：Erlang程序设计基础知识讲解</p><span id="more"></span><p>申明:此系列文章来源于【<a href="https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。">https://gitee.com/yujian1018/erlang.git】,经过本人搬运整理，并非原作，希望作者收到我的邮件以后联系本人。如有侵权会及时删除。</a></p><hr><h2 id="1-变量、模式匹配"><a href="#1-变量、模式匹配" class="headerlink" title="1. 变量、模式匹配"></a>1. 变量、模式匹配</h2><hr><p>Shell命令行常见操作</p><ol><li>%:注释;</li><li>变量首字母大写，单一赋值;</li><li>模式匹配;</li><li>原子：hello, ‘an atom with’;</li><li>元组tuple：元组嵌套{person,{a,1},{b,2}}；</li><li>提取元组字段值Point = {point, 10, 45}  {point, X, Y} = Point；</li><li>列表list:  定义列表ThingsToBuy1 = [{oranges,4}, {newspaper,1}|{ThingsToBuy}]</li><li>提取元素[Buy1|ThingsToBuy2] = ThingsToBuy1.</li><li>字符串：”hello”，注意：Erlang吗，没有字符串的说法，只有List，请看相关文章</li><li>q()退出shll</li><li>f()释放shell中的变量</li></ol><h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><hr><p>面向函数编程：函数可以作为参数，也可以作为返回值，可以使用列表解析、断言、case/if、二进制、比特位、进制、ASCII码</p><ol><li><p>函数<br>函数类似于其他语言的函数定义</p></li><li><p>匿名函数</p><pre><code class="hljs kotlin"><span class="hljs-built_in">Double</span> = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(X)</span></span> -&gt; <span class="hljs-number">2</span>*X end.<span class="hljs-built_in">Double</span>(<span class="hljs-number">2</span>).Hypot = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(X, Y)</span></span> -&gt; math:sqrt(X*X+Y*Y) end.    TempConvert = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(&#123;c,C&#125;)</span></span> -&gt; &#123;f, <span class="hljs-number">32</span>+C*<span class="hljs-number">9</span>/<span class="hljs-number">5</span>&#125;;    (&#123;f,F&#125;) -&gt; &#123;c, (F-<span class="hljs-number">32</span>)*<span class="hljs-number">5</span>/<span class="hljs-number">9</span>&#125;end.</code></pre></li><li><p>函数作为函数参数</p><pre><code class="hljs erlang">映射：lists:map(Double, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]).    返回[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>].过滤：lists:filter(Even, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]).    Even = <span class="hljs-keyword">fun</span>(X) -&gt; (X <span class="hljs-keyword">rem</span> <span class="hljs-number">2</span>) =:= <span class="hljs-number">0</span> <span class="hljs-keyword">end</span>.</code></pre></li><li><p>返回函数的函数</p><pre><code class="hljs kotlin">Fruit = [apple,pear,orange].MakeTest = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(L)</span></span> -&gt; (<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(X)</span></span> -&gt; lists:member(X,L) end) end.IsFruit = MakeTest(Fruit).IsFruit = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(X)</span></span> -&gt; lists:member(X,[apple,pear,orange]) end.</code></pre></li><li><p>循环</p><pre><code class="hljs mathematica"><span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Max</span><span class="hljs-operator">,</span><span class="hljs-built_in">Max</span><span class="hljs-operator">,</span><span class="hljs-variable">F</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">F</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Max</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span><span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">,</span><span class="hljs-built_in">Max</span><span class="hljs-operator">,</span><span class="hljs-variable">F</span><span class="hljs-punctuation">)</span>   <span class="hljs-operator">-&gt;</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">F</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-punctuation">)</span><span class="hljs-operator">|</span><span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">I</span><span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">,</span><span class="hljs-built_in">Max</span><span class="hljs-operator">,</span><span class="hljs-variable">F</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span></code></pre></li><li><p>列表解析</p><pre><code class="hljs prolog">[<span class="hljs-number">2</span>*<span class="hljs-symbol">X</span> || <span class="hljs-symbol">X</span> &lt;- <span class="hljs-symbol">L</span>].定义：<span class="hljs-symbol">Buy</span> = [&#123;oranges,<span class="hljs-number">4</span>&#125;,&#123;newspaper,<span class="hljs-number">1</span>&#125;,&#123;apples,<span class="hljs-number">10</span>&#125;,&#123;pears,<span class="hljs-number">6</span>&#125;,&#123;milk,<span class="hljs-number">3</span>&#125;].乘积：[shop:cost(<span class="hljs-symbol">A</span>)*<span class="hljs-symbol">B</span> || &#123;<span class="hljs-symbol">A</span>,<span class="hljs-symbol">B</span>&#125; &lt;- <span class="hljs-symbol">Buy</span>]求和：libs:sum([shop:cost(<span class="hljs-symbol">A</span>)*<span class="hljs-symbol">B</span> || &#123;<span class="hljs-symbol">A</span>,<span class="hljs-symbol">B</span>&#125; &lt;- <span class="hljs-symbol">Buy</span>]).(<span class="hljs-number">1</span>)快速排序：<span class="hljs-symbol">L</span>=[<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]. qsort(<span class="hljs-symbol">L</span>).(<span class="hljs-number">2</span>)毕达哥拉斯三元组：libs:pythag(<span class="hljs-number">16</span>).(<span class="hljs-number">3</span>)变位词：libs:perms(<span class="hljs-string">&quot;123&quot;</span>).          [<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;132&quot;</span>,<span class="hljs-string">&quot;213&quot;</span>,<span class="hljs-string">&quot;231&quot;</span>,<span class="hljs-string">&quot;312&quot;</span>,<span class="hljs-string">&quot;321&quot;</span>]</code></pre></li><li><p>算术表达式</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>+<span class="hljs-number">2</span>.<span class="hljs-attribute">1</span>/<span class="hljs-number">1</span>.<span class="hljs-attribute">10</span>*<span class="hljs-number">4</span>.</code></pre></li><li><p>断言：</p><pre><code class="hljs tp">max(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>) when <span class="hljs-keyword">X</span> &gt; <span class="hljs-keyword">Y</span> -&gt; <span class="hljs-keyword">X</span>;max(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>) -&gt; <span class="hljs-keyword">Y</span>.断言函数：f(<span class="hljs-keyword">X</span>,<span class="hljs-keyword">Y</span>) when is_integer(<span class="hljs-keyword">X</span>), <span class="hljs-keyword">X</span> &gt; <span class="hljs-keyword">Y</span>, <span class="hljs-keyword">Y</span> &lt; <span class="hljs-number">6</span> -&gt; <span class="hljs-keyword">X</span>;</code></pre></li><li><p>记录：record<br>结构化数据，类似于MAP的结构。</p></li><li><p>case表达式：</p></li></ol><pre><code class="hljs css"><span class="hljs-attribute">filter</span>(<span class="hljs-selector-tag">P</span>, <span class="hljs-selector-attr">[P|T]</span>) -&gt;    case <span class="hljs-selector-tag">P</span>(H) of        true -&gt; <span class="hljs-selector-attr">[H|filter(P,T&#125;]</span>; false -&gt;<span class="hljs-attribute">filter</span>(<span class="hljs-selector-tag">P</span>,T)     end;<span class="hljs-attribute">filter</span>(<span class="hljs-selector-tag">P</span>, <span class="hljs-selector-attr">[]</span>) -&gt; <span class="hljs-selector-attr">[]</span>.</code></pre><ol start="11"><li>if表达式：</li></ol><pre><code class="hljs livescript">test_if<span class="hljs-function"><span class="hljs-params">(Num)</span> -&gt;</span><span class="hljs-keyword">if</span>Num&gt;=<span class="hljs-number">5</span> -&gt;<span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-params">(Num&gt;=<span class="hljs-number">0</span>)</span> <span class="hljs-title">and</span> <span class="hljs-params">(Num&lt;<span class="hljs-number">5</span>)</span> -&gt;</span><span class="hljs-number">0</span>;Num&lt;<span class="hljs-number">0</span> -&gt;passend.</code></pre><ol start="12"><li><p>内建函数BIF<br>内置函数是指那些出于某种需求而内置到 Erlang 虚拟机中的函数。内置函数常常实现那些在 Erlang 中不容易实现或者在 Erlang 中实现效率不高的函数。某些内置函数也可以只用函数名就调用，因为这些函数是由于默认属于 erlang 模块。可理解为标准库。</p></li><li><p>二进制数据</p><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;&lt;&gt;</span>&gt;<span class="hljs-variable">&lt;&lt;E1,...,En&gt;</span>&gt;Ei = Value |<span class="hljs-string"></span><span class="hljs-string">       Value:Size </span>|       Value/TypeSpecifierList |<span class="hljs-string"></span><span class="hljs-string">       Value:Size/TypeSpecifierList</span><span class="hljs-string">Type= integer </span>|<span class="hljs-string"> float </span>|<span class="hljs-string"> binary </span>|<span class="hljs-string"> bytes </span>|<span class="hljs-string"> bitstring </span>|<span class="hljs-string"> bits </span>|<span class="hljs-string"> utf8 </span>|<span class="hljs-string"> utf16 </span>|<span class="hljs-string"> utf32</span><span class="hljs-string">Signedness= signed </span>|<span class="hljs-string"> unsigned  (整型值时有意义，默认是unsigned)</span><span class="hljs-string">Endianness= big </span>|<span class="hljs-string"> little </span>|<span class="hljs-string"> native 默认是big</span><span class="hljs-string">Unit= unit:IntegerLiteral</span><span class="hljs-string">  unit是每个数据段的size,允许的取值范围是1..256</span><span class="hljs-string">  size和unit的乘积是数据占用的二进制位数,且必须可以被8整除</span><span class="hljs-string">  unit 通常用来保证字节对齐.</span></code></pre></li><li><p>动态调用</p><pre><code class="hljs coq"><span class="hljs-built_in">apply</span>(libs, <span class="hljs-built_in">sum</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]).注意：尽量避免过多的<span class="hljs-built_in">apply</span>。</code></pre></li><li><p>指令</p><pre><code class="hljs erlang">模块：-module(modname).引入：-import(modname, [<span class="hljs-keyword">fun</span>/<span class="hljs-number">1</span>]). 可以不写模块名直接引用函数名导出：-export([name1/<span class="hljs-number">1</span>, name2/<span class="hljs-number">2</span>]).编译属性：-compile(options).模块版本：-vsn(Version).用户定义属性：-SomeTag(Value).输出属性：attr:module_info().          attr:module_info(attributes).引用函数：<span class="hljs-keyword">fun</span> Mod:RemoteFunc/Arity包含文件：-include(Filename).         -include_lib(Name).列表操作符：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]++[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]            [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]--[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]进制：K#<span class="hljs-number">123</span>$语法：$C 表示ASCII字典：erase(), put(x, <span class="hljs-number">20</span>),get(x), erase(x)短路表达式：Epr1 <span class="hljs-keyword">orelse</span> Epr2.  Epr1 andalse Epr2.</code></pre></li></ol><h2 id="3-编译运行"><a href="#3-编译运行" class="headerlink" title="3. 编译运行"></a>3. 编译运行</h2><hr><ol><li>退出：halt().导致数据库要恢复  q().安全退出，等价于init:stop().</li><li>取得加载路径：code:get_path().<br>取得主目录：init:get_argument(home).</li><li>外部运行：D:/erl&gt;erl.exe -noshell -s hello start -s init stop</li><li>帮助：help().</li></ol><h2 id="4-并发"><a href="#4-并发" class="headerlink" title="4. 并发"></a>4. 并发</h2><hr><ol><li><p>创建进程</p><pre><code class="hljs sqf">Pid = <span class="hljs-built_in">spawn</span>(Fun)<span class="hljs-built_in">spawn</span>(<span class="hljs-built_in">Mod</span>, FuncName, Args).</code></pre></li><li><p>erlang消息机制</p><pre><code class="hljs erlang-repl">发送消息：Pid!Message群发消息：Pid1!Pid2!Pid3...!Pidn!Message接收消息：receive ... end.例如：Pid = spawn(fun area_server0:loop/<span class="hljs-number">0</span>).     Pid!&#123;rectangle, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>&#125;.</code></pre></li><li><p>进程相关</p><pre><code class="hljs kotlin">自身ID：self().Pid!&#123;self(), Message&#125;.例如：Pid = spawn(<span class="hljs-function"><span class="hljs-keyword">fun</span> area_server1:loop/0).</span>     area_server1:rpc(Pid, &#123;rectangle, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>&#125;).</code></pre></li><li><p>设置进程数</p><pre><code class="hljs livescript">D:/erl&gt;erl +P <span class="hljs-number">500000</span>测试启动时间：process:max(<span class="hljs-number">400000</span>).register(AnAtom, Pid).  注册进程别名unregister(AnAtom).   溢出注册进程whereis<span class="hljs-function"><span class="hljs-params">(AnAtom)</span> -&gt;</span> Pid | <span class="hljs-literal">undefined</span> 判断是否注册registered<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> [AnAtom::atom()] 取得所有注册进程注册时钟：clock:start<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5000</span>, fun() -&gt; io:format(<span class="hljs-string">&quot;TICK ~p~n&quot;</span>, [erlang:now()]) end)</span>.</span><span class="hljs-function">停止时钟：<span class="hljs-title">clock</span>:<span class="hljs-title">stop</span><span class="hljs-params">()</span>.</span></code></pre></li></ol><h2 id="5-分布式"><a href="#5-分布式" class="headerlink" title="5. 分布式"></a>5. 分布式</h2><hr><ol><li><p>单节点测试<br>启动服务器：kvs.start().<br>存储： kvs:store({location, joe}, “Stockholm”).<br>kvs:store(weather, raining).<br>查找： kvs:lookup(weather).<br>kvs:lookup({location, joe}).</p></li><li><p>双节点测试<br>启动服务器节点：<br>D:/erl&gt;erl -sname gandalf<br>Eshell V5.7  (abort with ^G)<br>(gandalf@zhongbingliu)1&gt; kvs:start().<br>true<br>(gandalf@zhongbingliu)2&gt;</p></li><li><p>调用者节点：</p></li></ol><pre><code class="hljs autoit">D:/erl&gt;erl -sname bilboEshell V5<span class="hljs-number">.7</span>  (abort <span class="hljs-keyword">with</span> ^G)(bilbo<span class="hljs-symbol">@zhongbingliu</span>)<span class="hljs-number">1</span>&gt; rpc:<span class="hljs-built_in">call</span>(gandalf<span class="hljs-symbol">@zhongbingliu</span>, kvs, store, [weather, fine]).<span class="hljs-literal">true</span>(bilbo<span class="hljs-symbol">@zhongbingliu</span>)<span class="hljs-number">2</span>&gt; rpc:<span class="hljs-built_in">call</span>(gandalf<span class="hljs-symbol">@zhongbingliu</span>, kvs, lookup, [weather]).&#123;ok,fine&#125;</code></pre><ol start="4"><li>客户机和服务器位于同一局域网的不同机器上</li><li>客户机和服务器位于因特网的不同机器上：确保4396端口通信正常，epmd会使用这个端口</li></ol><h2 id="6-文件"><a href="#6-文件" class="headerlink" title="6. 文件"></a>6. 文件</h2><hr><ol><li>读取文件<pre><code class="hljs applescript"><span class="hljs-built_in">file</span>:consult(<span class="hljs-string">&quot;data1.data&quot;</span>).</code></pre></li><li>读取<pre><code class="hljs lua">&#123;ok, S&#125; = file:<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data1.data&quot;</span>, <span class="hljs-built_in">read</span>).  <span class="hljs-built_in">io</span>:<span class="hljs-built_in">read</span>(S, <span class="hljs-string">&#x27;&#x27;</span>).  <span class="hljs-built_in">io</span>:get_line(S, <span class="hljs-string">&#x27;&#x27;</span>).  file:<span class="hljs-built_in">close</span>(S).</code></pre></li><li>查找代码库位置 <pre><code class="hljs gradle">code:which(<span class="hljs-keyword">file</span>).d:<span class="hljs-regexp">/erl5.7/</span>lib<span class="hljs-regexp">/kernel-2.13/</span>ebin/<span class="hljs-keyword">file</span>.beam</code></pre></li><li>读取二进制数据<pre><code class="hljs tcl"><span class="hljs-keyword">file</span>:read_file(<span class="hljs-string">&quot;data1.data&quot;</span>).&#123;ok, S&#125; = <span class="hljs-keyword">file</span>:<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;data1.data&quot;</span>, [<span class="hljs-keyword">read</span>,<span class="hljs-keyword">binary</span>,raw]).<span class="hljs-keyword">file</span>:pread(S, <span class="hljs-number">22</span>, <span class="hljs-number">46</span>).</code></pre></li><li>查找文件<pre><code class="hljs avrasm"><span class="hljs-symbol">lib_find:</span>files</code></pre></li><li>写入文件<pre><code class="hljs lua">&#123;ok, S&#125; = file:<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data2.data&quot;</span>, <span class="hljs-built_in">write</span>). <span class="hljs-built_in">io</span>:<span class="hljs-built_in">format</span>(S, <span class="hljs-string">&quot;~s~n&quot;</span>, [<span class="hljs-string">&quot;Hello readers&quot;</span>]).  file:<span class="hljs-built_in">close</span>(S).</code></pre></li><li>随机写入 <pre><code class="hljs tcl">&#123;ok, S&#125; = <span class="hljs-keyword">file</span>:<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;data3.data&quot;</span>, [raw,write,<span class="hljs-keyword">binary</span>]).<span class="hljs-keyword">file</span>:pwrite(S, <span class="hljs-number">10</span>, &lt;&lt;<span class="hljs-string">&quot;new&quot;</span>&gt;&gt;).</code></pre></li><li>目录操作<pre><code class="hljs applescript"><span class="hljs-built_in">file</span>:list_dir(<span class="hljs-string">&quot;/&quot;</span>).  <span class="hljs-built_in">file</span>:make_dir(<span class="hljs-string">&quot;abc&quot;</span>).  <span class="hljs-built_in">file</span>:del_dir(<span class="hljs-string">&quot;abc&quot;</span>).</code></pre></li><li>文件属性 <pre><code class="hljs applescript"><span class="hljs-built_in">file</span>:read_file_info(<span class="hljs-string">&quot;data1.data&quot;</span>).</code></pre></li><li>文件操作 <pre><code class="hljs gradle"><span class="hljs-keyword">file</span>:<span class="hljs-keyword">copy</span>(<span class="hljs-string">&quot;data1,data&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>).        <span class="hljs-keyword">file</span>:<span class="hljs-keyword">delete</span>(<span class="hljs-string">&quot;data1&quot;</span>).</code></pre></li></ol><h2 id="7-套接字"><a href="#7-套接字" class="headerlink" title="7. 套接字"></a>7. 套接字</h2><hr><ol><li>Socket连接www:socket:nano_get_url().</li><li>启动服务器：server:start_nano_server().</li><li>编写客户端：client:nano_client_eval(“list_to_tuple([2+3*4,10+20])”).</li></ol><ul><li>主动型：非阻塞 服务器接收消息的速度必须快于客户端发送的速度，否则服务器会因为消息缓冲-区塞满被消息淹没</li><li>被动型：阻塞</li><li>混合型：半阻塞</li></ul><h2 id="8-数据库"><a href="#8-数据库" class="headerlink" title="8. 数据库"></a>8. 数据库</h2><hr><ol><li>ETS是内存存储，速度快</li><li>DETS是磁盘存储，可备份</li><li>创建表：ets:new </li><li>插入：insert(table, X)</li><li>查找：lookup(table, Key)</li><li>释放：dets:close(tableid) etd:delete(tableid)</li><li>Mnesia数据库：<pre><code class="hljs isbl">创建表：-<span class="hljs-variable">record</span>...选取所有数据：<span class="hljs-function"><span class="hljs-title">do</span>(<span class="hljs-title">qlc</span>())...</span><span class="hljs-function">选取部分列：</span><span class="hljs-function">按条件选取：</span><span class="hljs-function">关连查询：</span><span class="hljs-function">增加数据：<span class="hljs-variable">mnesia</span>:<span class="hljs-title">write</span>()</span>删除数据：<span class="hljs-variable">mnesia</span>:<span class="hljs-function"><span class="hljs-title">delete</span>()</span>事务管理：<span class="hljs-variable">mnesia</span>:<span class="hljs-function"><span class="hljs-title">transaction</span>(<span class="hljs-variable">F</span>)</span>取消事务：<span class="hljs-variable">mnesia</span>:<span class="hljs-function"><span class="hljs-title">abort</span>()</span>启动表查看器：<span class="hljs-variable">tv</span>:<span class="hljs-function"><span class="hljs-title">start</span>().</span></code></pre></li></ol><h2 id="9-OTP"><a href="#9-OTP" class="headerlink" title="9. OTP"></a>9. OTP</h2><hr><ol><li>支持事务：使用异常捕捉进行回滚</li><li>支持热代码替换</li><li>错误日志</li><li>警报管理</li><li>应用程序监视器：appmon:start().</li></ol>]]></content>
    
    
    <categories>
      
      <category>Erlang程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>OTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Erlang基于TCP协议的服务器开发</title>
    <link href="/2020/05/19/clpqt1iwe00al4cue0u5a2wa9.html"/>
    <url>/2020/05/19/clpqt1iwe00al4cue0u5a2wa9.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：用Erlang实现一个精简的基于TCP协议之上的应用层协议。</p><span id="more"></span><hr><h2 id="1-设计背景"><a href="#1-设计背景" class="headerlink" title="1. 设计背景"></a>1. 设计背景</h2><p>​        看到TRUMP大家首先想到的是一头飘逸金发，胸前飘着鲜艳红领带的老年人，没错就是下面这个：</p><p><img src="/uploads/image-20200519103707805.png" alt="image-20200519103707805"></p><p>​        但是今天我说的这个TRUMP和上面这位半毛钱关系都没有。我的TRUMP有单独的含义，我给出的这个TTUMP是一种简单的客户端-服务端的通信协议。下面是TRUMP的完整名称：</p><blockquote><p>TRUMP：TCP Remix UDP Middle Protocol（中文释义：TCP混合UDP的中间层协议）</p></blockquote><p>乍一看像是在卖关子，其实是有严格的定义和说明的，下面我解释一下为何要定义这么奇怪的一个名字。</p><p>​        近期在家里看着墙发呆的时候，闹钟引起了我的注意。这个闹钟是大学的时候用过的，一直到现在都还在正常显示，突然想起来上一次换时间貌似是2017年12月–一个冬天，现在都2020年了，拿过来摆弄了一番，发现里面装了3节南孚电池。令我惊讶的是，闹钟还能很大声的响铃。</p><p>​        我不由得来了兴趣，仔细分析了一下这个闹钟的基本构造。闹钟用了液晶数码管作为显示屏，而液晶数码管的功耗就非常低了，这节省了很大的电量。同时有3节7号电池供电，电压是1.5*3=4.5V，差不多工作电流是0.001MA(百度了一下基本的参数做了对比)，在如此低功耗条件下工作了快2年，确实值得研究。</p><p>​        于是我想了一下，能不能发明一个专门针对低功耗的芯片的通信协议，来实现以非常低的功率长时间工作。最好是纽扣电池，或者是马铃薯、番茄电池都能维持通信。我的闹钟上面可以显示温湿度，如果加以改造，就可以把这些数据上传到云服务器，岂不是可以时刻监控温湿度而实现动态调节？同时我还想远程换个铃声，这又涉及到了远程及时通信了，在这个比较有趣的情景下，我决定发明一个简单的，但是靠谱的，针对低端尤其是低功耗的设备进行少量数据传输的协议。</p><p>​        其实一开始叫Trap，可能我觉得我的能力不够，做出来的东西就是个坑(Trap)吧，为了避免过分解读和吐槽，简单定义为：一个简单的玩具协议。</p><p>​        最近我又重新梳理了一下，把一些比较核心的概念还有设计思路捋清楚，然后认证整理出来。Trap是之前设计的一个不完善的协议，所以这次相对比较完善，为了区分，重新更名为:TRUMP。</p><p>​        TRUMP的核心是同时支持基于原生TCP（Raw TCP）和原生UDP（Raw UDP）两种类型的通信形式，对于这两种传输层协议做了最简单的封装，故命名为中间层协议（Middle Protocol）。</p><p>​        本协议的设计相对来讲比较通俗易懂，都是基础知识，可以为初学者提供一些设计思路，这些思路可以用在游戏开发，IM开发，还有物联网终端通信等等，其实就是提供了一个把传输层往应用层靠拢的最基础的思路。</p><p>​        该设计当然是不完善的，远远达不到工业级的水准，所以各位朋友如果发现问题或者设计思路有大问题，可以指出。但是不接受喷子和高论，如果某个大佬有高论或者更优秀的设想，请自己亲自实现一遍比较好。</p><p>​        讲文明树新风，文明社会树立文明形象。</p><h2 id="2-参照标准"><a href="#2-参照标准" class="headerlink" title="2. 参照标准"></a>2. 参照标准</h2><p>​        在设计之前，我参考了好几种常见的协议，站在巨人的肩上工作能无限接近天花板不是吗。<br>近期参考了EMQ的一些设计思路(尤其是EMQ的产品介绍PPT)，还有之前的一个TCP服务器Demo也给了我一定程度的启发，EMQ给我的思路是：通信需要并发处理，TCP服务器Demo给我的思路是：越简单越好，这句话也是Python之禅的名言。<br>​        我协议设计的主要思路来源于Erlang的TCP并发处理模式和低功耗的芯片通信。</p><h2 id="3-同类协议"><a href="#3-同类协议" class="headerlink" title="3. 同类协议"></a>3. 同类协议</h2><h3 id="3-1-COAP协议"><a href="#3-1-COAP协议" class="headerlink" title="3.1 COAP协议"></a>3.1 COAP协议</h3><p>​        CoAP（Constrained Application Protocol）是一种在物联网世界的类HTTP协议，它的详细规范定义在 RFC 7252。COAP名字翻译来就是“受限应用协议”，顾名思义，使用在资源受限的物联网设备上。物联网设备的资源很受限，运行HTTP是不可以接受的。<br>COAP是一个非常简单的协议，非常轻量级，甚至可以看作是HTTP的精简版(当然和HTTP区别很大)。</p><h3 id="3-2-MQTT协议"><a href="#3-2-MQTT协议" class="headerlink" title="3.2 MQTT协议"></a>3.2 MQTT协议</h3><p>​        MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是一种基于发布/订阅范式的“轻量级”消息协议，由 IBM 发布。MQTT 可以被解释为一种低开销，低带宽占用的即时通讯协议，可以用极少的代码和带宽的为连接远程设备提供实时可靠的消息服务，它适用于硬件性能低下的远程设备以及网络状况糟糕的环境下，因此 MQTT 协议在 IoT（Internet of things，物联网），小型设备应用，移动应用等方面有较广泛的应用。<br>​        MQTT 可以看作是TCP之上的一个高级封装协议，功能强大，很适合作为物联网设备采集数据使用的协议。<br>关于其他的就不赘述了，上面介绍这两种协议最终目的就是让大家看到一个共同之处：物联网世界的通信大部分是：低功率、条件受限，资源不足。我们就按照这个设计思路出发设计新的协议，能同时支持TCP和类CoAP协议的协议，简单来说是简单合体又比单独两个协议更有趣（不是取代，也不是挑战，而是另一种思路，给学习者带来一种心情的愉悦）的简单协议。</p><h2 id="4-协议规范"><a href="#4-协议规范" class="headerlink" title="4. 协议规范"></a>4. 协议规范</h2><p>​        TRUMP协议其实是2个模式组成的：TCP模式和UDP模式，TRUMP有一个固定数据报文头，数据固定报文头使用4个字节(byte)来表示，如下表所示：</p><p><img src="/uploads/image-20200519104508811.png" alt="image-20200519104508811"></p><p>·  字节0表示消息报文类型编码，具体看附表；<br>·  字节1、2字节表示消息的长度（Byte），最长支持65536(Byte)个字符,也就是64KB，最长只能发送64KB数据；<br>·  字节3为扩展字节，预留给其他报文使用。分为高四位和低四位，主要用来传递客户端ID的长度。客户端ID长度最长为4位，也就是16个字符。当单个客户端的时候，ID在低四位，如果是客户端之间的通信，ID在高四位，而对端ID是低四位。</p><blockquote><p>注意：因为服务端支持分布式，所以ID不可重复，必须是整个节点群内的唯一值。</p></blockquote><h2 id="5-模式选择"><a href="#5-模式选择" class="headerlink" title="5. 模式选择"></a>5. 模式选择</h2><h3 id="5-1-Trap模式"><a href="#5-1-Trap模式" class="headerlink" title="5.1 Trap模式"></a>5.1 Trap模式</h3><p>​        TRAP模式是原生TCP的简单封装，专门用在实时通信的情况下，例如实时控制。下面是TRAP模式的设计规范。<br>​        TRAP最大的特征是可以保持数据的可达性，也就是只要发出去的数据，一定会到达对端，不论是服务器还是客户端。假如说对端不在线，服务器会保存下来，当客户端上线的时候第一时间发布过去。</p><h3 id="5-2-Urap模式"><a href="#5-2-Urap模式" class="headerlink" title="5.2 Urap模式"></a>5.2 Urap模式</h3><p>​        URAP模式是原生UDP的简单封装，专门用在非实时通信的情况下，例如设备简单的数据采集，IM聊天推送等等。URAP模式下，客户端可以进行的操作和TRAP一样，但是比较重要的是：服务端不保证数据可达性，也就是如果对端不存在，会直接丢弃消息。因此需要客户端来保存失败的数据。</p><h2 id="6-发布-订阅"><a href="#6-发布-订阅" class="headerlink" title="6. 发布-订阅"></a>6. 发布-订阅</h2><p>​        除此之外，TrumpServer为了方便开发的时候一些需求，增加了PUB-SUB插件功能，类似于Mqtt协议那样的形式，但是相对来讲比较简单。适合用在小型设备之间的网络通信。</p><p><img src="/uploads/image-20200519113539690.png" alt="image-20200519113539690"></p><h2 id="7-内存数据库"><a href="#7-内存数据库" class="headerlink" title="7. 内存数据库"></a>7. 内存数据库</h2><p>​        新增加插件功能：内存数据库，本插件是一个K-V类型的数据库，提供TCP客户端和HTTP接口，用法类似于Redis，但是功能简单，针对特殊场景，一般计划用在设备临时存放数据，当单片机的ROM或者RAM不够的情况下，可以把数据临时存放上来。</p><p><img src="/uploads/image-20200519113938941.png" alt="image-20200519113938941"></p><h2 id="8-资源链接"><a href="#8-资源链接" class="headerlink" title="8.资源链接"></a>8.资源链接</h2><ul><li>Trump：<a href="https://github.com/wwhai/trump">https://github.com/wwhai/trump</a></li><li>Erlang：<a href="https://github.com/wwhai/trump">https://github.com/wwhai/trump</a></li><li>Ets：<a href="http://www1.erlang.org/doc/man/ets.html">http://www1.erlang.org/doc/man/ets.html</a></li><li>Mnesia：<a href="http://www1.erlang.org/doc/man/mnesia.html">http://www1.erlang.org/doc/man/mnesia.html</a></li><li>TinyMq：<a href="https://github.com/ChicagoBoss/tinymq">https://github.com/ChicagoBoss/tinymq</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常操作记录</title>
    <link href="/2020/05/16/clpqt1iv5005b4cuegwbx0h72.html"/>
    <url>/2020/05/16/clpqt1iv5005b4cuegwbx0h72.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：记录近期工作中的一些常见操作.</p><span id="more"></span><h1 id="1-Docker相关"><a href="#1-Docker相关" class="headerlink" title="1.Docker相关"></a>1.Docker相关</h1><h2 id="1-1-Windows下"><a href="#1-1-Windows下" class="headerlink" title="1.1 Windows下"></a>1.1 Windows下</h2><p>windows安装Docker首先要启用Hyper-V：</p><ol><li><p>可以通过【程序和功能】=》【打开或关闭 Windows 功能】=》勾选【Hyper-V】来启用Hyper-V，</p><p><img src="/uploads/image-20200516160810446.png" alt="image-20200516160810446"></p><p><img src="/uploads/image-20200516160854773.png" alt="image-20200516160854773"></p></li></ol><ol start="2"><li><p>也可以通过管理员执行以下Powershell脚本：</p><p><code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All</code></p></li></ol><h2 id="1-2-Linux下"><a href="#1-2-Linux下" class="headerlink" title="1.2 Linux下"></a>1.2 Linux下</h2><ol><li><p>Ubuntu - server 安装Docker</p><pre><code class="hljs shell">sudo apt-get install apt-transport-https  ca-certificates curl gnupg-agent software-properties-common -ysudo add-apt-repository  &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu   $(lsb_release -cs)   stable&quot;sudo apt-get update  -ysudo apt-get install docker-ce docker-ce-cli containerd.io -y</code></pre></li><li><p>Docker强制删除容器</p><pre><code class="hljs shell">1. 删除所有容器<span class="hljs-meta">#</span><span class="bash"> 先停止所有容器</span> <span class="hljs-meta">$</span><span class="bash"> docker stop $(docker ps -a -q)</span> <span class="hljs-meta">#</span><span class="bash"> 删除</span> <span class="hljs-meta">$</span><span class="bash"> docker rm $(docker ps -a -q)</span>2. 批量删除部分容器<span class="hljs-meta">#</span><span class="bash"> 先停止所有容器</span> <span class="hljs-meta">$</span><span class="bash"> docker stop $(docker ps | grep rock | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)</span> <span class="hljs-meta">#</span><span class="bash"> 删除</span> <span class="hljs-meta">$</span><span class="bash"> docker rm $(docker ps -a| grep rock | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)</span></code></pre></li></ol><ol start="3"><li><p>UbuntuServer安装MINIKUBE</p><pre><code class="hljs shell">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64chmod +x minikubesudo mkdir -p /usr/local/bin/sudo install minikube /usr/local/bin/minikube start --registry-mirror=https://registry.docker-cn.com --memory=4096 --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</code></pre></li><li><p>DockerMysql8认证问题</p><p>Navicat连接失败的时候：</p><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> root<span class="hljs-variable">@localhost</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span> password expire never;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> root<span class="hljs-variable">@localhost</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span>;flush privileges;</code></pre><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1></li></ol><p>我们有时候需要快速搭建开发环境，比如数据库之类的，我这里总结了一个ComposeFile，直接即可搭建Mongo，Mysql，Redis开发环境。</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><span class="hljs-comment"># 定义网络</span><span class="hljs-comment"># 节点IP</span><span class="hljs-comment"># Mysql      192.168.1.100/24</span><span class="hljs-comment"># Mongodb  192.168.1.101/24</span><span class="hljs-comment"># Redis      192.168.1.102/24</span><span class="hljs-attr">networks:</span>  <span class="hljs-attr">ezlinker_net:</span>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span>    <span class="hljs-attr">ipam:</span>      <span class="hljs-attr">config:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">subnet:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><span class="hljs-comment"># 定义服务</span><span class="hljs-attr">services:</span>  <span class="hljs-comment"># Mysql</span>  <span class="hljs-attr">mysql:</span>    <span class="hljs-comment"># 使用最新版Mysql</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;ezlinker_mysql&quot;</span>    <span class="hljs-comment"># 环境变量</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&quot;root&quot;</span>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">&#x27;root&#x27;</span>      <span class="hljs-attr">MYSQL_PASS:</span> <span class="hljs-string">&#x27;root&#x27;</span>    <span class="hljs-comment"># 映射数据卷</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/mysql8/data:/var/lib/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/mysql8/log:/var/log/mysql</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/mysql8/mysql-files:/var/lib/mysql-files</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-comment"># 对外断口</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span>      <span class="hljs-bullet">-</span> <span class="hljs-number">33060</span><span class="hljs-string">:33060</span>    <span class="hljs-comment"># 启动后执行命令</span>    <span class="hljs-attr">command:</span>      <span class="hljs-string">--default-authentication-plugin=mysql_native_password</span>      <span class="hljs-string">--character-set-server=utf8mb4</span>      <span class="hljs-string">--collation-server=utf8mb4_general_ci</span>      <span class="hljs-string">--explicit_defaults_for_timestamp=true</span>      <span class="hljs-string">--lower_case_table_names=1</span>      <span class="hljs-string">--max_allowed_packet=128M;</span>    <span class="hljs-comment"># 日志限制</span>    <span class="hljs-attr">logging:</span>      <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span>      <span class="hljs-attr">options:</span>        <span class="hljs-attr">max-size:</span> <span class="hljs-string">&quot;200k&quot;</span>        <span class="hljs-attr">max-file:</span> <span class="hljs-string">&quot;10&quot;</span>    <span class="hljs-comment"># 网络</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-attr">ezlinker_net:</span>        <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>  <span class="hljs-comment"># Mongodb</span>  <span class="hljs-attr">mongo:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mongo</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">ezlinker_mongo</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/mongodb/db:/data/db</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/mongodb/configdb/:/data/configdb</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;27017:27017&quot;</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">command:</span>      <span class="hljs-string">--bind_ip</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>    <span class="hljs-attr">environment:</span>      <span class="hljs-attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="hljs-string">root</span>      <span class="hljs-attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="hljs-string">ezlinker_mongo</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-attr">ezlinker_net:</span>        <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.101</span>  <span class="hljs-comment"># Redis</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">ezlinker_redis</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">--requirepass</span> <span class="hljs-string">ezlinker_redis</span> <span class="hljs-string">--appendonly</span> <span class="hljs-literal">yes</span>    <span class="hljs-attr">ports:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;56379:6379&quot;</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/docker/ezlinker/redis/data:/data</span>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>    <span class="hljs-attr">networks:</span>      <span class="hljs-attr">ezlinker_net:</span>        <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.102</span></code></pre><p>直接用docker compose来构建即可：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择</title>
    <link href="/2020/05/16/clpqt1ivh006m4cueafv48fii.html"/>
    <url>/2020/05/16/clpqt1ivh006m4cueafv48fii.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：离开舒适地，要有危机感。</p><span id="more"></span><p><img src="/uploads/image-20200516154945096.png" alt="image-20200516154945096"></p><p>是的，我在2020年5月月底就离职，放弃了舒适的环境和优越的薪资，离开这个我准时下班的地方。<br>回想起2019年春天，刚到这里的时候，整个院子一片安静，然我不禁觉得这应该是和很舒服的地方。果然不出我预料，我接下来的一年过得是真舒服。<br>工作的地方是某个知名研究机构下面的孵化公司，主要研究领域是工业机器人。我在这里负责的主要是做物联网终端设备的接入和业务系统。本想到可以在这里能做出来点成就，不想到却慢慢的被煮了青蛙。<br>这边的工作过于轻松，以至于领导和同事全部是外行。是的，公司几个做软件开发的全部是外行，甚至有没上过大学的担任要职。经历过太多匪夷所思的事情了，比如自己研发操作系统，自己研发Nginx，自己写一个PUB/SUB系统等等，这里就不列举了。<br>但是上面说的一件都没做，因为整体研发团队属于“养老系”，技术水平完全和2020年毕业的应届生都没法比，每天就是开开会，做做样子，假装在工作。<br>但是日子过得真的舒服啊，每天按时上班，按时下班，一年了，记忆中没加过班，一直定着闹钟下班。6点下班，6:02就出公司大楼， 每天的工作强度几乎可以说是公务员的那种感觉。这种地方不求产出也没有产品责任，所以几乎是0压力。<br>这简直就是我爸妈心目中的神圣地：“阴凉房”、“高工资”。可是现在我却失眠了。就因为这种太过安逸的生活，给我造成了危机感。<br>进入5月以后，突然发现，很多东西我已经不会了，前段时间，写个单片机的固件，突然发现不会写C++的构造函数，写个SDK连最基础的Activemq消息队列的使用都玩不转。同期对比了一下进了大公司的学弟，我发现我在退步。很有可能会被淘汰。一点时间有些失眠，焦虑，心态也慢慢的不好了。我知道这是舒适生活带来的迷茫困扰自己。<br>于是我做了思想斗争：离职，去大公司从底层干，重新见世面。放弃舒适环境和优越薪资，真的是非常的难，想起来可能本来一无所有，又何必在乎多拿一两万块钱。也许这两年我真不需要太多的钱吧。<br>如果两年前从厦门离职是一个转折点，我想如今也会是我的一个转折点。<br>不在逆境中成长，就在顺境中煲汤。</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FRP-INI生成器</title>
    <link href="/2020/04/27/clpqt1iv400564cuec0dxcox8.html"/>
    <url>/2020/04/27/clpqt1iv400564cuec0dxcox8.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：主要展示一个FRP外网映射的INI配置文件生成器.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>手动管理INI比较麻烦，写了个脚本统一管理，方便零基础的朋友使用。</p><h2 id="2-Python代码"><a href="#2-Python代码" class="headerlink" title="2. Python代码"></a>2. Python代码</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> configparser<span class="hljs-keyword">import</span> os<span class="hljs-comment"># 使用绝对地址</span>frpcIniPath = os.path.join(os.path.dirname(os.path.realpath(__file__)), <span class="hljs-string">&quot;./frpc.ini&quot;</span>)<span class="hljs-comment"># 构建新配置</span>iniConfig = configparser.ConfigParser()iniConfig.read(frpcIniPath, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<span class="hljs-comment"># 设置名称</span>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入名称:&quot;</span>)tType = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入类型,[只有:http,tcp 两个选项]:&quot;</span>)localIp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入要转发的IP地址:&quot;</span>)localPort = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入转发的端口:&quot;</span>)<span class="hljs-keyword">try</span>:    iniConfig.add_section(name)<span class="hljs-keyword">except</span> configparser.DuplicateSectionError:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;名称已存在,请重新输入!&quot;</span>)    exit(<span class="hljs-number">0</span>)<span class="hljs-built_in">id</span> = <span class="hljs-built_in">int</span>(iniConfig.get(<span class="hljs-string">&quot;cursor&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>)) <span class="hljs-comment"># 写入Config</span><span class="hljs-keyword">if</span>((tType == <span class="hljs-string">&quot;tcp&quot;</span>) <span class="hljs-keyword">or</span> (tType == <span class="hljs-string">&quot;TCP&quot;</span>)):    <span class="hljs-keyword">pass</span><span class="hljs-keyword">elif</span>((tType == <span class="hljs-string">&quot;http&quot;</span>) <span class="hljs-keyword">or</span> (tType == <span class="hljs-string">&quot;HTTP&quot;</span>)):    customDomains = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入域名:&quot;</span>)    iniConfig.<span class="hljs-built_in">set</span>(name,<span class="hljs-string">&quot;custom_domains&quot;</span>, <span class="hljs-built_in">str</span>(customDomains))    <span class="hljs-comment"># 写配置</span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始写入......&quot;</span>)iniConfig.<span class="hljs-built_in">set</span>(name,<span class="hljs-string">&quot;type&quot;</span>, tType)iniConfig.<span class="hljs-built_in">set</span>(name,<span class="hljs-string">&quot;server_port&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>+<span class="hljs-number">1</span>))iniConfig.<span class="hljs-built_in">set</span>(name,<span class="hljs-string">&quot;local_ip&quot;</span>, <span class="hljs-built_in">str</span>(localIp))iniConfig.<span class="hljs-built_in">set</span>(name,<span class="hljs-string">&quot;local_port&quot;</span>, <span class="hljs-built_in">str</span>(localPort))iniConfig.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;cursor&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-built_in">id</span>+<span class="hljs-number">1</span>))iniConfig.write(<span class="hljs-built_in">open</span>(frpcIniPath, <span class="hljs-string">&quot;w&quot;</span>))<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;写入成功&quot;</span>)</code></pre><h2 id="3-INI模板文件"><a href="#3-INI模板文件" class="headerlink" title="3. INI模板文件"></a>3. INI模板文件</h2><pre><code class="hljs ini"><span class="hljs-section">[common]</span><span class="hljs-attr">server_addr</span> = 公网IP<span class="hljs-attr">server_port</span> = FRP端口<span class="hljs-attr">token</span> = token<span class="hljs-section">[cursor]</span><span class="hljs-attr">id</span> = 开始端口</code></pre><h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4. 使用方法"></a>4. 使用方法</h2><pre><code class="hljs shell">cd .\frp\python .\frp_ini_manager.py输入名称:rpi输入类型,[只有:http,tcp 两个选项]:http输入要转发的IP地址:1.2.3.4输入转发的端口:2222输入域名:www.ttt.cn开始写入......写入成功</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX二次开发-和Java通信</title>
    <link href="/2020/04/18/clpqt1iu2001n4cue7vyi6yzd.html"/>
    <url>/2020/04/18/clpqt1iu2001n4cue7vyi6yzd.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲EMQX和Java直连的过程。</p><span id="more"></span><h1 id="1-背景概述"><a href="#1-背景概述" class="headerlink" title="1.背景概述"></a>1.背景概述</h1><p>ErlangVm要求我们用Erlang编写代码，但是有时候我们可能对Erlang不熟悉或者是Erlang驱动太少，别担心，Erlang提供了一种接口技术，可以实现用Java来伪装成一个Erlang节点，从而实现ErlangVm的扩展。</p><blockquote><p>The Jinterface package provides a set of tools for communication with Erlang processes. It can also be used for communication with other Java processes using the same package, as well as C processes using the Erl_Interface library.</p></blockquote><h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h1><p>关于Java就不多讲了，我们说一下类型映射。Erlang的数据类型和Java是一一对应起来的，如下表所示：</p><p><img src="/uploads/image-20200418095915395.png" alt="image-20200418095915395"></p><p>我们熟悉Java以后很容易可以利用这些基本数据类型和ErlangVm通信。</p><h1 id="3-代码案例"><a href="#3-代码案例" class="headerlink" title="3.代码案例"></a>3.代码案例</h1><p>下面展示一个很基础的Demo：</p><pre><code class="hljs java"><span class="hljs-comment">// 省略部分代码 </span><span class="hljs-comment">// 创建一个节点，名字为node1</span>OtpNode self = <span class="hljs-keyword">new</span> OtpNode(<span class="hljs-string">&quot;node1&quot;</span>);    <span class="hljs-comment">// 模拟Erlang创建一个进程 name是process1</span>    OtpMbox mbox = self.createMbox(<span class="hljs-string">&quot;process1&quot;</span>);    OtpErlangObject o;    OtpErlangTuple msg;    OtpErlangPid from;    <span class="hljs-comment">// 用一个循环来实现消息接受，这里有点像Socket通信</span>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 注意 这个方法是个阻塞方法，会一直卡在这里 直到消息到达</span>        o = mbox.receive();        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> OtpErlangTuple) &#123;          msg = (OtpErlangTuple)o;          from = (OtpErlangPid)(msg.elementAt(<span class="hljs-number">0</span>));          mbox.send(from,msg.elementAt(<span class="hljs-number">1</span>));      &#125;      <span class="hljs-keyword">catch</span> (Exception e) &#123;        System.out.println(<span class="hljs-string">&quot;&quot;</span> + e);      &#125;    &#125;   <span class="hljs-comment">// 省略部分代码 </span></code></pre><p>用java来实现一些计算型强的业务是一种很好的做法。</p><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h1><p>因为Jinterface是用EPMD进行通信的，所以要把本机的EPMD打开，参考命令如下:</p><pre><code class="hljs ebnf"><span class="hljs-attribute">epmd -daemon</span></code></pre><h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h1><ul><li>[爱立信官方文档] <a href="http://erlang.org/doc/apps/jinterface/jinterface_users_guide.html">http://erlang.org/doc/apps/jinterface/jinterface_users_guide.html</a></li><li>[Maven仓库] <a href="https://mvnrepository.com/artifact/clojang/erlang-jinterface">https://mvnrepository.com/artifact/clojang/erlang-jinterface</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX二次开发-增加点对点通信功能</title>
    <link href="/2020/04/18/clpqt1iu3001o4cuef1e13v2c.html"/>
    <url>/2020/04/18/clpqt1iu3001o4cuef1e13v2c.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要展示一个EMQX的点对点通信插件的开发流程。</p><span id="more"></span><h1 id="1-背景概述"><a href="#1-背景概述" class="headerlink" title="1. 背景概述"></a>1. 背景概述</h1><p>近期在做一个小玩具，使用MQTT协议通信，有个功能：直接实现A客户端直接给B客户端发送消息。常规做法是B订阅一个全局唯一Topic，然后A给这个Topic发送消息，但是我觉得这样操作比较麻烦。于是写了个插件实现了直接发送消息。</p><h1 id="2-相关代码"><a href="#2-相关代码" class="headerlink" title="2. 相关代码"></a>2. 相关代码</h1><p>关于Erlang的基础知识和EMQX的二次开发教程之前的文章已经写了，请没基础的可以先去翻翻历史文章，我这里直接贴关键代码。</p><h2 id="1-核心插件"><a href="#1-核心插件" class="headerlink" title="1.核心插件"></a>1.核心插件</h2><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(ezlinker_p2p_plugin)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;ezlinker_p2p_plugin.hrl&quot;</span>)</span>.<span class="hljs-keyword">-include_lib</span><span class="hljs-params">(<span class="hljs-string">&quot;emqx/include/emqx.hrl&quot;</span>)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([load/<span class="hljs-number">0</span>, register_metrics/<span class="hljs-number">0</span>, unload/<span class="hljs-number">0</span>])</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([on_message_publish/<span class="hljs-number">2</span>])</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([on_client_subscribe/<span class="hljs-number">4</span>])</span>.<span class="hljs-keyword">-define</span><span class="hljs-params">(LOG(Level, Format, Args)</span>,emqx_logger:Level<span class="hljs-params">(<span class="hljs-string">&quot;ezlinker_p2p_plugin: &quot;</span> ++ Format,</span><span class="hljs-params">  Args)</span>).<span class="hljs-function"><span class="hljs-title">register_metrics</span><span class="hljs-params">()</span> -&gt;</span>    [emqx_metrics:new(MetricName) || MetricName &lt;- [&#x27;ezlinker_p2p_plugin.message_publish&#x27;,&#x27;ezlinker_p2p_plugin.client_subscribe&#x27;]].<span class="hljs-function"><span class="hljs-title">load</span><span class="hljs-params">()</span> -&gt;</span>    lists:foreach(<span class="hljs-keyword">fun</span> (&#123;Hook, Fun, Filter&#125;) -&gt;  load_(Hook, binary_to_atom(Fun, utf8), &#123;Filter&#125;)  <span class="hljs-keyword">end</span>,  parse_rule(application:get_env(?APP, hooks, []))).<span class="hljs-function"><span class="hljs-title">unload</span><span class="hljs-params">()</span> -&gt;</span>    lists:foreach(<span class="hljs-keyword">fun</span> (&#123;Hook, Fun, _Filter&#125;) -&gt;  unload_(Hook, binary_to_atom(Fun, utf8))  <span class="hljs-keyword">end</span>,  parse_rule(application:get_env(?APP, hooks, []))).<span class="hljs-function"><span class="hljs-title">load_</span><span class="hljs-params">(Hook, Fun, Params)</span> -&gt;</span><span class="hljs-keyword">case</span> Hook <span class="hljs-keyword">of</span>&#x27;message.publish&#x27;  -&gt; emqx:hook(Hook, <span class="hljs-keyword">fun</span> ?MODULE:Fun/<span class="hljs-number">2</span>, [Params]);&#x27;client.subscribe&#x27; -&gt; emqx:hook(Hook, <span class="hljs-keyword">fun</span> ?MODULE:Fun/<span class="hljs-number">4</span>, [Params])<span class="hljs-keyword">end</span>.unload_(Hook, Fun) -&gt;<span class="hljs-keyword">case</span> Hook <span class="hljs-keyword">of</span>&#x27;message.publish&#x27;  -&gt; emqx:unhook(Hook, <span class="hljs-keyword">fun</span> ?MODULE:Fun/<span class="hljs-number">2</span>);&#x27;client.subscribe&#x27; -&gt; emqx:hook(Hook, <span class="hljs-keyword">fun</span> ?MODULE:Fun/<span class="hljs-number">4</span>)<span class="hljs-keyword">end</span>.<span class="hljs-comment">%%--------------------------------------------------------------------</span>on_message_publish(Message = #message&#123;topic =  &lt;&lt;<span class="hljs-string">&quot;$SYS/&quot;</span>, _/binary&gt;&gt;&#125;, _Env) -&gt;&#123;ok, Message&#125;;<span class="hljs-comment">%%</span>on_message_publish(Message = #message&#123;headers= Headers, topic =  &lt;&lt;<span class="hljs-string">&quot;$p2p/&quot;</span>, Path/binary&gt;&gt;,qos = QOS , payload = Payload ,from = From&#125;, _Env) -&gt;    <span class="hljs-keyword">case</span> Path <span class="hljs-keyword">of</span> &lt;&lt;&gt;&gt; -&gt;io:format(<span class="hljs-string">&quot;P2P Message is empty,will be ignored ~n&quot;</span>),&#123;stop, Message#message&#123;headers = Headers#&#123;allow_publish =&gt; false&#125;&#125; &#125;;PeerClientId -&gt;io:format(<span class="hljs-string">&quot;P2P Message:~p to ~p QOS is:~p ~n&quot;</span>,[ Payload , PeerClientId , QOS ] ),<span class="hljs-keyword">case</span>  ets:lookup(emqx_channel, PeerClientId) <span class="hljs-keyword">of</span>[&#123;_,ChannelPid&#125;] -&gt;P2PMessage = emqx_message:make( From, QOS, &lt;&lt;<span class="hljs-string">&quot;$p2p/&quot;</span>, PeerClientId/binary &gt;&gt; , Payload),            ChannelPid ! &#123;deliver, &lt;&lt;<span class="hljs-string">&quot;$p2p/&quot;</span>, PeerClientId/binary &gt;&gt;, P2PMessage&#125;,io:format(<span class="hljs-string">&quot;P2PMessage is :~p ~n&quot;</span>, [P2PMessage]),&#123;ok, Message&#125;;[]-&gt; io:format(<span class="hljs-string">&quot;PeerClientId mappinged channel pid :~p is not exist ~n&quot;</span>,[PeerClientId]),&#123;stop, Message#message&#123;headers = Headers#&#123;allow_publish =&gt; false&#125;&#125; &#125;    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>;on_message_publish(Message = #message&#123;topic = Topic&#125;, &#123;Filter&#125;) -&gt;with_filter(  <span class="hljs-keyword">fun</span>() -&gt;emqx_metrics:inc(&#x27;ezlinker_p2p_plugin.message_publish&#x27;),<span class="hljs-comment">%% Begin</span><span class="hljs-comment">%% End</span>&#123;ok, Message&#125;  <span class="hljs-keyword">end</span>, Message, Topic, Filter).<span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-comment">%% Client subscribe</span><span class="hljs-comment">%%--------------------------------------------------------------------</span>on_client_subscribe(#&#123;clientid := _C, username := _U&#125;, _P, RawTopicFilters, &#123;_F&#125;) -&gt;  <span class="hljs-comment">%% [&#123;Topic,_OP&#125;] = RawTopicFilters</span>  lists:foreach(<span class="hljs-keyword">fun</span>(&#123;Topic, _OP&#125;) -&gt;        emqx_metrics:inc(&#x27;ezlinker_p2p_plugin.client_subscribe&#x27;),        <span class="hljs-comment">%% Code Start</span>io:format(<span class="hljs-string">&quot;Client sub topic:~p~n&quot;</span>,[Topic]),<span class="hljs-keyword">case</span>  string_start_with(Topic,<span class="hljs-string">&quot;$p2p/&quot;</span>) <span class="hljs-keyword">of</span><span class="hljs-literal">false</span> -&gt;io:format(<span class="hljs-string">&quot;Client nomatch p2p topic~n&quot;</span>),ok;<span class="hljs-literal">true</span> -&gt;io:format(<span class="hljs-string">&quot;Client match p2p topic ,deny~n&quot;</span>),&#123;stop, deny&#125;<span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>, RawTopicFilters).<span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-comment">%% Internal functions</span><span class="hljs-comment">%%--------------------------------------------------------------------</span>parse_rule(Rules) -&gt; parse_rule(Rules, []).parse_rule([], Acc) -&gt; lists:reverse(Acc);parse_rule([&#123;Rule, Conf&#125; | Rules], Acc) -&gt;    Params = emqx_json:decode(iolist_to_binary(Conf)),    Action = proplists:get_value(&lt;&lt;<span class="hljs-string">&quot;action&quot;</span>&gt;&gt;, Params),    Filter = proplists:get_value(&lt;&lt;<span class="hljs-string">&quot;topic&quot;</span>&gt;&gt;, Params),    parse_rule(Rules,       [&#123;list_to_atom(Rule), Action, Filter&#125; | Acc]).with_filter(Fun, _, undefined) -&gt;Fun(), ok;with_filter(Fun, Topic, Filter) -&gt;<span class="hljs-keyword">case</span> emqx_topic:match(Topic, Filter) <span class="hljs-keyword">of</span><span class="hljs-literal">true</span> -&gt; Fun(), ok;<span class="hljs-literal">false</span> -&gt; ok<span class="hljs-keyword">end</span>.with_filter(Fun, _, _, undefined) -&gt; Fun();with_filter(Fun, Msg, Topic, Filter) -&gt;    <span class="hljs-keyword">case</span> emqx_topic:match(Topic, Filter) <span class="hljs-keyword">of</span>      <span class="hljs-literal">true</span> -&gt; Fun();      <span class="hljs-literal">false</span> -&gt; &#123;ok, Msg&#125;<span class="hljs-keyword">end</span>.<span class="hljs-comment">%% start with</span>string_start_with(String,SubString)-&gt;<span class="hljs-keyword">case</span>  string:prefix(String,SubString) <span class="hljs-keyword">of</span>nomatch -&gt;<span class="hljs-literal">false</span>;_ -&gt;<span class="hljs-literal">true</span><span class="hljs-keyword">end</span>.</code></pre><h2 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h2><pre><code class="hljs ini"><span class="hljs-attr">ezlinker_p2p_plugin.hook.message.publish.1</span>      = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_publish&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;<span class="hljs-attr">ezlinker_p2p_plugin.hook.client.subscribe.1</span>     = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_subscribe&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;</code></pre><h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><blockquote><p>p2p不是搞传销的那个p2p，含义是:point to point.</p></blockquote><p>本插件为EMQX新增一个内置topic：<code>$p2p/&#123;client_id&#125;</code>，客户端需要订对点通信的时候，只需要 给topic下客户端id为topic的客户端单独发送一条数据</p><pre><code class="hljs avrasm"><span class="hljs-symbol">topic:</span>$p2p/&#123;client_id&#125;<span class="hljs-symbol">payload:</span>数据内容</code></pre><p>其中<code>&#123;client_id&#125;</code>就是要发送的对端的clientid.如果是python客户端，A客户端给B发送数据，最简单的代码描述应该是这样：</p><pre><code class="hljs python">client.publish(<span class="hljs-string">&#x27;$p2p/client1&#x27;</span>, json.dumps(&#123;a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>&#125;, ensure_ascii=<span class="hljs-literal">False</span>))</code></pre><blockquote><p>注意:<code>&#123;clientId&#125;</code>为空的时候不发送任何数据，也不会返回任何数据</p></blockquote><p>这里给出一个简单的客户端方便测试:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> paho.mqtt.client <span class="hljs-keyword">as</span> mqtt<span class="hljs-keyword">import</span> json<span class="hljs-comment"># 连接成功以后打印</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_connect</span>(<span class="hljs-params">client, userdata, flags, rc</span>):</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected with result code &quot;</span>+<span class="hljs-built_in">str</span>(rc))<span class="hljs-comment"># 注意 我们没有给客户端订阅任何Topic，就可以收的到消息</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_message</span>(<span class="hljs-params">client, userdata, msg</span>):</span>    <span class="hljs-built_in">print</span>(msg.topic+<span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(msg.payload))client = mqtt.Client(<span class="hljs-string">&quot;client1&quot;</span>)client.username_pw_set(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)client.on_connect = on_connectclient.on_message = on_messageclient.connect(<span class="hljs-string">&quot;10.168.1.159&quot;</span>,<span class="hljs-number">1883</span>, <span class="hljs-number">60</span>)client.loop_forever()</code></pre><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h1><ul><li><p>client_id 不可空；</p></li><li><p>不需要订阅 <code>$p2p/</code>,不然会收到2条消息。</p></li><li><p>MQTT标准协议规定：如果两个客户端之间要通信，必须订阅相同的topic。但是这种做法不适合单个客户端之间的直接通信。为了解决类似点对点通信的需求，写了一个简单的插件来实现这个功能。本插件仅仅是为了增强EMQX的功能，不是Mqtt协议的规范，请多大家注意。</p><h1 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h1><p>任何需要单点通信的地方，比如游戏开发，即时聊天，及时控制等等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 lambda表达式在Mqtt消息回调中的应用</title>
    <link href="/2020/04/14/clpqt1iv300544cue31jwg12v.html"/>
    <url>/2020/04/14/clpqt1iv300544cue31jwg12v.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文通过一个简单的Demo来实现C++11环境下的Mqtt消息回调函数</p><span id="more"></span><h1 id="1-本文概述"><a href="#1-本文概述" class="headerlink" title="1.本文概述"></a>1.本文概述</h1><p>近期在用Qt5-C++开发Mqtt客户端的时候，消息回调我用了普通的函数指针的形式，后来发现更骚的是Lambda匿名函数的写法比较精炼，在这里记录学习一下过程。</p><h1 id="2-原始需求"><a href="#2-原始需求" class="headerlink" title="2.原始需求"></a>2.原始需求</h1><p>mqtt消息到达以后，一开始用了一个函数指针来处理：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[], <span class="hljs-keyword">void</span> (*onMessage)(<span class="hljs-keyword">char</span>[], <span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>[]))</span> </span>&#123;<span class="hljs-built_in">onMessage</span>(msg,  qos,  topic);&#125;</code></pre><p>当消息到达的时候我们只需要实现这个onMessage函数就行：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">onMessage</span> <span class="hljs-params">(<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[])</span> </span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;onMessage:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;MSG:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot; QOS:&quot;</span> &lt;&lt; qos &lt;&lt; <span class="hljs-string">&quot; Topic:&quot;</span> &lt;&lt; topic &lt;&lt; endl;&#125;;</code></pre><p>调用：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> topic[] = <span class="hljs-string">&quot;test/&quot;</span>;<span class="hljs-keyword">char</span> msg[] = <span class="hljs-string">&quot;json&quot;</span>;<span class="hljs-keyword">int</span> qos = <span class="hljs-number">1</span>;<span class="hljs-built_in">handleMsg</span>(msg, qos, topic, onMessage);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>到这里即可实现消息回调。上面是经典的函数指针的形式来实现的。</p><h1 id="3-改造函数"><a href="#3-改造函数" class="headerlink" title="3.改造函数"></a>3.改造函数</h1><p>我们换个更精炼的方法来实现，使用C++11的Lambda表达式，改造一下onMessage;</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> topic[] = <span class="hljs-string">&quot;test/&quot;</span>;<span class="hljs-keyword">char</span> msg[] = <span class="hljs-string">&quot;json&quot;</span>;<span class="hljs-keyword">int</span> qos = <span class="hljs-number">1</span>;<span class="hljs-built_in">handleMsg</span>(msg, qos, topic, [](<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;onMessage:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;MSG:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot; QOS:&quot;</span> &lt;&lt; qos &lt;&lt; <span class="hljs-string">&quot; Topic:&quot;</span> &lt;&lt; topic &lt;&lt; endl;&#125;);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>直接传入匿名内部函数就可以实现，这样看起来更加精炼，看起来像是“函数定义和调用同时发生”。拆解一下看，这段代码：</p><pre><code class="hljs c++">[](<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;onMessage:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;MSG:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot; QOS:&quot;</span> &lt;&lt; qos &lt;&lt; <span class="hljs-string">&quot; Topic:&quot;</span> &lt;&lt; topic &lt;&lt; endl;&#125;</code></pre><p>其实是一个简化写法：</p><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> onMessage[](<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[]) &#123;cout &lt;&lt; <span class="hljs-string">&quot;onMessage:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;MSG:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot; QOS:&quot;</span> &lt;&lt; qos &lt;&lt; <span class="hljs-string">&quot; Topic:&quot;</span> &lt;&lt; topic &lt;&lt; endl;&#125;</code></pre><p>而我们的回调原型：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleMsg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> msg[], <span class="hljs-keyword">int</span> qos, <span class="hljs-keyword">char</span> topic[], <span class="hljs-keyword">void</span> (*onMessage)(<span class="hljs-keyword">char</span>[], <span class="hljs-keyword">int</span>, <span class="hljs-keyword">char</span>[]))</span> </span>&#123;<span class="hljs-built_in">onMessage</span>(msg,  qos,  topic);&#125;</code></pre><p>最后一个参数其实就是函数。利用了C++11的Lambda函数特性，可以省去名称。</p>]]></content>
    
    
    <categories>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔改爱立信的ErlangJavaInterface库</title>
    <link href="/2020/03/29/clpqt1iuh00334cue6g9n7tds.html"/>
    <url>/2020/03/29/clpqt1iuh00334cue6g9n7tds.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲了Jinterface的基本使用方法。</p><span id="more"></span><h1 id="魔改爱立信的ErlangJavaInterface库"><a href="#魔改爱立信的ErlangJavaInterface库" class="headerlink" title="魔改爱立信的ErlangJavaInterface库"></a>魔改爱立信的ErlangJavaInterface库</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>近期在用JInterface实现一些功能，发现爱立信提供的Java库已经很老了，最后一个版本是2004年写的，至今已经无人维护。<br>有很多蹩脚的语法和写法，现在看来非常奇怪。据说是开源的但是我找不到源码地址，有知道的朋友可以联系一下我。于是我用了一个<br>极端的办法：反编译代码，修改部分问题。好在源码数量不是很多，如果熟悉Erlang和Otp的一些基础概念，还是能看得懂的。我改的东西不多，<br>主要还是一些模棱两可的命名，还有写了一些Demo给大家学习。</p><h2 id="2-基础教程"><a href="#2-基础教程" class="headerlink" title="2. 基础教程"></a>2. 基础教程</h2><p>JInterface的主要功能就是用Java来模拟ErlangNode节点，实现一个“假装节点”，从而和真正的Erlang节点或者集群通信。所以这个库适用于想<br>用Java来扩展Erlang的项目，比如用Java实现一些Erlang不支持的驱动，或者是库。当前我主要用在用Java来连接Mongodb4.0以上的版本。</p><h2 id="3-一个简单的Demo"><a href="#3-一个简单的Demo" class="headerlink" title="3. 一个简单的Demo"></a>3. 一个简单的Demo</h2><p>官方给出的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ericsson.otp.erlang.OtpNode;  <span class="hljs-keyword">import</span> com.ericsson.otp.erlang.OtpMbox;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReceiveMessage</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;          OtpNode node = <span class="hljs-keyword">new</span> OtpNode(<span class="hljs-string">&quot;javaNode1@127.0.0.1&quot;</span>);            OtpMbox mbox = node.createMbox();          mbox.registerName(<span class="hljs-string">&quot;java&quot;</span>);          System.out.println(<span class="hljs-string">&quot;开始监控消息&quot;</span>);          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;              System.out.println(<span class="hljs-string">&quot;收到消息:&quot;</span>+mbox.receive());        &#125;      &#125;  &#125;</code></pre><p>但是上面的代码不利于掌控连接状态，比如中断，中断恢复等等，我简单的改了一下代码，实现了状态监控回调。经过修改的代码如下所示：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.otpsupport;<span class="hljs-keyword">import</span> com.ezlinker.otpsupport.ericsson.otp.erlang.*;<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<span class="hljs-comment">/**</span><span class="hljs-comment"> * OTP Java连接器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaOtpNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 连接状态</span><span class="hljs-comment">     * false:连接失败</span><span class="hljs-comment">     * true：连接成功</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> OtpConnectListener otpConnectListener;    <span class="hljs-keyword">private</span> String nodeName;    <span class="hljs-keyword">private</span> String selfName;    <span class="hljs-keyword">private</span> String peerName;    <span class="hljs-keyword">private</span> String cookie;    <span class="hljs-keyword">private</span> OtpNode otpNode;    <span class="hljs-keyword">private</span> OtpMailBox otpMailBox;    <span class="hljs-keyword">private</span> OtpConnection connection;    <span class="hljs-function"><span class="hljs-keyword">public</span> OtpConnection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> connection;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnection</span><span class="hljs-params">(OtpConnection connection)</span> </span>&#123;        <span class="hljs-keyword">this</span>.connection = connection;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaOtpNode</span><span class="hljs-params">(String nodeName, String selfName, String peerName, String cookie)</span> </span>&#123;        <span class="hljs-keyword">this</span>.nodeName = nodeName;        <span class="hljs-keyword">this</span>.selfName = selfName;        <span class="hljs-keyword">this</span>.peerName = peerName;        <span class="hljs-keyword">this</span>.cookie = cookie;        setName(<span class="hljs-string">&quot;JavaOtpNodeThread&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addListener</span><span class="hljs-params">(OtpConnectListener otpConnectListener)</span> </span>&#123;        <span class="hljs-keyword">this</span>.otpConnectListener = otpConnectListener;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.otpNode = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.otpMailBox = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.connection = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">this</span>.otpNode = <span class="hljs-keyword">new</span> OtpNode(<span class="hljs-keyword">this</span>.nodeName, <span class="hljs-keyword">this</span>.cookie);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">this</span>.otpConnectListener.onError(e);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (otpNode.ping(<span class="hljs-keyword">this</span>.peerName, <span class="hljs-number">1000</span>)) &#123;            <span class="hljs-keyword">this</span>.otpConnectListener.onConnect();            <span class="hljs-keyword">this</span>.otpMailBox = otpNode.createMailBox();            <span class="hljs-keyword">this</span>.otpMailBox.registerName(<span class="hljs-string">&quot;ezlinker_core_node1_receive_loop&quot;</span>);            <span class="hljs-keyword">this</span>.otpNode.registerStatusHandler(<span class="hljs-keyword">new</span> OtpNodeStatusListener() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remoteStatus</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> up, Object info)</span> </span>&#123;                    System.out.println(<span class="hljs-string">&quot;远程节点状态: &quot;</span> + node + <span class="hljs-string">&quot; &quot;</span> + up + <span class="hljs-string">&quot; &quot;</span> + info.toString());                    <span class="hljs-keyword">if</span> (up) &#123;                        System.out.println(<span class="hljs-string">&quot;远程节点开启:&quot;</span> + node);                    &#125; <span class="hljs-keyword">else</span> &#123;                        System.out.println(<span class="hljs-string">&quot;远程节点关闭:&quot;</span> + node);                    &#125;                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localStatus</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> up, Object info)</span> </span>&#123;                    System.out.println(<span class="hljs-string">&quot;本地节点状态: &quot;</span> + node + <span class="hljs-string">&quot; &quot;</span> + up + <span class="hljs-string">&quot; &quot;</span> + info.toString());                &#125;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connAttempt</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> incoming, Object info)</span> </span>&#123;                    System.out.println(<span class="hljs-string">&quot;重新连接 &quot;</span> + node + <span class="hljs-string">&quot; &quot;</span> + incoming + <span class="hljs-string">&quot; &quot;</span> + info.toString());                &#125;            &#125;);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    OtpErlangObject erlangObject = <span class="hljs-keyword">this</span>.otpMailBox.receive();                    System.out.println(erlangObject.toString());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    <span class="hljs-keyword">this</span>.otpConnectListener.onError(e);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>我在官方的基础上加了一个<code>OtpNodeStatusListener</code>来实现状态监控。通过回调实现了连接状态监控：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtpNodeStatusListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remoteStatus</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> up, Object info)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">localStatus</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> up, Object info)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connAttempt</span><span class="hljs-params">(String node, <span class="hljs-keyword">boolean</span> incoming, Object info)</span></span>;&#125;</code></pre><p>同时实现了一个简单的看门狗:<code>OtpNodeSupervisor</code>，当连接失败的时候，重启连接线程:</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.otpsupport;<span class="hljs-keyword">import</span> com.ezlinker.otpsupport.ericsson.otp.erlang.OtpNode;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 节点连接监控器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtpNodeSupervisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    ExecutorService pool = Executors.newSingleThreadExecutor(Thread::<span class="hljs-keyword">new</span>);    <span class="hljs-keyword">private</span> JavaOtpNode javaOtpNode;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OtpNodeSupervisor</span><span class="hljs-params">(JavaOtpNode javaOtpConnector)</span> </span>&#123;        <span class="hljs-keyword">this</span>.javaOtpNode = javaOtpConnector;        setName(<span class="hljs-string">&quot;OtpNodeSupervisorThread&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 如果线程存活 就使劲ping</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);                OtpNode otpNode = <span class="hljs-keyword">this</span>.javaOtpNode.getOtpNode();                <span class="hljs-keyword">if</span> (otpNode != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">boolean</span> result = otpNode.ping(<span class="hljs-keyword">this</span>.javaOtpNode.getPeerName(), <span class="hljs-number">500</span>);                    <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">false</span>) &#123;                        pool.execute(<span class="hljs-keyword">this</span>.javaOtpNode);                        <span class="hljs-comment">//System.out.println(&quot;节点已经连接失败:&quot; + this.javaOtpNode.getName());</span>                    &#125;                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>如果在使用过程中有问题可联系本人.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
      <tag>Java</tag>
      
      <tag>Jinterface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PlatformIo-基于Arduino框架开发单片机</title>
    <link href="/2020/03/23/clpqt1iwd00ah4cue9kpzgnc4.html"/>
    <url>/2020/03/23/clpqt1iwd00ah4cue9kpzgnc4.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下使用PlatformIo，基于Arduino框架开发单片机项目。</p><span id="more"></span><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><p>​        目前玩Arduino的朋友，用得最多的也许是Arduino官方的ArduinoIDE，说实话这个IDE真不好用，甚至不如一个记事本。有时候启动速度简直不能忍受，还有包管理做的也不好。依赖都不清楚。这种情况下可能大家很想要一个友好的IDE来开发Arduino应用。刚好，PlatformIo配合Vscode可以做。</p><h1 id="2-关于PlatformIo"><a href="#2-关于PlatformIo" class="headerlink" title="2.关于PlatformIo"></a>2.关于PlatformIo</h1><p>​        PlatformIO 是开源的物联网开发生态系统。提供跨平台的代码构建器、集成开发环境（IDE），兼容 Arduino，ESP8266等。甚至说是一个框架，子啊这个框架之下我们除了可以开发Arduino，还可以开发Arm甚至是WindowsAPP。</p><h1 id="4-PlatformIo安装"><a href="#4-PlatformIo安装" class="headerlink" title="4.PlatformIo安装"></a>4.PlatformIo安装</h1><h2 id="1-通过VScode安装"><a href="#1-通过VScode安装" class="headerlink" title="1.通过VScode安装"></a>1.通过VScode安装</h2><p>直接通过插件搜索【PlatformIo】即可：</p><p><img src="/uploads/platformio-ide-vscode-pkg-installer.png" alt="platformio-ide-vscode-pkg-installer.png"></p><h2 id="2-命令行安装"><a href="#2-命令行安装" class="headerlink" title="2.命令行安装"></a>2.命令行安装</h2><p>因为PlatformIo是Python实现的一个库，所以可以直接用Python的Pip包管理器安装：</p><pre><code class="hljs python">Py2：pip install -U platformioPy3：pip3 install -U platformio</code></pre><h2 id="3-更多安装方式"><a href="#3-更多安装方式" class="headerlink" title="3.更多安装方式"></a>3.更多安装方式</h2><p>​        除此之外还支持其他IDE或者编辑器安装，请参考这里：<a href="https://docs.platformio.org/en/latest/core/installation.html">https://docs.platformio.org/en/latest/core/installation.html</a></p><h1 id="3-Arduino初试"><a href="#3-Arduino初试" class="headerlink" title="3.Arduino初试"></a>3.Arduino初试</h1><p>​        我们试着来新建一个Arduino项目。这里我们假设项目名字就叫:HelloWorld.首先在硬盘上新建一个目录：HelloWorld.</p><pre><code class="hljs shell">mkdir HelloWorldcd HelloWorld</code></pre><p>​         然后初始化项目：</p><pre><code class="hljs shell">platformio project init --board uno</code></pre><p>​        表示我们新建了一个项目，使用了uno开发板作为基础的硬件。</p><p>​        如何添加依赖？首先找到<code>platformio.ini</code>这个文件，其实这个文件类似Java项目中常见依赖工具的Mavel的pom.xml,或者是node项目中的package.json,都是用来统一管理依赖的。依赖文件如下所示：</p><pre><code class="hljs ini"><span class="hljs-section">[env:uno]</span><span class="hljs-attr">platform</span> = atmelavr<span class="hljs-attr">framework</span> = ardui<span class="hljs-literal">no</span><span class="hljs-attr">board</span> = u<span class="hljs-literal">no</span></code></pre><p>​        表示我们使用的是atmelavr这个平台的硬件库，用了Arduino的框架来对uno开发板进行开发。然后我们在src目录下新建一个main.cpp的入口文件，下面的代码想必大家很熟悉了，这里就不做赘述。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Arduino.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LED_BUILTIN</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LED_BUILTIN 13</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">pinMode</span>(LED_BUILTIN, OUTPUT);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">digitalWrite</span>(LED_BUILTIN, HIGH);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">digitalWrite</span>(LED_BUILTIN, LOW);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);&#125;</code></pre><p>​        到此为止，我们的项目基本结构就完成了，目录结构如下：</p><pre><code class="hljs txt">HelloWorld├── lib│   └── README├── platformio.ini└── src    └── main.cpp</code></pre><p>​        如果你做过WEB开发，就很清楚node和maven这两个依赖管理的处理步骤，项目新建好了以后就开始构建。</p><ul><li><code>platformio run</code> 下载依赖</li><li><code>platformio run --target upload</code>：编译上传</li><li><code>platformio run --target clean</code>：清理编译结果</li><li><code>platformio run -e uno</code>：编译指定的Profile，比如我们常见的dev，prod，test等等</li><li><code>platformio run -e uno -t upload</code>：编译指定的Profile，然后上传。</li></ul><p><img src="/uploads/platformio-demo-wiring.gif" alt="/platformio-demo-wiring.gif"></p><p>​        在此有一个已经写好的ESP通过Mqtt传输数据的Demo项目，供给大家学习参考：<a href="https://github.com/wwhai/ezlinker_arduino_sdk">https://github.com/wwhai/ezlinker_arduino_sdk</a></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>​        本文主要介绍了一种全新的开发Arduino的方法，希望能有助于大家提高开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>物联网高级开发技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>PlatformIo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PlatformIo-ESP32接入MQTT服务器</title>
    <link href="/2020/03/23/clpqt1iwd00af4cue60vy9m0a.html"/>
    <url>/2020/03/23/clpqt1iwd00af4cue60vy9m0a.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一个简单案例：通过PlatformIO来开发ESP32开发板，使其可以通过MQTT协议连接服务器发送数据。</p><span id="more"></span><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>之前的文章有讲怎么安装PlatformIO，如果没有环境，先驱翻一下前面的文章。本文主要直接讲一个简单的实践。</p><h1 id="2-新建项目"><a href="#2-新建项目" class="headerlink" title="2.新建项目"></a>2.新建项目</h1><h2 id="1-首先添加依赖"><a href="#1-首先添加依赖" class="headerlink" title="1.首先添加依赖"></a>1.首先添加依赖</h2><p>在<code>platformio.ini</code>中添加如下内容：</p><pre><code class="hljs ini"><span class="hljs-section">[env:esp32dev]</span><span class="hljs-attr">monitor_speed</span> = <span class="hljs-number">115200</span><span class="hljs-attr">platform</span> = espressif32<span class="hljs-attr">board</span> = esp32dev<span class="hljs-attr">framework</span> = ardui<span class="hljs-literal">no</span><span class="hljs-attr">lib_deps</span> =  AsyncMqttClient</code></pre><h2 id="2-构建项目"><a href="#2-构建项目" class="headerlink" title="2.构建项目"></a>2.构建项目</h2><pre><code class="hljs applescript">pio <span class="hljs-built_in">run</span></code></pre><p>到这里要是没问题的话，可以一路顺利进行下去。</p><h2 id="3-源码解释"><a href="#3-源码解释" class="headerlink" title="3.源码解释"></a>3.源码解释</h2><p>接下来直接讲一下源代码：</p><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">This example uses FreeRTOS softwaretimers as there is no built-in Ticker library</span><span class="hljs-comment">*/</span><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;freertos/FreeRTOS.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;freertos/timers.h&quot;</span></span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;AsyncMqttClient.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EEPROM.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WiFi.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WiFiType.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;esp_event.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-comment">// WIFI SSID</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIFI_SSID <span class="hljs-meta-string">&quot;206-public&quot;</span></span><span class="hljs-comment">// WIFI 密码</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIFI_PASSWORD <span class="hljs-meta-string">&quot;665544332211&quot;</span></span><span class="hljs-comment">// MQTT Server</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MQTT_HOST IPAddress(192, 168, 2, 142)</span><span class="hljs-comment">// MQTT 端口</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MQTT_PORT 1883</span><span class="hljs-comment">// 下行</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *c2sTopic = <span class="hljs-string">&quot;687giyhbU^&amp;YYHOU/c2s&quot;</span>;<span class="hljs-comment">// 上行</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s2cTopic = <span class="hljs-string">&quot;687giyhbU^&amp;YYHOU/s2c&quot;</span>;<span class="hljs-comment">// 状态</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *stateTopic = <span class="hljs-string">&quot;687giyhbU^&amp;YYHOU/state&quot;</span>;AsyncMqttClient asyncMqttClient;TimerHandle_t mqttReconnectTimer;TimerHandle_t wifiReconnectTimer;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connectToWifi</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Connecting to Wi-Fi...&quot;</span>);  WiFi.<span class="hljs-built_in">begin</span>(WIFI_SSID, WIFI_PASSWORD);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connectToMqtt</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Connecting to mqtt server...&quot;</span>);  asyncMqttClient.<span class="hljs-built_in">setClientId</span>(<span class="hljs-string">&quot;687giyhbU^&amp;YYHOU&quot;</span>);  asyncMqttClient.<span class="hljs-built_in">setCredentials</span>(<span class="hljs-string">&quot;Y&amp;TOHUBo8yhiol&amp;UJ)&quot;</span>, <span class="hljs-string">&quot;&amp;UNBkjL63541tgHB&quot;</span>);  asyncMqttClient.<span class="hljs-built_in">connect</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WiFiEvent</span><span class="hljs-params">(WiFiEvent_t event)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// Serial.printf(&quot;[WiFi-event] event: %d\n&quot;, event);</span>  <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (event)  &#123;  <span class="hljs-keyword">case</span> SYSTEM_EVENT_STA_GOT_IP:    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WiFi connected&quot;</span>);    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IP address: &quot;</span>);    Serial.<span class="hljs-built_in">println</span>(WiFi.<span class="hljs-built_in">localIP</span>());    <span class="hljs-built_in">connectToMqtt</span>();    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> SYSTEM_EVENT_STA_DISCONNECTED:    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WiFi lost connection&quot;</span>);    <span class="hljs-comment">// 当WIFI链接失败的时候,需要停止MQTT的连接定时器</span>    <span class="hljs-built_in">xTimerStop</span>(mqttReconnectTimer, <span class="hljs-number">0</span>);    <span class="hljs-built_in">xTimerStart</span>(wifiReconnectTimer, <span class="hljs-number">0</span>);    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">default</span>:    <span class="hljs-keyword">break</span>;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * MQtt连接成功以后,订阅s2c,QOS=2</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMqttConnect</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> sessionPresent)</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connected to MQTT;Session present:&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(sessionPresent);  asyncMqttClient.<span class="hljs-built_in">subscribe</span>(s2cTopic, <span class="hljs-number">2</span>);  <span class="hljs-comment">// asyncMqttClient.publish(&quot;test/lol&quot;, 0, true, &quot;test 1&quot;);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMqttDisconnect</span><span class="hljs-params">(AsyncMqttClientDisconnectReason reason)</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Disconnected from MQTT server.&quot;</span>);  <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">isConnected</span>())  &#123;    <span class="hljs-built_in">xTimerStart</span>(mqttReconnectTimer, <span class="hljs-number">0</span>);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMqttMessage</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *topic, <span class="hljs-keyword">char</span> *payload, AsyncMqttClientMessageProperties properties, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">size_t</span> total)</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Data received:&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(payload);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMqttPublish</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> packetId)</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Publish successfully.&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;EZlinker sdk V0.1&quot;</span>);  mqttReconnectTimer = <span class="hljs-built_in">xTimerCreate</span>(<span class="hljs-string">&quot;mqttTimer&quot;</span>, <span class="hljs-built_in">pdMS_TO_TICKS</span>(<span class="hljs-number">2000</span>), pdFALSE, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">0</span>, <span class="hljs-keyword">reinterpret_cast</span>&lt;TimerCallbackFunction_t&gt;(connectToMqtt));  wifiReconnectTimer = <span class="hljs-built_in">xTimerCreate</span>(<span class="hljs-string">&quot;wifiTimer&quot;</span>, <span class="hljs-built_in">pdMS_TO_TICKS</span>(<span class="hljs-number">2000</span>), pdFALSE, (<span class="hljs-keyword">void</span> *)<span class="hljs-number">0</span>, <span class="hljs-keyword">reinterpret_cast</span>&lt;TimerCallbackFunction_t&gt;(connectToWifi));  WiFi.<span class="hljs-built_in">onEvent</span>(WiFiEvent);  asyncMqttClient.<span class="hljs-built_in">onConnect</span>(onMqttConnect);  asyncMqttClient.<span class="hljs-built_in">onDisconnect</span>(onMqttDisconnect);  asyncMqttClient.<span class="hljs-built_in">onMessage</span>(onMqttMessage);  asyncMqttClient.<span class="hljs-built_in">onPublish</span>(onMqttPublish);  asyncMqttClient.<span class="hljs-built_in">setServer</span>(MQTT_HOST, MQTT_PORT);  <span class="hljs-built_in">connectToWifi</span>();&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;&#125;</code></pre><p>其中比较重要的是：</p><pre><code class="hljs c"><span class="hljs-comment">// WIFI SSID</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIFI_SSID <span class="hljs-meta-string">&quot;206-public&quot;</span></span><span class="hljs-comment">// WIFI 密码</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIFI_PASSWORD <span class="hljs-meta-string">&quot;665544332211&quot;</span></span><span class="hljs-comment">// MQTT Server</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MQTT_HOST IPAddress(192, 168, 2, 142)</span><span class="hljs-comment">// MQTT 端口</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MQTT_PORT 1883</span></code></pre><p>上述代码就是用来配置MQTT服务器的，包含了WIFI的SSID，密码，服务器的IP，端口等等。</p><p>而数据接收相关代码在这个函数中实现：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onMqttMessage</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *topic, <span class="hljs-keyword">char</span> *payload, AsyncMqttClientMessageProperties properties, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">size_t</span> index, <span class="hljs-keyword">size_t</span> total)</span></span><span class="hljs-function"></span>&#123;  Serial.print(<span class="hljs-string">&quot;Data received:&quot;</span>);  Serial.println(payload);&#125;</code></pre><p>你可以在这里解析相关的数据格式，比如JSON，XML。</p><p>如果需要上报数据，可以用这个函数：</p><pre><code class="hljs c++">asyncMqttClient.<span class="hljs-built_in">publish</span>(<span class="hljs-string">&quot;上报的Topic&quot;</span>, 【Qos：<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>】, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;数据内容&quot;</span>);</code></pre><h2 id="4-服务器搭建"><a href="#4-服务器搭建" class="headerlink" title="4.服务器搭建"></a>4.服务器搭建</h2><p>前期测试阶段建议使用EMQ作为本地测试节点。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>本文给出了一个简单的Demo，通过ESP32开发板来实现和MQTT服务器互联，大家可以尝试一下，逐步实现状态监控，比如用LED实现网络状态监控，或者用OLED实现监控。还有一些比较复杂的操作，比如自动配网，保存配置到flash中，希望大家可以多多交流。</p>]]></content>
    
    
    <categories>
      
      <category>物联网高级开发技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>PlatformIo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX二次开发教程（高级篇）</title>
    <link href="/2020/03/23/clpqt1iu1001j4cueer9dhx30.html"/>
    <url>/2020/03/23/clpqt1iu1001j4cueer9dhx30.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲解用Erlang Java Interface实现和Erlang节点通信.</p><span id="more"></span><h1 id="1-本文概述"><a href="#1-本文概述" class="headerlink" title="1.本文概述"></a>1.本文概述</h1><p>近期准备用EMQ来实现一个业务:吧数据保存到MongoDb 里面,但是发现一个问题:Erlang的MongoDb 驱动版本太老,甚至是10年前的版本,只支持到MongoDb 3.0阶段.但是我们的需求是在MongoDb 4.0上进行.于是我找遍github还有其他的代码平台,都没找到合适的驱动.工作陷入僵局.</p><p>这几天在看Erlang的官网文档,突然看到几个单词:Erlang Jinterface:</p><blockquote><p>The <strong><a href="http://erlang.org/doc/apps/jinterface/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a></strong> package provides a set of tools for communication with Erlang processes. It can also be used for communication with other Java processes using the same package, as well as C processes using the Erl_Interface library.</p></blockquote><p>深入看了文档以后发现Jinterface是Erlang的Java接口,可以实现Java和Erlang节点直接通信.看到这里顿时来了希望,Java各种数据库驱动都有,我们可以用Java接口来实现这部分业务.</p><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h1><p>在此之前,我们先准备一下开发环境:</p><ol><li>JDK:8以上</li><li>Erlang:22以上</li><li>EMQX:4.0以上</li></ol><p>好了,准备好这些以后我们就开始写代码吧.</p><h1 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3.实现细节"></a>3.实现细节</h1><h2 id="1-Java项目准备"><a href="#1-Java项目准备" class="headerlink" title="1.Java项目准备"></a>1.Java项目准备</h2><p>我们需要新建一个Maven项目,把OTP的库依赖进去:</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.erlang.otp/jinterface --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.erlang.otp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jinterface<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>然后新建一个Main类,按照正常的流程,在main方法里面加入下面的代码:</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.ericsson.otp.erlang.OtpEpmd;<span class="hljs-keyword">import</span> com.ericsson.otp.erlang.OtpMbox;<span class="hljs-keyword">import</span> com.ericsson.otp.erlang.OtpNode;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 测试Erlang Interface</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErlangNodeTest1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String nodeName = <span class="hljs-string">&quot;ezlinker_core_node1@127.0.0.1&quot;</span>;        String receiveLoopProcessName = <span class="hljs-string">&quot;ezlinker_core_node1_receive_loop&quot;</span>;        OtpNode otpNode = <span class="hljs-keyword">new</span> OtpNode(nodeName, <span class="hljs-string">&quot;emqxsecretcookie&quot;</span>);        <span class="hljs-keyword">if</span> (otpNode.ping(<span class="hljs-string">&quot;emqx@127.0.0.1&quot;</span>, <span class="hljs-number">5</span>)) &#123;            System.out.println(<span class="hljs-string">&quot;远程节点启动&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">&quot;远程节点停止&quot;</span>);        &#125;        OtpMbox otpMbox = otpNode.createMbox();        otpMbox.registerName(receiveLoopProcessName);        System.out.println(<span class="hljs-string">&quot;start to listen.....&quot;</span>);        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            System.out.println(<span class="hljs-string">&quot;收到Erlang节点的消息:&quot;</span> + otpMbox.receiveMsg().getMsg());        &#125;    &#125;&#125;</code></pre><p>注意:这里仅仅是做个Demo,并不能生产,有经验可以把这段代码移植到比如Spring上.到这里你肯定很兴奋，直接把main运行了一下，结果很失望：抛出异常了：</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.io.IOException: Nameserver not responding on <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> when publishing ezlinker_core_node1at com.ericsson.otp.erlang.OtpEpmd.r4_publish(OtpEpmd.java:<span class="hljs-number">344</span>)at com.ericsson.otp.erlang.OtpEpmd.publishPort(OtpEpmd.java:<span class="hljs-number">141</span>)at com.ericsson.otp.erlang.OtpNode$Acceptor.publishPort(OtpNode.java:<span class="hljs-number">784</span>)at com.ericsson.otp.erlang.OtpNode$Acceptor.&lt;init&gt;(OtpNode.java:<span class="hljs-number">776</span>)at com.ericsson.otp.erlang.OtpNode.init(OtpNode.java:<span class="hljs-number">232</span>)at com.ericsson.otp.erlang.OtpNode.&lt;init&gt;(OtpNode.java:<span class="hljs-number">196</span>)at com.ericsson.otp.erlang.OtpNode.&lt;init&gt;(OtpNode.java:<span class="hljs-number">149</span>)at com.ezlinker.app.ErlangNodeTest1.main(ErlangNodeTest1.java:<span class="hljs-number">17</span>)</code></pre><p>稳住！！！其实到这里还没有准备完整，接下来还有很多要做。</p><h2 id="2-EMQX插件准备"><a href="#2-EMQX插件准备" class="headerlink" title="2.EMQX插件准备"></a>2.EMQX插件准备</h2><p>上面准备好Java方面的工作以后，我们来准备Erlang和EMQX，在这里我假设你的电脑上已经装好了Erlang环境，最低版本22，如果没有请上官网自己下载。</p><p>接下来我们新建一个EMQX的插件和Java写的Node通信。</p><ol><li><p>安装rebar3（不做讲解，请网上自行下载安装对应版本）；</p></li><li><p>安装EMQX官方给出的插件工具（注意：Linux环境下）：</p><pre><code class="hljs shell">mkdir -p ~/.config/rebar3/templatesgit clone https://github.com/emqx/rebar3_emqx_plugin ~/.config/rebar3/templates</code></pre></li><li><p>然后新建一个插件：</p><pre><code class="hljs shell">rebar3 new emqx-plugin &lt;plugin-name&gt;</code></pre><p>我新建的插件名字是：<code>ezlinker_core_plugin</code>:</p><pre><code class="hljs shell">rebar3 new emqx-plugin `ezlinker_core_plugin`</code></pre></li><li><p>增加配置参数：</p><p>首先在<code>etc</code>目录下找到<code>ezlinker_core_plugin.conf</code>文件，里面的内容如下：</p><pre><code class="hljs erlang">ezlinker_core_plugin.hook.client.connected.<span class="hljs-number">1</span>     = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_connected&quot;</span>&#125;ezlinker_core_plugin.hook.client.disconnected.<span class="hljs-number">1</span>  = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_disconnected&quot;</span>&#125;ezlinker_core_plugin.hook.client.subscribe.<span class="hljs-number">1</span>     = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_subscribe&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.client.unsubscribe.<span class="hljs-number">1</span>   = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_unsubscribe&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.session.subscribed.<span class="hljs-number">1</span>   = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_subscribed&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.session.unsubscribed.<span class="hljs-number">1</span> = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_unsubscribed&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.message.publish.<span class="hljs-number">1</span>      = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_publish&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.message.delivered.<span class="hljs-number">1</span>    = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_delivered&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;ezlinker_core_plugin.hook.message.acked.<span class="hljs-number">1</span>        = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_acked&quot;</span>, <span class="hljs-string">&quot;topic&quot;</span>: <span class="hljs-string">&quot;#&quot;</span>&#125;</code></pre><p>我们在最后加上自己的配置项：</p><pre><code class="hljs erlang">## ezlinker core  node configezlinker_core_plugin.node.name = ezlinker_core_node1@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span></code></pre><p>找到插件目录下的<code>priv</code>目录，最后一行加入：</p><pre><code class="hljs erlang">&#123;mapping, <span class="hljs-string">&quot;ezlinker_core_plugin.node.name&quot;</span>, <span class="hljs-string">&quot;ezlinker_core_plugin.node_name&quot;</span>, [  &#123;datatype, string&#125;]&#125;.</code></pre><p>其中mapping的作用是把配置项的键映射到插件的值，具体格式如下：</p><pre><code class="hljs erlang">&#123;mapping, <span class="hljs-string">&quot;conf中的配置项名字&quot;</span>, <span class="hljs-string">&quot;插件名.插件中使用的项名&quot;</span>, [  &#123;datatype, string&#125;]&#125;.</code></pre><p>是不是不耐烦了？其实到这里才刚开始，上述步骤仅仅是我们生成了一个插件，并且注册进了EMQ，能不能发挥作用还不一定呢。接下来我们就开始对这个插件进行简单的开发。</p></li></ol><h2 id="3-插件开发"><a href="#3-插件开发" class="headerlink" title="3.插件开发"></a>3.插件开发</h2><p>我们目前实现一个最简单的功能：把EMQX的所有消息全部丢给JavaNode去处理。</p><p>先打开：<code>ezlinker_core_plugin.erl</code>,找到publish相关的代码（大概在155行位置处）：</p><pre><code class="hljs erlang"><span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-comment">%% Message publish</span><span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-title">on_message_publish</span><span class="hljs-params">(Message = #message&#123;topic = &lt;&lt;<span class="hljs-string">&quot;$SYS/&quot;</span>, _/binary&gt;&gt;&#125;, _Env)</span> -&gt;</span>    &#123;ok, Message&#125;;<span class="hljs-function"><span class="hljs-title">on_message_publish</span><span class="hljs-params">(Message = #message&#123;topic = Topic, flags = #&#123;retain := Retain&#125;&#125;, &#123;Filter&#125;)</span> -&gt;</span>    EZlinkerNodeName = application:get_env(?APP, node_name, &#x27;ezlinker_core_node1@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>&#x27;),    with_filter(      <span class="hljs-keyword">fun</span>() -&gt;        emqx_metrics:inc(&#x27;ezlinker_core_plugin.message_publish&#x27;),          // 核心代码        &#123;ezlinker_core_node1_receive_loop,list_to_atom(EZlinkerNodeName)&#125;!&#123;self(),Message&#125;,        &#123;ok, Message&#125;      <span class="hljs-keyword">end</span>, Message, Topic, Filter).</code></pre><p>加入以下代码：</p><pre><code class="hljs erlang">&#123;ezlinker_core_node1_receive_loop,list_to_atom(EZlinkerNodeName)&#125;!&#123;self(),Message&#125;,</code></pre><p>上面代码表示，EMQX内部产生的消息全部转发倒=到我们配置的那个节点上面。</p><p>到此为止，我们的插件就开发好了，接下来准备运行起来。</p><h2 id="4-插件加载"><a href="#4-插件加载" class="headerlink" title="4.插件加载"></a>4.插件加载</h2><p>我们还需要维护一个发布EMQX的项目：emqx-rel：<code>https://github.com/emqx/emqx-rel.git</code>。首先需要fork下来，然后做个简单配置，目的是把插件加载进EMQX里面。</p><p>在emqx-rel项目中找到rebar.config,在deps节点加入以下配置：</p><pre><code class="hljs erlang">&#123;ezlinker_core_plugin,&#123;git,<span class="hljs-string">&quot;你插件的git位置&quot;</span>,&#123;branch, <span class="hljs-string">&quot;master&quot;</span>&#125;&#125;&#125;,</code></pre><p>然后在relx节点下的release节点最后面加上：</p><pre><code class="hljs erlang">&#123;ezlinker_core_plugin, load&#125;</code></pre><p>到此为止插件就配置完整。</p><h2 id="5-启动配置"><a href="#5-启动配置" class="headerlink" title="5.启动配置"></a>5.启动配置</h2><p>启动过程也是比较麻烦，首先需要确保你的主机已经启动了epmd（不知道可百度一下）。然后更改EMQX下面的启动脚本，把<code>_build\emqx\rel\emqx\bin\emqx</code>脚本28行倒32行全部注释，改成以下：</p><pre><code class="hljs shell"><span class="hljs-meta"></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$WITH_EPMD</span>&quot;</span> ]; <span class="hljs-keyword">then</span></span><span class="hljs-meta">#</span><span class="bash">    EPMD_ARG=<span class="hljs-string">&quot;-start_epmd false -epmd_module ekka_epmd -proto_dist ekka&quot;</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">else</span></span><span class="hljs-meta">#</span><span class="bash">    EPMD_ARG=<span class="hljs-string">&quot;-start_epmd true <span class="hljs-variable">$PROTO_DIST_ARG</span>&quot;</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">fi</span></span>EPMD_ARG=&quot;-start_epmd true $PROTO_DIST_ARG&quot;</code></pre><p>这么做的原因是emqx目前是用ekka集群的，没有自己启动epmd，所以当前需要手动指定启动epmd。</p><h2 id="6-运行EMQX"><a href="#6-运行EMQX" class="headerlink" title="6.运行EMQX"></a>6.运行EMQX</h2><p>​    切换倒emqx-rel项目，执行脚本：</p><pre><code class="hljs shell">_build/emqx/rel/emqx/bin/emqx console</code></pre><p>如果上面做的没问题，就会出现：</p><pre><code class="hljs shell">_build/emqx/rel/emqx/bin/emqx consoleExec: /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/erts-10.5/bin/erlexec -boot /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/releases/v4.0-beta.4/emqx -mode embedded -boot_var ERTS_LIB_DIR /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/erts-10.5/../lib -mnesia dir &quot;/mnt/c/Users/a&quot; -config /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/data/configs/app.2020.03.23.16.04.14.config -args_file /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/data/configs/vm.2020.03.23.16.04.14.args -vm_args /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/data/configs/vm.2020.03.23.16.04.14.args -start_epmd true -- consoleRoot: /mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqx/mnt/c/Users/admin/Github/emqx-rel/_build/emqx/rel/emqxErlang/OTP 22 [erts-10.5] [source] [64-bit] [smp:16:16] [ds:16:16:8] [async-threads:4] [hipe]Starting emqx on node emqx@127.0.0.12020-03-23 16:04:19.815 [alert] [Plugins] Cannot find plugins: [emqx_recon,emqx_rule_engine]Start http:management listener on 8081 successfully.Start http:dashboard listener on 18083 successfully.ezlinker_core_plugin loaded!Start mqtt:tcp listener on 127.0.0.1:11883 successfully.Start mqtt:tcp listener on 0.0.0.0:1883 successfully.Start_trap_listenerStart mqtt:trap listener on 0.0.0.0:1884 successfully.Start mqtt:ws listener on 0.0.0.0:8083 successfully.Start mqtt:ssl listener on 0.0.0.0:8883 successfully.Start mqtt:wss listener on 0.0.0.0:8084 successfully.EMQ X Broker master is running now!Eshell V10.5  (abort with ^G)</code></pre><h2 id="7-启动插件"><a href="#7-启动插件" class="headerlink" title="7.启动插件"></a>7.启动插件</h2><p>打开<code>http://localhost:18083</code>,进入控制台，找到plugins：</p><p><img src="/uploads/image-20200323171539539.png" alt="image-20200323171539539"></p><p>点击start按钮，启动插件。</p><h2 id="8-测试通信"><a href="#8-测试通信" class="headerlink" title="8.测试通信"></a>8.测试通信</h2><p>此时我们回过去到第一步，运行java的<code>main</code>方法，发现居然不报错了？如果没有报错，说明epmd启动成功了。</p><p>我们用Mqttfx发送一条消息看看效果：</p><p><img src="/uploads/image-20200323171732153.png" alt="image-20200323171732153"></p><p>看java这边的打印：</p><p><img src="/uploads/image-20200323171821974.png" alt="image-20200323171821974"></p><p>此时已经实现通信，到这里，我们就可以解析出消息来任意处理。</p><h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4.参考文档"></a>4.参考文档</h1><p><a href="http://erlang.org/doc/apps/jinterface/jinterface_users_guide.html">http://erlang.org/doc/apps/jinterface/jinterface_users_guide.html</a></p>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异构数据结构的存储设计</title>
    <link href="/2020/02/25/clpqt1iv200504cuebo8s0kdh.html"/>
    <url>/2020/02/25/clpqt1iv200504cuebo8s0kdh.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要介绍如何存储动态结构的数据</p><span id="more"></span><h1 id="动态表结构设计"><a href="#动态表结构设计" class="headerlink" title="动态表结构设计"></a>动态表结构设计</h1><h2 id="1-场景概述"><a href="#1-场景概述" class="headerlink" title="1.场景概述"></a>1.场景概述</h2><p>​      我们在平时的开发过程中，难免会遇到这种情况：某个业务需求的数据是没有固定结构的，也就是动态结构。遇到这种问题以后，大部分人当然采取的是传统的表关联的形式来做，但是这样做起来很麻烦，中间表多，会引起一些额外的技术问题。</p><p>​      个人在项目过程中就遇到了类似问题：某个商店的卖的一些商品需要做一个动态管理，但是谁也不知道新来的商品都是什么，有可能是一个指甲刀，也有可能是一桶泡面，我们无法预测未来入仓的商品的具体数据结构和属性。例如指甲刀有力度属性，但是泡面又有蛋白质含量属性，我们不能用一个通用的数据结构去描述。</p><p>​      在上面的案例中，我个人的解决方案是：采取文档数据库MongoDB来作为存储工具，当然实际情况下，大家可以采取自己擅长的NoSql数据库来实现。下面就来分析设计一下解决方案。</p><h2 id="2-简单分析设计"><a href="#2-简单分析设计" class="headerlink" title="2.简单分析设计"></a>2.简单分析设计</h2><p>​      首先我们最大的问题是：无法预测表结构，也就是动态数据结构。传统的关系数据库此时就无法友好的解决这类问题，此时需要有No Schema（无结构）的数据库。我们知道MongoDB具有动态结构的特性，所以本次设计我们采取MongoDB。</p><p>​      大致思路就是：关系数据库来描述固定数据，比如我们定义一个Mysql表结构，作为基础固定数据来存储，然后定义一个结构去描述这个数据的动态结构。这句话听起来比较绕，我详细介绍一下。</p><p>​      如果商品都有名称（name）属性，则我们的MySql基础字段首先包含公共部分。然后新来的一个商品是指甲刀，我们上库的时候才知道指甲刀有力度这个属性，力度一般是1-10的值。接下来需要定义一个描述规则，在这里我用JSON去描述：</p><pre><code class="hljs JSON">[  &#123;<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;force&quot;</span>,<span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;integer&quot;</span>,<span class="hljs-attr">&quot;default&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;label&quot;</span>:<span class="hljs-string">&quot;力度&quot;</span>  &#125;]</code></pre><p>​      在上面的描述规则中，我们定义了一个属性，字段叫force，类型是一个integer，默认值为0，UI显示为：力度。因为字段数量不确定，所以我们最外层是一个数组。这个JSON数组对应描述了一系列的属性，也就是对应了MongoDB的一个表结构。</p><p>​      其实这样看来，就比较明确了我们的做法：用关系数据结构来固定基本字段，然后用一个结构来描述，用非关系数据库来存储具体的数据。</p><p>​      接下来我们做具体表结构设计。</p><h2 id="3-表结构设计"><a href="#3-表结构设计" class="headerlink" title="3.表结构设计"></a>3.表结构设计</h2><ol><li><p>商品基本信息表：goods</p><table><thead><tr><th>字段名</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>INT(11)</td><td>ID</td></tr><tr><td>name</td><td>VARCHAR(50)</td><td>名称</td></tr><tr><td>properties</td><td>JSON</td><td>描述</td></tr></tbody></table><blockquote><p>需要注意一下：Mysql5.7.5以上才支持JSON类型。</p></blockquote></li><li><p>字段描述格式：properties</p><pre><code class="hljs json">[  &#123;<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;字段名&quot;</span>,<span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;字段类型&quot;</span>,<span class="hljs-attr">&quot;default&quot;</span>:默认值,<span class="hljs-attr">&quot;label&quot;</span>:<span class="hljs-string">&quot;UI显示字符&quot;</span>  &#125;]</code></pre></li><li><p>商品详情设计：properties_detail</p><p>MongoDB是没有表结构的，但是都应该包含一个字段，也就是goods的索引：id。</p><pre><code class="hljs JSON">&#123;  _id:ObjectId(),  goods_id:Int64(),  <span class="hljs-comment">//........其他字段</span>&#125;</code></pre></li></ol><p>​      再次通过观察上面设计的几个表结构，发现我们用了MongoDB动态表结构的特性，非常简单的实现了动态数据结构。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>​      我们通过MongoDB的特性实现了存储异构数据。</p>]]></content>
    
    
    <categories>
      
      <category>日常学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2019记录</title>
    <link href="/2020/02/24/clpqt1ivg006j4cuefeoy4iq5.html"/>
    <url>/2020/02/24/clpqt1ivg006j4cuefeoy4iq5.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：2019年记录</p><span id="more"></span><blockquote><p>今天是2020年2月24日，农历二月初二，龙抬头。如果不出这场意外，我应该抱得美人归了。然而天不作美，现在只能写代码，玩游戏，聊以自慰。突然就想起来我2019年的一些经历了，往年都有<br>写记录的习惯，2019年没写，现在补上。</p></blockquote><h2 id="2019年，我的关键词是：沉淀，稳重，追寻。"><a href="#2019年，我的关键词是：沉淀，稳重，追寻。" class="headerlink" title="2019年，我的关键词是：沉淀，稳重，追寻。"></a>2019年，我的关键词是：沉淀，稳重，追寻。</h2><h1 id="一、离开大厂"><a href="#一、离开大厂" class="headerlink" title="一、离开大厂"></a>一、离开大厂</h1><p>我是2019年2月春节过完以后回到闽。因为2018年被骗子骗了（专门有个打工奇遇记文章），年底没找到合适工作，于是为了过度，年底11月开始在一个做电商的公司里面打杂，做一些服务端开发。2019年初回去以后考虑到电商公司终究不是自己想要发展的路线，于是在二月底的时候，提出了离职。当时电商公司的老板极力想留下我，给我加工资，但是我还是没有接受，因为我很清楚我未来的方向，而不是随遇而安随便将就。于是在这个电商公司经历了短短的3个月以后，我最终在2月28号离开了。<br>出去以后我就投简历给了闽省榕市一家巨头企业思达内特，行业来算属于全国领先水平，主要做路由器，交换机，还有云电脑终端。第二天就通知我去面试，面试我的是一个看起来很随和的技术官，问了一些基础的技术问题，还有闲聊了一下，才知道技术官是北大博士，深深的被自己的本科学历给自卑到了。当时问的比较多的还是基础问题，什么JVM参数，JVM调优，内存，堆栈指针这种基础问题，印象深刻的问我：你写一个程序让JVM抛出StackOverFlow异常。当时心里嘀咕，其实已经想到第一个经典的问题：无限递归，但是没敢说，我还以为在考察我写的代码是不是会出现栈溢出，结果是为了考察我基础是否扎实。通过这次面试，我也是明白了技术官问的每一个问题都要认真回答，不要回避。<br>面试过后，我顺利进入思达内特旗下的KTV部门，部门主要就是做KTV点歌机相关的东西，包含业务，还有商城，终端通信等等。而我负责的部分是商家相关。进去以后就是面试我的面试官带我，首先丢给我一本资料，我看完以后才知道公司项目是Groovy开发的，于是那段时间我用一周时间学会了Groovy这个语言，同时接受了GORM这个框架的思想，思想来源于Ruby on rails，比较经典。算是第一次认真学习完了另一种JVM编程语言。<br>思达内特福利非常好，我非常喜欢这个地方，工作时间人性化，领导们都是很和善，喜欢找底下的人沟通了解情况。而且因为我们是做KTV相关项目的，所以公司内置了一间非常豪华的KTV，下班可以在里面唱歌，非常嗨。当时觉得可能这就是理想中的公司。非常期待未来的生活。</p><h1 id="二、初入研究所"><a href="#二、初入研究所" class="headerlink" title="二、初入研究所"></a>二、初入研究所</h1><p>但是计划永远赶不上变化，偶然的一次QQ群闲聊，又改变了一次我的轨迹。之前我认识的一个朋友在QQ群给我说，近期有个项目需要合作，然我去聊聊。然后周末我就去了，目的地正是研究所。<br>当时聊的比较久，所内负责人直接跟我说，过来所里干吧，所里近期在研发机器人，缺少人开发物联网业务。当时我还是比较纠结的，一边是很多人都进不去的巨头，另一面是我非常喜欢的物联网业务。刚好对我的研究方向和擅长点。<br>周末我叫了女朋友出来吃饭，跟她讲了这件事，她支持我追求自己的领域，而不是随便因为好的一些条件就轻易放弃。确实从思达内特再次辞职需要勇气，毕竟还不到一个月。但是我考虑第一的还是研究领域和方向，而不是待遇和工作环境。于是我下决心，从思达内特辞职了。<br>于是三月底，我又从思达内特离职，去了研究所。主要任务是做一个人脸识别项目。</p><h1 id="三、人脸识别"><a href="#三、人脸识别" class="headerlink" title="三、人脸识别"></a>三、人脸识别</h1><p>我比较吃惊的是这个项目居然做了2年之久，在我看来很简单的一个毕设级别的小项目，第一次提交时间居然是2017年，而且至今没有做完。<br>我重新审核了一下代码发现整个项目就是不会写代码的人堆起来的“屎山”，完全没法接手，于是我和负责人商量，推倒重构，他因为不太懂技术，刚开始不同意，但是过了一段时间还是同意了，于是我直接把之前两年堆起来的那些东西删除，重构了一遍。<br>磕磕绊绊前前后后做了也是比较久吧，算是第一个版本做完了，交差完事。这算是我对研究所的最初印象。</p><h1 id="四、研究所见闻"><a href="#四、研究所见闻" class="headerlink" title="四、研究所见闻"></a>四、研究所见闻</h1><p>在研究所远远比在企业闲，工作安排得当，很快就可以做完，所以时间比较多，那段时间我也逐渐适应了所里的慢节奏。期间接触了一些研究生，还有几个硕士，几个博士。才知道他们和我是同一级入学的，不禁又陷入了自责，同龄人都上了博士，而我还依旧是个本科打工仔。<br>所里下班比较早，我下班走在路上一般都是在思考一些问题，有时候想想未来的路，有时候想想工作遇到的比较蛋疼的事情，骂几句。<br>后期工作是做工业机器人后台相关的东西，属于半研究性的项目，所以进度不赶，那时候时间就比较多，所以有时间看看别的东西，兴趣来的时候，还买了SICP，可惜第一章都看不下去。<br>整体上研究所的生活是比较舒适的，很适合静下心研究一些东西，于是我再次下定决心继续研究物联网相关的技术。</p><h1 id="五、意外收获：Erlang"><a href="#五、意外收获：Erlang" class="headerlink" title="五、意外收获：Erlang"></a>五、意外收获：Erlang</h1><p>我刚开始是5点半下班，下班回到房间差不多7点，打一把王者荣耀，然后就开始第二段时间，有时候做一些东西，有时候学点知识，一般情况我的安排是：7-9点两个小时，看看网课，当时主要看的是C++，因为我至今心里有个结：没有学会C++；除此之外，还有一些运维方面的，比如Docker，还有一些项目架构等等。9点以后不想看了就开始实战，写点代码，或者是做点小工具，玩玩开发板等等，一直熬到11点半左右，收拾一下开始睡觉，基本上都是十二点睡觉的。所以时间还算比较规律。<br>所以逐渐养成了白天上班学理论，晚上看视频做实战的习惯，这个习惯保持的还不错，2019年一整年都是这个节奏。<br>同时最大的收获是接触了Erlang。因为做物联网项目需要用到消息代理，所以我很早就开始研究EMQ，但是那个时候，我仅仅回安装使用，不会开发。2019年再次接触了以后，决定深入去研究一下，于是在9月开始买了一批Erlang相关的书开始学习，学习路线比较曲折，远远没有Groovy那么快，花了我一个月时间才勉强写个服务器。后来慢慢的Erlang熟悉了以后，可以针对EMQ进行二次开发，才觉得入门了新的领域。<br>从10月开始Erlang进入了我的技术栈。这也是我一直想学习的领域，算是最大的收获。</p><h1 id="六、智能共享柜"><a href="#六、智能共享柜" class="headerlink" title="六、智能共享柜"></a>六、智能共享柜</h1><p>六月的时候，有个朋友给我推荐了一个老板，他们想做一个智能共享柜项目，于是我们跟他们进行了合作，经过了半年多的周末时间，开发了一套软硬件齐全的项目。这算是我自己参与负责的最完整的项目，软件设计，开发，还有工厂跟进，全部跟着经历了一遍，加上有大佬带队，那段时间不光是技术，还有产品意识也增长不少。</p><h1 id="七、生活"><a href="#七、生活" class="headerlink" title="七、生活"></a>七、生活</h1><p>女朋友在另一个公司做互联网业务，也是非常累，周末时间短暂，两个身在异乡的年轻人只能互相安慰鼓励对方。去看个电影，吃个饭，都觉得开心满足。当物质极度匮乏的时候，人的幸福感就很容易满足。<br>一年了，我们两个人几乎都是把时间投入到了工作中，有时候她跟我抱怨，我和我的电脑过一辈子去，那时候也是没办法，落后就要被淘汰。不过她还是很支持我，甚至我花2万多买电脑还有电子产品的时候，她都支持。我觉得她26岁了，还是和一个小孩子一样，跟着我穷开心。<br>都感叹人生若得安稳，谁愿颠沛流离，一年多了，两个人过的也有很窘迫的时候。记得秋天的时候，她半夜肚子疼的打滚，连夜送去医院却被庸医骗了，花了几千，没有治好却加重了。那时候她哭着说坚持不下去了，我心里也是非常难过，好在同学在医院，开了个方子，一副药就好了。一年多，有窘迫，痛苦，迷茫，但是又重新安慰自己未来有希望，两个人在异乡就这么一天天过。<br>我问她：你信不信我将来能成为一个很厉害的人。她想都不想就回答：我相信你一定会成为一个很厉害的人。</p><h1 id="八、对物联网的一点感悟"><a href="#八、对物联网的一点感悟" class="headerlink" title="八、对物联网的一点感悟"></a>八、对物联网的一点感悟</h1><p>2019年所有精力全部花在研究物联网领域上了，自己对物联网的看法是未来3年内国内大趋势，非常有前景。但是物联网技术的门槛又很高，所需的知识积累很多，有时候甚至要求你会画PCB，还要会HTML（指的是对行业的认知，而不是实际去做）。学习路线其实很明确了，就是编程语言三巨头（C C++ Java）和一些适合做嵌入式的框架，比如QT，还有Python（适合系统之上）等等。同时单片机还需要学习一下，2020年准备学点STM32，不然做物联网出软件就是外行了，对设备和硬件运行原理一窍不通，根本没法去研究物联网技术。<br>潜力大，门槛高，技术难度大，是物联网技术的主要特征。</p><h1 id="九、反思"><a href="#九、反思" class="headerlink" title="九、反思"></a>九、反思</h1><p>反思一下2019年，我自己整体上算是走在一开始计划的大方向上，但是还是有很多问题，比如自制力还是太差，喜欢玩王者荣耀，浪费太多时间玩游戏。还有就是效率不高，做事老磨磨唧唧，写一分钟代码，吹水10分钟，以后需要改正这些问题。<br>同时发现自己性格上面还是有些问题，比较自我，不愿意接受别人的意见，不会倾听，只会输出价值观。以后要学会不仅做一个输出者，还做一个倾听者，不要一味的强调是非对错，待人要和善，友好，做一个正直善良的人。</p><h1 id="十、疫情耽误终身大事"><a href="#十、疫情耽误终身大事" class="headerlink" title="十、疫情耽误终身大事"></a>十、疫情耽误终身大事</h1><p>和女朋友两个人认识6年，在一起三年半，本来是时候决定终身大事。于是婚礼定在了2020年2月1日，但是2020年却是一个多事之秋，马上来了一波瘟疫，只能取消婚礼。我们真是万万没想到。想起来也是和段子一样，哭笑不得。</p><h1 id="十一、展望2020"><a href="#十一、展望2020" class="headerlink" title="十一、展望2020"></a>十一、展望2020</h1><p>2020年我们会好起来吗？我不知道，但是她说一定会。疫情过了以后一定会柳暗花明。<br>对于我而言，2020年我希望我继续保持初心即可，不需要太高奢望，不能好高骛远。继续保持状态就是最好的展望。</p>]]></content>
    
    
    <categories>
      
      <category>文集-踉跄于世</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集-踉跄与世</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过WebSocket监控EMQX的设备上下线</title>
    <link href="/2020/01/08/clpqt1itx00134cue0wgq480e.html"/>
    <url>/2020/01/08/clpqt1itx00134cue0wgq480e.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要用WebSocket实现了一个简单的监控器,监控设备上下线.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>很多人想通过WEB界面来实时监控设备上下线消息,于是我做了个简单的Demo供大家参考.</p><p>本项目用Mqtt-paho来实现客户端代理的,实验之前记得装依赖.</p><h2 id="2-服务端代码"><a href="#2-服务端代码" class="headerlink" title="2.服务端代码"></a>2.服务端代码</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.app.config.emqxproxy;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<span class="hljs-keyword">import</span> com.corundumstudio.socketio.SocketIOClient;<span class="hljs-keyword">import</span> com.corundumstudio.socketio.SocketIOServer;<span class="hljs-keyword">import</span> com.ezlinker.app.config.mqtt.MqttProxyClient;<span class="hljs-keyword">import</span> com.ezlinker.app.config.socketio.EchoEventMessage;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;<span class="hljs-keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: ezlinker</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 这里用来通过WS给前端发一些动态通知</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: wangwenhai</span><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2019-12-16 15:09</span><span class="hljs-comment"> **/</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmqxEventListener</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * MQTT代理</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Resource</span>    MqttProxyClient emqClient;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 状态标识:用来标识代理是否连接成功</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isConnectToEmqx = <span class="hljs-keyword">false</span>;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SocketIOServer <span class="hljs-title">socketIoServer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">/*</span><span class="hljs-comment">         * 创建Socket，并设置监听端口</span><span class="hljs-comment">         */</span>        com.corundumstudio.socketio.Configuration socketIoConfig = <span class="hljs-keyword">new</span> com.corundumstudio.socketio.Configuration();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 目前只允许本地WS连接</span><span class="hljs-comment">         */</span>        socketIoConfig.setHostname(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * WS端口</span><span class="hljs-comment">         */</span>        socketIoConfig.setPort(<span class="hljs-number">2501</span>);        socketIoConfig.setUpgradeTimeout(<span class="hljs-number">10000</span>);        socketIoConfig.setPingTimeout(<span class="hljs-number">180000</span>);        socketIoConfig.setPingInterval(<span class="hljs-number">60000</span>);        <span class="hljs-comment">// 认证</span>        socketIoConfig.setAuthorizationListener(data -&gt; &#123;            <span class="hljs-comment">// TODO 这里做个安全拦截器,WS必须带上颁发的随机Token才能连接</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;);        SocketIOServer server = <span class="hljs-keyword">new</span> SocketIOServer(socketIoConfig);        server.startAsync();        <span class="hljs-comment">/**</span><span class="hljs-comment">         * WS 连接处理</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 当WS连接成功以后,开始连接EMQX</span><span class="hljs-comment">         */</span>        server.addConnectListener(<span class="hljs-keyword">this</span>::connectToEmqx);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 离线回调</span><span class="hljs-comment">         */</span>        server.addDisconnectListener(<span class="hljs-keyword">this</span>::disConnectToEmqx);        <span class="hljs-keyword">return</span> server;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 回复消息</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">echoEvent</span><span class="hljs-params">(SocketIOClient socketIoClient, EchoEventMessage message)</span> </span>&#123;        socketIoClient.sendEvent(<span class="hljs-string">&quot;echoEvent&quot;</span>, JSONObject.toJSONString(message));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代理客户端</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ioClient</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectToEmqx</span><span class="hljs-params">(SocketIOClient ioClient)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 开始连接MQTT</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 把前一个给踢下去</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span> (emqClient.isConnected()) &#123;                emqClient.disconnect();            &#125; <span class="hljs-keyword">else</span> &#123;                MqttConnectOptions mqttConnectOptions = <span class="hljs-keyword">new</span> MqttConnectOptions();                mqttConnectOptions.setConnectionTimeout(<span class="hljs-number">10</span>);                mqttConnectOptions.setCleanSession(<span class="hljs-keyword">true</span>);                mqttConnectOptions.setAutomaticReconnect(<span class="hljs-keyword">true</span>);                mqttConnectOptions.setUserName(<span class="hljs-string">&quot;ezlinker_event_listener&quot;</span>);                mqttConnectOptions.setPassword(<span class="hljs-string">&quot;password&quot;</span>.toCharArray());                emqClient.connect(mqttConnectOptions);            &#125;        &#125; <span class="hljs-keyword">catch</span> (MqttException e) &#123;            e.printStackTrace();            log.error(<span class="hljs-string">&quot;连接EMQX失败&quot;</span> + e.getMessage());            isConnectToEmqx = <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span> (emqClient.isConnected()) &#123;            isConnectToEmqx = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">try</span> &#123;                emqClient.subscribe(<span class="hljs-string">&quot;$SYS/brokers/+/clients/+/#&quot;</span>, <span class="hljs-number">2</span>, (s, mqttMessage) -&gt; &#123;                    System.out.println(mqttMessage.toString());                    EchoEventMessage m0 = <span class="hljs-keyword">new</span> EchoEventMessage();                    m0.setCode(<span class="hljs-number">200</span>);                    m0.setDebug(<span class="hljs-keyword">true</span>);                    m0.setMsg(JSONObject.parseObject(mqttMessage.toString()));                    echoEvent(ioClient, m0);                &#125;);            &#125; <span class="hljs-keyword">catch</span> (MqttException e) &#123;                e.printStackTrace();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            isConnectToEmqx = <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ioClient</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">disConnectToEmqx</span><span class="hljs-params">(SocketIOClient ioClient)</span> </span>&#123;        <span class="hljs-keyword">if</span> (emqClient.isConnected()) &#123;            <span class="hljs-keyword">try</span> &#123;                emqClient.disconnect();            &#125; <span class="hljs-keyword">catch</span> (MqttException e) &#123;                log.error(<span class="hljs-string">&quot;内部错误:&quot;</span> + e.getMessage());            &#125;        &#125;        <span class="hljs-keyword">if</span> (isConnectToEmqx) &#123;            isConnectToEmqx = <span class="hljs-keyword">false</span>;        &#125;    &#125;&#125;</code></pre><h2 id="3-Websocket端"><a href="#3-Websocket端" class="headerlink" title="3.Websocket端:"></a>3.Websocket端:</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sendBtn&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;testBtn&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;test()&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content-wrap&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><span class="javascript">    <span class="hljs-comment">// const socket = io(&#x27;http://39.108.214.107:12001?token=32dassw4fd3r&amp;deviceId=1&#x27;);</span></span><span class="javascript">    <span class="hljs-keyword">const</span> socket = io(<span class="hljs-string">&#x27;http://localhost:2501?token=32dassw4fd3r&#x27;</span>);</span><span class="javascript">    socket.on(<span class="hljs-string">&#x27;echoEvent&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;</span><span class="javascript">        <span class="hljs-built_in">window</span>.console.log(<span class="hljs-string">&quot;来自服务器的回应:&quot;</span>, data);</span><span class="javascript">    &#125;);</span><span class="javascript"></span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="4-效果展示"><a href="#4-效果展示" class="headerlink" title="4.效果展示"></a>4.效果展示</h2><p><img src="/uploads/image-20200108171853165.png" alt="image-20200108171853165"></p><p>然后通过前端框架,可以动态把这些数据渲染到HTML界面上面.</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>$SYS 主题前缀: $SYS/brokers/${node}/clients/</p><table><thead><tr><th align="left">主题(Topic)</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">${clientid}/connected</td><td align="left">上线事件。当某客户端上线时，会发布该消息</td></tr><tr><td align="left">${clientid}/disconnected</td><td align="left">下线事件。当某客户端离线时，会发布该消息</td></tr></tbody></table><p>通配符:<code>$SYS/brokers/+/clients/+/#</code>,表示监听所有的节点.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Emqx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQ新手玩家常见问题解答</title>
    <link href="/2020/01/08/clpqt1itw000y4cue433oat9z.html"/>
    <url>/2020/01/08/clpqt1itw000y4cue433oat9z.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下刚接触EMQ的时候遇到的一些新手问题,这些问题每天都有人问,但是没人总结,故抽空总结一下,以便后人翻阅.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>相信很多朋友在初次接触EMQ的时候,都会有一些基础问题,什么端口在哪?还有API怎么调用等等,每天都在群里看到新人问,为了方便大家统一查阅,我专门整理了个文档来记录下来.</p><h2 id="2-问答"><a href="#2-问答" class="headerlink" title="2.问答"></a>2.问答</h2><p>下面这些是起步的时候遇到的基础问题:</p><h3 id="1-EMQ怎么下载"><a href="#1-EMQ怎么下载" class="headerlink" title="1. EMQ怎么下载?"></a>1. EMQ怎么下载?</h3><p>   下载地址:<a href="https://www.emqx.io/cn/downloads">https://www.emqx.io/cn/downloads</a></p><p>   <img src="/uploads/image-20200108090253684.png" alt="image-20200108090253684"></p><p>   版本选择:</p><ul><li><p>如果你是个人用户,建议下载Broker;</p></li><li><p>如果是企业用户,建议下载Enterprise.</p></li></ul><h3 id="2-EMQ在windows怎么启动"><a href="#2-EMQ在windows怎么启动" class="headerlink" title="2. EMQ在windows怎么启动?"></a>2. EMQ在windows怎么启动?</h3><p>​根据这两年的研究和使用,我自己发现在windows下启动的时候很不友好,有时候经常启动失败,我总结的办法是:当输入:<code>emqx start</code>的时候,会卡住比较久,在这个时候<code>Ctrl+C</code>取消,然后再来一遍,可能就成功了,总之在windows下启动不太理想,建议用linux或者WSL也可以.</p><h3 id="3-为何我的WEB控制台报404"><a href="#3-为何我的WEB控制台报404" class="headerlink" title="3. 为何我的WEB控制台报404?"></a>3. 为何我的WEB控制台报404?</h3><p> EMQ的WEB控制台的端口默认是8080,如果你事先已经占用了8080,比如启动了tomcat,请先去看下是不是冲突了,这种情况大部分是端口冲突.</p><h3 id="4-为何我的WEB控制台启动不了"><a href="#4-为何我的WEB控制台启动不了" class="headerlink" title="4. 为何我的WEB控制台启动不了?"></a>4. 为何我的WEB控制台启动不了?</h3><p>原因同上面第三点,端口冲突.</p><h3 id="5-怎么设置WEB界面为中文"><a href="#5-怎么设置WEB界面为中文" class="headerlink" title="5. 怎么设置WEB界面为中文?"></a>5. 怎么设置WEB界面为中文?</h3><p> <img src="/uploads/image-20200108090839669.png" alt="image-20200108090839669"></p><h3 id="6-WEB界面的管理员账号怎么设置"><a href="#6-WEB界面的管理员账号怎么设置" class="headerlink" title="6. WEB界面的管理员账号怎么设置?"></a>6. WEB界面的管理员账号怎么设置?</h3><p><img src="/uploads/image-20200108090915883.png" alt="image-20200108090915883"></p><h2 id="下面这些在使用过程中遇到的"><a href="#下面这些在使用过程中遇到的" class="headerlink" title="下面这些在使用过程中遇到的:"></a>下面这些在使用过程中遇到的:</h2><h3 id="1-为何我的MQTT客户端连接不了EMQ"><a href="#1-为何我的MQTT客户端连接不了EMQ" class="headerlink" title="1. 为何我的MQTT客户端连接不了EMQ?"></a>1. 为何我的MQTT客户端连接不了EMQ?</h3><p>   请检查端口是否是1883,或者看看EMQ启动成功了没.</p><h3 id="2-为何我改了XXX配置还是不行"><a href="#2-为何我改了XXX配置还是不行" class="headerlink" title="2. 为何我改了XXX配置还是不行?"></a>2. 为何我改了XXX配置还是不行?</h3><p>   EMQ的配置修改了以后需要重启才能加载进内存.</p><h3 id="3-为何我的Mysql插件配置成功了但是还是没有效果"><a href="#3-为何我的Mysql插件配置成功了但是还是没有效果" class="headerlink" title="3. 为何我的Mysql插件配置成功了但是还是没有效果?"></a>3. 为何我的Mysql插件配置成功了但是还是没有效果?</h3><p>   EMQ的匿名连接默认是开的,也就是默认不需要认证,如果开启Mysql认证插件,就需要配合关闭匿名,具体操作如下:</p><ul><li><p>打开emqx.conf,关闭匿名模式，大概在410行的位置处，把【anonymous=true】改成【anonymous=false】;</p></li><li><p>在大约415行处【acl_nomatch = allow】改成【acl_nomatch = deny】;</p></li><li><p>如果需要严格约束,可以配置当ACL不匹配的时候拒绝连接:445行的【acl_deny_action=ignore】改为【acl_deny_action=disconnect】。</p></li></ul><h3 id="4-为何我的Mysql认证插件老是拒绝连接"><a href="#4-为何我的Mysql认证插件老是拒绝连接" class="headerlink" title="4. 为何我的Mysql认证插件老是拒绝连接?"></a>4. 为何我的Mysql认证插件老是拒绝连接?</h3><p>   检查密码的加密方式是不是有问题.</p><h3 id="5-为何我的WebHook插件没有效果"><a href="#5-为何我的WebHook插件没有效果" class="headerlink" title="5. 为何我的WebHook插件没有效果?"></a>5. 为何我的WebHook插件没有效果?</h3><p>   有2种情况:</p><ul><li>URL配置错误,倒是webhook请求不到</li><li>webhook压根没启动</li></ul><h3 id="6-怎么监控设备上下线"><a href="#6-怎么监控设备上下线" class="headerlink" title="6. 怎么监控设备上下线?"></a>6. 怎么监控设备上下线?</h3><p>   目前有2种形式:</p><ol><li><p>用一个MQTT客户端订阅下面的两个topic:</p><table><thead><tr><th align="left">主题(Topic)</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">${clientid}/connected</td><td align="left">上线事件。当某客户端上线时，会发布该消息</td></tr><tr><td align="left">${clientid}/disconnected</td><td align="left">下线事件。当某客户端离线时，会发布该消息</td></tr></tbody></table><ul><li>‘connected’ 事件消息的 Payload 可解析成 JSON 格式:</li></ul><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;clientid&quot;</span>:<span class="hljs-string">&quot;id1&quot;</span>,    <span class="hljs-attr">&quot;username&quot;</span>:<span class="hljs-string">&quot;u&quot;</span>,    <span class="hljs-attr">&quot;ipaddress&quot;</span>:<span class="hljs-string">&quot;127.0.0.1&quot;</span>,    <span class="hljs-attr">&quot;connack&quot;</span>:<span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;ts&quot;</span>:<span class="hljs-number">1554047291</span>,    <span class="hljs-attr">&quot;proto_ver&quot;</span>:<span class="hljs-number">3</span>,    <span class="hljs-attr">&quot;proto_name&quot;</span>:<span class="hljs-string">&quot;MQIsdp&quot;</span>,    <span class="hljs-attr">&quot;clean_start&quot;</span>:<span class="hljs-literal">true</span>,    <span class="hljs-attr">&quot;keepalive&quot;</span>:<span class="hljs-number">60</span>&#125;</code></pre><ul><li>‘disconnected’ 事件消息的 Payload 可解析成 JSON 格式:</li></ul><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;clientid&quot;</span>:<span class="hljs-string">&quot;id1&quot;</span>,    <span class="hljs-attr">&quot;username&quot;</span>:<span class="hljs-string">&quot;u&quot;</span>,    <span class="hljs-attr">&quot;reason&quot;</span>:<span class="hljs-string">&quot;normal&quot;</span>,    <span class="hljs-attr">&quot;ts&quot;</span>:<span class="hljs-number">1554047291</span>&#125;</code></pre></li><li><p>用WebHook插件:</p><h2 id="WebHook-插件"><a href="#WebHook-插件" class="headerlink" title="WebHook 插件"></a>WebHook 插件</h2><p><a href="https://github.com/emqx/emqx-web-hook">emqx_web_hook</a> 插件可以将所有 <em>EMQ X</em> 的事件及消息都发送到指定的 HTTP 服务器。</p><h3 id="配置-WebHook-插件"><a href="#配置-WebHook-插件" class="headerlink" title="配置 WebHook 插件"></a>配置 WebHook 插件</h3><ul><li>etc/plugins/emqx_web_hook.conf:</li></ul><pre><code class="hljs ini"><span class="hljs-comment">## 回调的 Web Server 地址</span><span class="hljs-attr">web.hook.api.url</span> = http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span><span class="hljs-comment">## 编码 Payload 字段</span><span class="hljs-comment">## 枚举值: undefined | base64 | base62</span><span class="hljs-comment">## 默认值: undefined (不进行编码)</span><span class="hljs-comment">## web.hook.encode_payload = base64</span><span class="hljs-comment">## 消息、事件配置</span><span class="hljs-attr">web.hook.rule.client.connected.1</span>     = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_connected&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.client.disconnected.1</span>  = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_disconnected&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.client.subscribe.1</span>     = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_subscribe&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.client.unsubscribe.1</span>   = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_client_unsubscribe&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.session.created.1</span>      = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_created&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.session.subscribed.1</span>   = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_subscribed&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.session.unsubscribed.1</span> = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_unsubscribed&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.session.terminated.1</span>   = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_session_terminated&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.message.publish.1</span>      = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_publish&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.message.deliver.1</span>      = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_deliver&quot;</span>&#125;<span class="hljs-attr">web.hook.rule.message.acked.1</span>        = &#123;<span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;on_message_acked&quot;</span>&#125;</code></pre></li></ol><h3 id="7-怎么监控设备发送的数据"><a href="#7-怎么监控设备发送的数据" class="headerlink" title="7. 怎么监控设备发送的数据?"></a>7. 怎么监控设备发送的数据?</h3><p>   可以和第八点一样的形式,或者使用规则引擎</p><p>下面这些是比较高级的使用:</p><h3 id="1-怎么让我的XXX设备通过MQTT协议把数据上报到EMQ"><a href="#1-怎么让我的XXX设备通过MQTT协议把数据上报到EMQ" class="headerlink" title="1. 怎么让我的XXX设备通过MQTT协议把数据上报到EMQ?"></a>1. 怎么让我的XXX设备通过MQTT协议把数据上报到EMQ?</h3><p>   让设备作为一个客户端,然后向一个topic发送数据即可.</p><h3 id="2-怎么设计一个简单的物联网平台"><a href="#2-怎么设计一个简单的物联网平台" class="headerlink" title="2. 怎么设计一个简单的物联网平台?"></a>2. 怎么设计一个简单的物联网平台?</h3><p>   设计一个平台比较复杂,没有能分分钟完成的,建议先参考同类,总结需求再提出设计方案..</p><p>   欢迎加入QQ群进行讨论:475512169</p><h2 id="3-建议"><a href="#3-建议" class="headerlink" title="3.建议"></a>3.建议</h2><p>建议大家多阅读文档,最好是通读一遍,大概有个印象,每次遇到问题就能直接去查阅,而不是反反复复的问问题,其实每个问题都是很多人重复问过的.</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本文总结了一些EMQ的新手使用问题.</p>]]></content>
    
    
    <categories>
      
      <category>EMQX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emqx</tag>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot项目中使用Mybatisplus分页Mongodb</title>
    <link href="/2020/01/07/clpqt1iv2004y4cue0dnjeybn.html"/>
    <url>/2020/01/07/clpqt1iv2004y4cue0dnjeybn.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下如何让Springboot项目中的MongoDB查询到的数据按照MybatisPlus的格式返回分页.</p><span id="more"></span><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p>本文主要以一个WEB系统站内通知为主,讲一下Springboot项目同时使用MongoDB和Mybatisplus的时候,如何返回统一的分页数据.</p><h2 id="1-文档结构"><a href="#1-文档结构" class="headerlink" title="1.文档结构"></a>1.文档结构</h2><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><span class="hljs-meta">@Accessors(chain = true)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMessage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> Integer type;    <span class="hljs-keyword">private</span> String content;    <span class="hljs-keyword">private</span> String title;    <span class="hljs-keyword">private</span> Integer marked;    <span class="hljs-keyword">private</span> Long userId;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建时间</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@JsonFormat(timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>    <span class="hljs-keyword">private</span> Date createTime;&#125;</code></pre><h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2.Service"></a>2.Service</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.app.modules.internalmessage.service;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;<span class="hljs-keyword">import</span> com.ezlinker.app.modules.internalmessage.model.InternalMessage;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 服务类</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lc5900</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InternalMessageService</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entity</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(InternalMessage entity)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从MongoDB查询站内信</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId 用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> marked 是否标记阅读</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function">IPage&lt;InternalMessage&gt; <span class="hljs-title">queryForPage</span><span class="hljs-params">(Long userId, Integer marked, Pageable pageable)</span></span>;&#125;</code></pre><h2 id="3-Service实现类"><a href="#3-Service实现类" class="headerlink" title="3.Service实现类"></a>3.Service实现类</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.app.modules.internalmessage.service.impl;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;<span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;<span class="hljs-keyword">import</span> com.ezlinker.app.modules.internalmessage.model.InternalMessage;<span class="hljs-keyword">import</span> com.ezlinker.app.modules.internalmessage.service.InternalMessageService;<span class="hljs-keyword">import</span> org.bson.types.ObjectId;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.data.domain.Sort;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Criteria;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Query;<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.query.Update;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 服务实现类</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lc5900</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMessageServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InternalMessageService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    MongoTemplate mongoTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(InternalMessage entity)</span> </span>&#123;        mongoTemplate.insert(entity, <span class="hljs-string">&quot;internal_message&quot;</span>);    &#125;    <span class="hljs-comment">//最主要的是这里,需要返回一个Ipage匿名实现对象</span>    <span class="hljs-comment">//根据查询条件来统计Page各种属性</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;InternalMessage&gt; <span class="hljs-title">queryForPage</span><span class="hljs-params">(Long userId, Integer marked, Pageable pageable)</span> </span>&#123;        Query query = <span class="hljs-keyword">new</span> Query();        query.addCriteria(Criteria.where(<span class="hljs-string">&quot;userId&quot;</span>).is(userId));        query.addCriteria(Criteria.where(<span class="hljs-string">&quot;marked&quot;</span>).is(marked));        query.with(Sort.by(Sort.Direction.DESC, <span class="hljs-string">&quot;createTime&quot;</span>));        query.with(pageable);        List&lt;InternalMessage&gt; list = mongoTemplate.find(query, InternalMessage.class, <span class="hljs-string">&quot;internal_message&quot;</span>);        <span class="hljs-keyword">long</span> total = mongoTemplate.count(query, <span class="hljs-string">&quot;internal_message&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IPage&lt;InternalMessage&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;OrderItem&gt; <span class="hljs-title">orders</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> OrderItem.descs(<span class="hljs-string">&quot;createTime&quot;</span>);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;InternalMessage&gt; <span class="hljs-title">getRecords</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> list;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;InternalMessage&gt; <span class="hljs-title">setRecords</span><span class="hljs-params">(List&lt;InternalMessage&gt; records)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> total;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;InternalMessage&gt; <span class="hljs-title">setTotal</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> pageable.getPageSize();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;InternalMessage&gt; <span class="hljs-title">setSize</span><span class="hljs-params">(<span class="hljs-keyword">long</span> size)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCurrent</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> pageable.getPageNumber();            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> IPage&lt;InternalMessage&gt; <span class="hljs-title">setCurrent</span><span class="hljs-params">(<span class="hljs-keyword">long</span> current)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;            &#125;        &#125;;    &#125;&#125;</code></pre><h2 id="4-控制器"><a href="#4-控制器" class="headerlink" title="4.控制器"></a>4.控制器</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ezlinker.app.modules.internalmessage.controller;<span class="hljs-keyword">import</span> com.ezlinker.app.common.web.CurdController;<span class="hljs-keyword">import</span> com.ezlinker.app.modules.internalmessage.model.InternalMessage;<span class="hljs-keyword">import</span> com.ezlinker.app.modules.internalmessage.service.InternalMessageService;<span class="hljs-keyword">import</span> com.ezlinker.app.common.exception.XException;<span class="hljs-keyword">import</span> com.ezlinker.app.common.exchange.R;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.domain.PageRequest;<span class="hljs-keyword">import</span> org.springframework.data.domain.Pageable;<span class="hljs-keyword">import</span> org.springframework.data.domain.Sort;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> * 站内信 前段控制器</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lc5900</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-13</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/internalMessages&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InternalMessageController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CurdController</span>&lt;<span class="hljs-title">InternalMessage</span>&gt; </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> InternalMessageService internalMessageService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InternalMessageController</span><span class="hljs-params">(HttpServletRequest httpServletRequest)</span> </span>&#123;        <span class="hljs-keyword">super</span>(httpServletRequest);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 分页检索</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> current 页码：必传</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size    页长：必传</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> XException</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">queryForPage</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@RequestParam</span> Integer current,</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@RequestParam</span> Integer marked,</span></span><span class="hljs-params"><span class="hljs-function">            <span class="hljs-meta">@RequestParam</span> Integer size)</span> <span class="hljs-keyword">throws</span> XException </span>&#123;        Pageable pageable = PageRequest.of(current, size, Sort.by(Sort.Direction.DESC, <span class="hljs-string">&quot;_id&quot;</span>));        <span class="hljs-keyword">return</span> data(internalMessageService.queryForPage(getUserDetail().getId(), marked, pageable));    &#125;&#125;</code></pre><p>通过:</p><p>Pageable pageable = PageRequest.of(current, size, Sort.by(Sort.Direction.DESC, “_id”));</p><p>构建Page对象,然后传给Service去处理,最终生成MongoDb’的query语句.</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>本文主要讲了如何实现Mongodb兼容Mybatisplus进行分页.</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mongodb</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arduino简单命令行模拟</title>
    <link href="/2020/01/06/clpqt1iv1004t4cue9g771ntr.html"/>
    <url>/2020/01/06/clpqt1iv1004t4cue9g771ntr.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要展示一段之前实现的Arduino命令行模拟代码,包含了WIFI操作,MQTT,DHT11温湿度读取等等常见操作.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>我们在用串口操作Arduino的时候,会有一些输出提示,一般我们做一个封装,比如命令行输出一些提示信息给用户去查看,操作比较友好,于是我自己写了个非常简单的模拟固件,同时还有通过串口配置WIFI的一些操作.</p><h2 id="2-代码展示"><a href="#2-代码展示" class="headerlink" title="2.代码展示"></a>2.代码展示</h2><p>代码如下所示:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ESP_EEPROM.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ESP8266WiFi.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;PubSubClient.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Wire.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Ethernet.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ACROBOTIC_SSD1306.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Arduino_JSON.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;DHTesp.h&quot;</span></span><span class="hljs-comment">///</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RED_LED_GPIO 12</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GREEN_LED_GPIO 13</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLUE_LED_GPIO 15</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DHT11_GPIO 5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUZZER_GPIO  14</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MQTT_MAX_TRANSFER_SIZE</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* clientId = <span class="hljs-string">&quot;85C05BE9296E49EBAACA1A4BF77AD0E2&quot;</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">   联网不一定连MQTT服务器</span><span class="hljs-comment">   不联网一定不连MQTT服务器</span><span class="hljs-comment">*/</span>DHTesp dht;boolean isConnectToWifi ;boolean isConnectToMqtt ;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SysConfig</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">char</span> ssid[<span class="hljs-number">32</span>];  <span class="hljs-keyword">char</span> password[<span class="hljs-number">32</span>];  <span class="hljs-keyword">char</span> mqttServer[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;192.168.1.100&quot;</span>;  <span class="hljs-keyword">char</span> mqttClientId[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;testEsp&quot;</span>;  <span class="hljs-keyword">char</span> mqttUsername[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;system&quot;</span>;  <span class="hljs-keyword">char</span> mqttPassword[<span class="hljs-number">64</span>] = <span class="hljs-string">&quot;password&quot;</span>;  <span class="hljs-keyword">int</span> mqttPort = <span class="hljs-number">1883</span>;&#125;;SysConfig sysConfig;<span class="hljs-comment">/**</span><span class="hljs-comment">   连接Mqtt用的</span><span class="hljs-comment">*/</span>WiFiClient espClient;<span class="hljs-function">PubSubClient <span class="hljs-title">mqttClient</span><span class="hljs-params">(<span class="hljs-string">&quot;192.168.1.100&quot;</span>, <span class="hljs-number">1883</span>, espClient)</span></span>;<span class="hljs-comment">//PubSubClient mqttClient(espClient);</span><span class="hljs-comment">/**</span><span class="hljs-comment">   OLED 显示屏</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> line, <span class="hljs-keyword">int</span> x, boolean isClear, <span class="hljs-keyword">char</span> content[])</span> </span>&#123;  <span class="hljs-keyword">if</span> (isClear) &#123;    oled.<span class="hljs-built_in">clearDisplay</span>();    oled.<span class="hljs-built_in">setTextXY</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    oled.<span class="hljs-built_in">putString</span>(content);  &#125; <span class="hljs-keyword">else</span> &#123;    oled.<span class="hljs-built_in">setTextXY</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    oled.<span class="hljs-built_in">putString</span>(content);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   加载配置</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadSysConfig</span><span class="hljs-params">()</span> </span>&#123;  EEPROM.<span class="hljs-built_in">begin</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SysConfig));  EEPROM.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>, sysConfig);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;--------Load wifi SysConfig from EPROM--------&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|SSID: &quot;</span>);  Serial.<span class="hljs-built_in">print</span>(sysConfig.ssid);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t Password: &quot;</span>);  Serial.<span class="hljs-built_in">println</span>(sysConfig.password);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;----------------------------------------------&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   写入配置到EPROM</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeSysConfig</span><span class="hljs-params">()</span> </span>&#123;  EEPROM.<span class="hljs-built_in">begin</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SysConfig));  EEPROM.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, sysConfig);  EEPROM.<span class="hljs-built_in">commitReset</span>();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   打印banner</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">welcome</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;**********************************************&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*     Welcome use NodeMcu Cli Mode V0.0.1    *&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*     Send &#x27;help&#x27; for more information       *&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;**********************************************&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   Help</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showHelp</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;**********************************************&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|SysConfig Wlan: wlanset -s &#123;SSID&#125; -p &#123;Password&#125;|&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Print Wlan Info:wlan                        |&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Test Buzzer &#123;n&#125; times: beep &#123;n&#125;             |&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Print tempature:temp                        |&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Print tempature:hum                         |&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;**********************************************&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echoTemp</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|             Current tempature is:      &quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-number">35</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echoHumidity</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|     Current humidity:             |&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-number">35</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echoWlan</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">status</span>() == WL_CONNECTED) &#123;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|state:&quot;</span>);    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ON\t&quot;</span>);    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;     \tIP:&quot;</span>);    Serial.<span class="hljs-built_in">println</span>(WiFi.<span class="hljs-built_in">localIP</span>());    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;*------------------------------------------*&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Network has disconnected.&quot;</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   配置网络</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupWifi</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;-----------------SetUp wifi-------------------&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Try  connect to network.&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|&quot;</span>);  WiFi.<span class="hljs-built_in">begin</span>(sysConfig.ssid, sysConfig.password);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>; i++) &#123;    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&gt;&quot;</span>);    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">status</span>() == WL_CONNECTED) &#123;      WiFi.<span class="hljs-built_in">hostname</span>(<span class="hljs-string">&quot;ESP8266_NODE_1&quot;</span>);      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Success connect to network.&quot;</span>);      isConnectToWifi = <span class="hljs-literal">true</span>;      <span class="hljs-built_in">writeSysConfig</span>();      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">status</span>() != WL_CONNECTED) &#123;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Connect to network failure.Please try again!&quot;</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   初始化MQTT</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initMqtt</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;-----------------SetUp mqtt-------------------&quot;</span>);  mqttClient.<span class="hljs-built_in">setCallback</span>([](<span class="hljs-keyword">char</span>* topic, byte * payload, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> length)-&gt; <span class="hljs-keyword">void</span>&#123;    String msg ;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; length; i++) &#123;      msg += (<span class="hljs-keyword">char</span> )payload[i];    &#125;    JSONVar dataJson = JSON.<span class="hljs-built_in">parse</span>(msg);    <span class="hljs-keyword">if</span> (JSON.<span class="hljs-built_in">typeof</span>(dataJson) == <span class="hljs-string">&quot;undefined&quot;</span>) &#123;      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Parsing input failed!&quot;</span>);      <span class="hljs-keyword">return</span>;    &#125; <span class="hljs-keyword">else</span>&#123;      Serial.<span class="hljs-built_in">println</span>(dataJson);    &#125;  &#125;);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>; i++) &#123;    mqttClient.<span class="hljs-built_in">connect</span>(<span class="hljs-string">&quot;NodeMcu10010&quot;</span>);<span class="hljs-comment">//    mqttClient.connect(sysConfig.mqttClientId, sysConfig.mqttUsername, sysConfig.mqttPassword);</span>    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&gt;&quot;</span>);    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">connected</span>()) &#123;      <span class="hljs-comment">//连接成功</span>      <span class="hljs-comment">//mqttClient.subscribe(String(String(&quot;/device/OUT/&quot;) + sysConfig.mqttClientId).c_str(), 2);</span>      mqttClient.<span class="hljs-built_in">subscribe</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;mqttTestNodeMcu&quot;</span>).<span class="hljs-built_in">c_str</span>(),<span class="hljs-number">2</span>);      isConnectToMqtt = <span class="hljs-literal">true</span>;      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Connect to mqtt success!&quot;</span>);      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (!mqttClient.<span class="hljs-built_in">connected</span>() ) &#123;    isConnectToMqtt = <span class="hljs-literal">false</span>;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Connect to mqtt failure.Please try again!&quot;</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   Mqtt配置:</span><span class="hljs-comment">   准备使用clientId作为Topic</span><span class="hljs-comment">   mqttset|username|password|clientId</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupMqtt</span><span class="hljs-params">(String cmd)</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Start setup mqtt&quot;</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   配置WIFI</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWlan</span><span class="hljs-params">( String cmd)</span> </span>&#123;  <span class="hljs-comment">// wlanset|206-public|665544332211</span>  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Start SysConfig wifi&quot;</span>);  String ssid = cmd.<span class="hljs-built_in">substring</span>(cmd.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;|&quot;</span>) + <span class="hljs-number">1</span>, cmd.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">&quot;|&quot;</span>));  String password = cmd.<span class="hljs-built_in">substring</span>( cmd.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">&quot;|&quot;</span>) + <span class="hljs-number">1</span>, cmd.<span class="hljs-built_in">length</span>());  ssid.<span class="hljs-built_in">trim</span>();  password.<span class="hljs-built_in">trim</span>();  <span class="hljs-keyword">if</span> (ssid.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; password.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> ) &#123;    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|Wifi SSID:&quot;</span>); Serial.<span class="hljs-built_in">println</span>(ssid);    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|Password:&quot;</span>); Serial.<span class="hljs-built_in">println</span>(password);    SysConfig &amp;tempCfg = sysConfig;    <span class="hljs-built_in">strcpy</span>(tempCfg.ssid, ssid.<span class="hljs-built_in">c_str</span>());    <span class="hljs-built_in">strcpy</span>(tempCfg.password, password.<span class="hljs-built_in">c_str</span>());    <span class="hljs-built_in">setupWifi</span>();  &#125; <span class="hljs-keyword">else</span> &#123;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;SSID and password must not null,command is : wlanset|ssid|password!&quot;</span>);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   初始化GPIO</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialGpio</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">12</span>, OUTPUT);  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">13</span>, OUTPUT);  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">15</span>, OUTPUT);  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">3</span>, OUTPUT);  <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">14</span>, OUTPUT);  <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">12</span>, LOW);  <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">13</span>, LOW);  <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">15</span>, LOW);  Wire.<span class="hljs-built_in">begin</span>();  oled.<span class="hljs-built_in">init</span>();  dht.<span class="hljs-built_in">setup</span>(DHT11_GPIO, DHTesp::DHT11);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   指示灯：三色RGB指示灯，可以组合出6种颜色；</span><span class="hljs-comment">   r g b  含义</span><span class="hljs-comment">   0 000  断电</span><span class="hljs-comment">   1 001  联网</span><span class="hljs-comment">   2 010  联网但是MQTT没有连上</span><span class="hljs-comment">   3 011  联网+MQTT连上</span><span class="hljs-comment">   4 100  断网</span><span class="hljs-comment">   5 101  待定</span><span class="hljs-comment">   6 111  待定</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">blinkRGB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pin)</span> </span>&#123;  <span class="hljs-built_in">digitalWrite</span>(pin, LOW);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">digitalWrite</span>(pin, HIGH);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   蜂鸣器 嘀嘀嘀</span><span class="hljs-comment">   beep|n</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buzzerBeep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> times)</span> </span>&#123;  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|Beep: &quot;</span>);  Serial.<span class="hljs-built_in">println</span>(times);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; times; i++) &#123;    <span class="hljs-built_in">tone</span>(BUZZER_GPIO, <span class="hljs-number">1500</span>); <span class="hljs-comment">// Send 1MHz sound signal...</span>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);        <span class="hljs-comment">// ...for 1 sec</span>    <span class="hljs-built_in">noTone</span>(BUZZER_GPIO);     <span class="hljs-comment">// Stop sound...</span>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);        <span class="hljs-comment">// ...for 1sec</span>  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">   初始化</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-built_in">buzzerBeep</span>(<span class="hljs-number">1</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">initialGpio</span>();  <span class="hljs-built_in">display</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;Hello world!NodeMcu!&quot;</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">welcome</span>();  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">loadSysConfig</span>();  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">setupWifi</span>();  <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);  <span class="hljs-built_in">initMqtt</span>();&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> *  读取DHT11</span><span class="hljs-comment">*/</span><span class="hljs-function">JSONVar <span class="hljs-title">getDHT11Data</span><span class="hljs-params">()</span> </span>&#123;  JSONVar data;  <span class="hljs-built_in">delay</span>(dht.<span class="hljs-built_in">getMinimumSamplingPeriod</span>());  <span class="hljs-comment">//湿度</span>  <span class="hljs-keyword">float</span> h = dht.<span class="hljs-built_in">getHumidity</span>();  <span class="hljs-comment">//摄氏度</span>  <span class="hljs-keyword">float</span> c = dht.<span class="hljs-built_in">getTemperature</span>();  <span class="hljs-comment">//华氏度</span>  <span class="hljs-keyword">float</span> f = dht.<span class="hljs-built_in">toFahrenheit</span>(c);  <span class="hljs-comment">//热指数</span>  <span class="hljs-keyword">float</span> cc = dht.<span class="hljs-built_in">computeHeatIndex</span>(c, h, <span class="hljs-literal">true</span>);  <span class="hljs-keyword">float</span> ff = dht.<span class="hljs-built_in">computeHeatIndex</span>(f, h, <span class="hljs-literal">true</span>);  data[<span class="hljs-string">&quot;h&quot;</span>] = h;  data[<span class="hljs-string">&quot;c&quot;</span>] = c;  data[<span class="hljs-string">&quot;f&quot;</span>] = f;  data[<span class="hljs-string">&quot;cc&quot;</span>] = cc;  data[<span class="hljs-string">&quot;ff&quot;</span>] = ff;  <span class="hljs-keyword">return</span> data;&#125;<span class="hljs-function">JSONVar <span class="hljs-title">jsonDataPackage</span><span class="hljs-params">(JSONVar j2strData)</span></span><span class="hljs-function"></span>&#123;  JSONVar jsonData;  jsonData[<span class="hljs-string">&quot;clientId&quot;</span>] = clientId;  jsonData[<span class="hljs-string">&quot;value&quot;</span>] = JSON.<span class="hljs-built_in">stringify</span>(j2strData);    <span class="hljs-keyword">return</span> jsonData;&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;String publishData = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;  count += <span class="hljs-number">1</span>;  <span class="hljs-keyword">if</span> (isConnectToMqtt) &#123;    mqttClient.<span class="hljs-built_in">loop</span>();    <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">100000</span>) &#123;      publishData = JSON.<span class="hljs-built_in">stringify</span>(<span class="hljs-built_in">jsonDataPackage</span>(<span class="hljs-built_in">getDHT11Data</span>()));<span class="hljs-comment">//      flag=mqttClient.publish(&quot;/device/IN/NodeMcuTest&quot;,publishData.c_str(),strlen(publishData.c_str()));</span>      mqttClient.<span class="hljs-built_in">beginPublish</span>(<span class="hljs-string">&quot;/device/IN/NodeMcuTest&quot;</span>,<span class="hljs-built_in">strlen</span>(publishData.<span class="hljs-built_in">c_str</span>()),<span class="hljs-literal">false</span>);      mqttClient.<span class="hljs-built_in">print</span>(publishData.<span class="hljs-built_in">c_str</span>());      mqttClient.<span class="hljs-built_in">endPublish</span>();      Serial.<span class="hljs-built_in">println</span>(publishData+flag);      count = <span class="hljs-number">0</span>;    &#125;  &#125;  String cmd = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span> (Serial.<span class="hljs-built_in">available</span>() &gt; <span class="hljs-number">0</span>) &#123;    cmd = Serial.<span class="hljs-built_in">readStringUntil</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);    <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);  &#125;  <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;help&quot;</span>))) &#123;      <span class="hljs-built_in">showHelp</span>();    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;wlaninfo&quot;</span>))) &#123;      <span class="hljs-built_in">echoWlan</span>();    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;temp&quot;</span>))) &#123;      <span class="hljs-built_in">echoTemp</span>();    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hum&quot;</span>))) &#123;      <span class="hljs-built_in">echoHumidity</span>();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">       led 闪烁</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;red&quot;</span>))) &#123;      <span class="hljs-built_in">blinkRGB</span>(<span class="hljs-number">12</span>);    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;green&quot;</span>))) &#123;      <span class="hljs-built_in">blinkRGB</span>(<span class="hljs-number">13</span>);    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">equals</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;blue&quot;</span>))) &#123;      <span class="hljs-built_in">blinkRGB</span>(<span class="hljs-number">15</span>);    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">startsWith</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;wlanset|&quot;</span>))) &#123;      <span class="hljs-built_in">setWlan</span>(cmd);    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">startsWith</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;mqttset|&quot;</span>))) &#123;      <span class="hljs-built_in">setWlan</span>(cmd);    &#125;    <span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">startsWith</span>(<span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;beep|&quot;</span>))) &#123;      <span class="hljs-keyword">int</span> times = cmd.<span class="hljs-built_in">substring</span>( cmd.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">&quot;|&quot;</span>) + <span class="hljs-number">1</span>, cmd.<span class="hljs-built_in">length</span>()).<span class="hljs-built_in">toInt</span>();      <span class="hljs-built_in">buzzerBeep</span>(times);    &#125;  &#125;  <span class="hljs-comment">// wlanset|206-public|665544332211</span>  <span class="hljs-keyword">if</span> ( isConnectToWifi) &#123;    <span class="hljs-comment">// blue</span>    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">12</span>, LOW);    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">13</span>, LOW);    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">15</span>, HIGH);    <span class="hljs-comment">//if connect to mqtt</span>    <span class="hljs-keyword">if</span> (isConnectToWifi &amp;&amp; isConnectToMqtt) &#123;      <span class="hljs-comment">//Green</span>      <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">12</span>, LOW);      <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">13</span>, HIGH);      <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">15</span>, LOW);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//Red</span>    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">12</span>, HIGH);    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">13</span>, LOW);    <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">15</span>, LOW);  &#125;&#125;</code></pre><p>上述代码,注释加的比较完善,比较容易看懂,就不详细解释了,有个细节在这里提一下就行,位置在通过串口配置网络处:</p><pre><code class="hljs C++"><span class="hljs-comment">/**</span><span class="hljs-comment">   配置网络</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupWifi</span><span class="hljs-params">()</span> </span>&#123;  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;-----------------SetUp wifi-------------------&quot;</span>);  Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;|Try  connect to network.&quot;</span>);  Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|&quot;</span>);  WiFi.<span class="hljs-built_in">begin</span>(sysConfig.ssid, sysConfig.password);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>; i++) &#123;    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&gt;&quot;</span>);      <span class="hljs-comment">/**</span><span class="hljs-comment">      *</span><span class="hljs-comment">      *此处的delay1000很重要,为了防止抖动引起的误差.</span><span class="hljs-comment">      **/</span>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">status</span>() == WL_CONNECTED) &#123;      WiFi.<span class="hljs-built_in">hostname</span>(<span class="hljs-string">&quot;ESP8266_NODE_1&quot;</span>);      Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Success connect to network.&quot;</span>);      isConnectToWifi = <span class="hljs-literal">true</span>;      <span class="hljs-built_in">writeSysConfig</span>();      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (WiFi.<span class="hljs-built_in">status</span>() != WL_CONNECTED) &#123;    Serial.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;\n|Connect to network failure.Please try again!&quot;</span>);  &#125;&#125;</code></pre><p>单独把 delay(1000);这行拿出来说,因为通过实际操作发现,串口数据抖动还是比较大,建议做延迟防抖.</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本文展示了一段简单的Arduino代码Demo.</p>]]></content>
    
    
    <categories>
      
      <category>Arduino</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arduino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThingsBoard源码分析-JavaMqtt实现原理</title>
    <link href="/2020/01/02/clpqt1iv0004r4cue8zi631iw.html"/>
    <url>/2020/01/02/clpqt1iv0004r4cue8zi631iw.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下著名物联网应用ThingsBoard中Java实现Mqtt协议的一些细节.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ThingsBoard是一个github上star数非常高的项目,主要特色是开源,纯Java技术栈,对于学习者来说降低了门槛.本人闲暇之余,学习了一下其设计思路和源码,大致把自己的心得和一些研究成果做一个记录.</p><p>这里主要记录了ThingsBoard的基本架构和部分源码分析(主要是Java实现Mqtt部分),并未研究如何使用,如果享要使用,请移步此处查看文档:<a href="https://thingsboard.io">https://thingsboard.io</a>.</p><h2 id="2-Mqtt协议简介"><a href="#2-Mqtt协议简介" class="headerlink" title="2.Mqtt协议简介"></a>2.Mqtt协议简介</h2><p>首先提一下MQTT 协议吧,MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是一种基于<strong>发布/订阅</strong>范式的“轻量级”消息协议，由 IBM 发布。目前广泛应用于物联网.相关知识请移步这里:<a href="http://mqtt.p2hp.com">http://mqtt.p2hp.com</a></p><p>其中ThingsBoard支持的基本协议就是MQTT 协议.</p><h2 id="3-ThingsBoard简介"><a href="#3-ThingsBoard简介" class="headerlink" title="3.ThingsBoard简介"></a>3.ThingsBoard简介</h2><p>ThingsBoard是一个开源平台，用于收集和可视化物联网设备的数据。可以将来自任意数量设备的数据发送到云服务器，在云服务器中可以通过可自定义的仪表板查看或共享。</p><p>Thingsboard支持提供设备连接的标准协议是MQTT，CoAP和HTTP，并支持云和本地部署。 它提供了30多个可自定义的小部件，允许您为大多数物联网用例构建最终用户自定义仪表板。thingsboard.io开源的物联网平台主要特点：实时数据可视化和远程设备控制自定义仪表板的30个可定制小部件可定制的规则，插件，小部件和传输实现允许监视客户端和提供服务器端设备属性。支持多租户安装即装即用。支持MQTT和HTTP协议的传输加密。失败的节点可以在没有停机的情况下进行更换.Thingsboard分为专业版和社区版，社区版是开源的，专业版是收费的.</p><h2 id="4-Netty简介"><a href="#4-Netty简介" class="headerlink" title="4.Netty简介"></a>4.Netty简介</h2><p>因为ThingsBoard的Mqtt协议处理相关部分是用Java实现的,其中使用的框架是Netty,所以这里我们需要着重介绍一下Netty.</p><p>Netty是Java的一个NIO框架,架构图如下所示(取自官网):</p><p><img src="/uploads/4185175-54ccd179f77b8390.webp" alt="img"></p><p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。<br>Netty 是一个广泛使用的 Java 网络编程框架（Netty 在 2011 年获得了Duke’s Choice Award，见<a href="https://www.java.net/dukeschoice/2011）。它活跃和成长于用户社区，像大型公司">https://www.java.net/dukeschoice/2011）。它活跃和成长于用户社区，像大型公司</a> Facebook 和 Instagram 以及流行 开源项目如 Infinispan, HornetQ, Vert.x, Apache Cassandra 和 Elasticsearch 等，都利用其强大的对于网络抽象的核心代码。</p><blockquote><p>摘自[《Essential Netty In Action》</p></blockquote><p>说白了就是Netty是一个性能非常优秀的网络通讯框架,可以自定义各种协议,开发基于TCP/IP栈的应用协议.换句话来说,Netty的核心功能就是让你自己实现协议,因此属于比较高级的Java内容,要求大家的通信基础知识扎实.</p><p>关于更多的这里就不介绍了,详情请移步:<a href="https://netty.io/index.html">https://netty.io/index.html</a>.</p><h2 id="7-Netty实现Mqtt协议"><a href="#7-Netty实现Mqtt协议" class="headerlink" title="7.Netty实现Mqtt协议"></a>7.Netty实现Mqtt协议</h2><p>ThingsBoard的Mqtt协议处理是用Netty实现的,我们来看看基本的代码结构.</p><p>首先我们看下Mqtt协议实现的核心类:<a href="https://github.com/thingsboard/thingsboard/tree/master/netty-mqtt/src/main/java/org/thingsboard/mqtt">https://github.com/thingsboard/thingsboard/tree/master/netty-mqtt/src/main/java/org/thingsboard/mqtt</a>.</p><p><img src="/uploads/image-20200102145611920.png" alt="image-20200102145611920"></p><p>包含的是Mqtt协议的具体实现和协议处理相关的类,我们挑其中一个比较重要的协议报文处理类:<a href="https://github.com/thingsboard/thingsboard/blob/master/netty-mqtt/src/main/java/org/thingsboard/mqtt/MqttChannelHandler.java,来分析一下代码">https://github.com/thingsboard/thingsboard/blob/master/netty-mqtt/src/main/java/org/thingsboard/mqtt/MqttChannelHandler.java,来分析一下代码</a>.</p><ol><li><h3 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MqttChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MqttMessage</span>&gt; </span>&#123;<span class="hljs-comment">//.......</span>&#125;</code></pre><p>​        Mqtt协议处理器继承的是SimpleChannelInboundHandler,这个类主要就是处理消息和转换消息,吧网络字节流转换成MqttMessage类,其中:SimpleChannelInboundHandler<T> 是一个Netty提供给用户的接口,用来自动转换网络字节流.</p></li></ol><ol start="2"><li><h3 id="协议报文处理"><a href="#协议报文处理" class="headerlink" title="协议报文处理"></a>协议报文处理</h3><p>下面我们摘取一段代码来进行简单分析:</p><pre><code class="hljs java"><span class="hljs-comment">//......</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MqttMessage msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//处理Mqtt报文,类型见下表</span>        <span class="hljs-keyword">switch</span> (msg.fixedHeader().messageType()) &#123;            <span class="hljs-keyword">case</span> CONNACK:                handleConack(ctx.channel(), (MqttConnAckMessage) msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> SUBACK:                handleSubAck((MqttSubAckMessage) msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PUBLISH:                handlePublish(ctx.channel(), (MqttPublishMessage) msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> UNSUBACK:                handleUnsuback((MqttUnsubAckMessage) msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PUBACK:                handlePuback((MqttPubAckMessage) msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PUBREC:                handlePubrec(ctx.channel(), msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PUBREL:                handlePubrel(ctx.channel(), msg);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> PUBCOMP:                handlePubcomp(msg);                <span class="hljs-keyword">break</span>;        &#125;    &#125;<span class="hljs-comment">//.....</span></code></pre></li></ol><blockquote><p>​        也许你对channelRead0这个命名比较迷惑,其实这个问题作者本人也说了,是不小心随手写的:”silly mistake”.关于这个类的重写,我个人总结出来的一种写法比较好,可以作为参考:</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;<span class="hljs-keyword">import</span> io.netty.util.ReferenceCountUtil;<span class="hljs-keyword">import</span> io.netty.util.internal.TypeParameterMatcher;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 重写了一下Netty提供的SimpleChannelInboundHandler</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;I&gt;I表示一个抽象 ，特指实现了Message的具体消息的类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageReceiveHandler</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * TypeParameterMatcher 是为了判断泛型的类, 然后根据传入的泛型来确定类型拦截器</span><span class="hljs-comment">     * 比如泛型的类是Mqtt消息，然后识别出来以后就会使用Mqtt的拦截器Handler</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TypeParameterMatcher matcher;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> autoRelease;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MessageReceiveHandler</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MessageReceiveHandler</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoRelease)</span> </span>&#123;        <span class="hljs-keyword">this</span>.matcher = TypeParameterMatcher.find(<span class="hljs-keyword">this</span>, MessageReceiveHandler.class, <span class="hljs-string">&quot;I&quot;</span>);        <span class="hljs-keyword">this</span>.autoRelease = autoRelease;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MessageReceiveHandler</span><span class="hljs-params">(Class&lt;? extends I&gt; inboundMessageType)</span> </span>&#123;        <span class="hljs-keyword">this</span>(inboundMessageType, <span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MessageReceiveHandler</span><span class="hljs-params">(Class&lt;? extends I&gt; inboundMessageType, <span class="hljs-keyword">boolean</span> autoRelease)</span> </span>&#123;        <span class="hljs-keyword">this</span>.matcher = TypeParameterMatcher.get(inboundMessageType);        <span class="hljs-keyword">this</span>.autoRelease = autoRelease;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 这个方法的作用是：判断是否是泛型规定的消息类型</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acceptInboundMessage</span><span class="hljs-params">(Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.matcher.match(msg);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从消息管道中读取消息，然后处理成泛型识别出来的类型(理解起来很蛋疼)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">boolean</span> release = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.acceptInboundMessage(msg)) &#123;                <span class="hljs-keyword">this</span>.messageReceived(ctx, (I) msg);            &#125; <span class="hljs-keyword">else</span> &#123;                release = <span class="hljs-keyword">false</span>;                ctx.fireChannelRead(msg);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoRelease &amp;&amp; release) &#123;                ReferenceCountUtil.release(msg);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在上一步的 channelRead 中，已经处理了消息转换，所以我们实现这个方法的时候，I 其实就是我们具体的消息了</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channelHandlerContext 具体的处理器的上下文</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i                     具体消息</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">messageReceived</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, I i)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 断线</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">super</span>.channelInactive(ctx);    &#125;&#125;</code></pre></blockquote><p>   ​        channelRead0方法负责处理流入的消息,其中ChannelHandlerContext表示当前连接进来的客户端的上下文,通俗点讲就是Socket的封装,而MqttMessage则是泛型T传进来的类型,表示这里已经是Mqtt报文.</p><p>   ​        在此之前本人也尝试有用Netty实现一个MqttServer,但是工作量比较大,做的不完善,经过参考别人的代码,最终修改出来了一个自定义的处理器可做参考:<a href="https://github.com/wwhai/EasyJMqttServer/blob/master/mqtt-broker/src/main/java/com/easyiot/iot/mqtt/server/core/BrokerHandler.java">https://github.com/wwhai/EasyJMqttServer/blob/master/mqtt-broker/src/main/java/com/easyiot/iot/mqtt/server/core/BrokerHandler.java</a>.</p><p>   ​        Mqtt报文有很多种,详细见下表,含义请看这里:<a href="http://mqtt.p2hp.com/mqtt311">http://mqtt.p2hp.com/mqtt311</a>.</p><table><thead><tr><th>报文类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CONNECT</td><td>1</td><td>客户端向代理发起连接请求</td></tr><tr><td>CONNACK</td><td>2</td><td>连接确认</td></tr><tr><td>PUBLISH</td><td>3</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>发布确认</td></tr><tr><td>PUBREC</td><td>5</td><td>发布收到（QoS2）</td></tr><tr><td>PUBREL</td><td>6</td><td>发布释放（QoS2）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>发布完成（QoS2）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端向代理发起订阅请求</td></tr><tr><td>SUBACK</td><td>9</td><td>订阅确认</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>取消订阅</td></tr><tr><td>UNSUBACK</td><td>11</td><td>取消订阅确认</td></tr><tr><td>PINGREQ</td><td>12</td><td>PING请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>PING响应</td></tr><tr><td>DISCONNECT</td><td>14</td><td>断开连接</td></tr></tbody></table><p>   switch语句就是为了处理不同的协议包.我们拿其中的CONACK包来分析一下:</p>   <pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleConack</span><span class="hljs-params">(Channel channel, MqttConnAckMessage message)</span> </span>&#123;      <span class="hljs-keyword">switch</span> (message.variableHeader().connectReturnCode()) &#123;      <span class="hljs-comment">//当连接成功以后,返回应答报文,然后回应客户端</span>       <span class="hljs-keyword">case</span> CONNECTION_ACCEPTED:           <span class="hljs-keyword">this</span>.connectFuture.setSuccess(<span class="hljs-keyword">new</span> MqttConnectResult(<span class="hljs-keyword">true</span>, MqttConnectReturnCode.CONNECTION_ACCEPTED, channel.closeFuture()));               <span class="hljs-keyword">this</span>.client.getPendingSubscriptions().entrySet().stream().filter((e) -&gt; !e.getValue().isSent()).forEach((e) -&gt; &#123;                 channel.write(e.getValue().getSubscribeMessage());                 e.getValue().setSent(<span class="hljs-keyword">true</span>);   &#125;);       <span class="hljs-keyword">this</span>.client.getPendingPublishes().forEach((id, publish) -&gt; &#123;       <span class="hljs-keyword">if</span> (publish.isSent()) <span class="hljs-keyword">return</span>;          channel.write(publish.getMessage());          publish.setSent(<span class="hljs-keyword">true</span>);          <span class="hljs-keyword">if</span> (publish.getQos() == MqttQoS.AT_MOST_ONCE) &#123;          publish.getFuture().setSuccess(<span class="hljs-keyword">null</span>); <span class="hljs-comment">//We don&#x27;t get an ACK for QOS 0</span>          <span class="hljs-keyword">this</span>.client.getPendingPublishes().remove(publish.getMessageId());        &#125;   &#125;);         channel.flush();         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.client.isReconnect()) &#123;         <span class="hljs-keyword">this</span>.client.onSuccessfulReconnect();         &#125;         <span class="hljs-keyword">break</span>;          <span class="hljs-comment">//此处处理的就是连接失败的情况,对应状态码看下面给出的表</span>          <span class="hljs-keyword">case</span> CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD:          <span class="hljs-keyword">case</span> CONNECTION_REFUSED_IDENTIFIER_REJECTED:          <span class="hljs-keyword">case</span> CONNECTION_REFUSED_NOT_AUTHORIZED:          <span class="hljs-keyword">case</span> CONNECTION_REFUSED_SERVER_UNAVAILABLE:          <span class="hljs-keyword">case</span> CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION:          <span class="hljs-keyword">this</span>.connectFuture.setSuccess(<span class="hljs-keyword">new</span> MqttConnectResult(<span class="hljs-keyword">false</span>, message.variableHeader().connectReturnCode(), channel.closeFuture()));          channel.close();      <span class="hljs-comment">// Don&#x27;t start reconnect logic here</span>      <span class="hljs-comment">// 翻译:不要在这里进行重连.这是为什么?因为客户端都断开了,这个状态明确知道,  所以不用再次尝试连接</span>           <span class="hljs-keyword">break</span>;      &#125;&#125;</code></pre><p>   ​        CONNACK是代理用来响应客户端CONNECT的报文。代理向客户端发送的第一个报文必须是CONNACT。CONNACK有一个固定报头，一个可变报头，但是不带有荷载。CONNACK报文的可变报头为定长2字节。第一字节的0位表示是否有会话存在。如果代理上已经有请求连接的客户端的会话，且连接请求的清除会话标识为0，则该位为1，否则该位为0。客户端可以根据这一位的值采取响应行为，比如（重新）订阅主题等。</p><p>   ​        CONNACK报文的可变报头的第二字节为返回码。如果CONNECT请求的格式正确，但是代理依然不能允许客户端连接，则返回码为一个非零值。如果连接成功，则返回0。</p><table><thead><tr><th>值</th><th>返回码含义</th></tr></thead><tbody><tr><td>0</td><td>成功，连接请求被接受。</td></tr><tr><td>1</td><td>拒绝连接，不可接受的协议版本。</td></tr><tr><td>2</td><td>拒绝连接，不被允许的身份识别符（Client Identifier）。</td></tr><tr><td>3</td><td>拒绝连接，服务器不可用。</td></tr><tr><td>4</td><td>拒绝连接，无效的用户名和密码。</td></tr><tr><td>5</td><td>拒绝连接，客户端无授权。</td></tr><tr><td>6-255</td><td>系统保留。</td></tr></tbody></table><p>   ​        我们从代码实现可知,Netty其实就是做了协议和报文封装,具体的实现和分析,转换,还是根据具体自定义的规范去实施,类似于上述Mqtt的CONNACK报文处理一样.MqttConnectResult是一个给客户端的回应结果封装.</p><p>   ​        按照这个思路,我们继续来看下publish报文的处理,分别处理了三种QOS的报文:</p>   <pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlePublish</span><span class="hljs-params">(Channel channel, MqttPublishMessage message)</span> </span>&#123;   <span class="hljs-comment">//根据不同的QOS来进行处理   </span>    <span class="hljs-keyword">switch</span> (message.fixedHeader().qosLevel()) &#123;   <span class="hljs-comment">//QOS=1的情况            </span>   <span class="hljs-keyword">case</span> AT_MOST_ONCE:   invokeHandlersForIncomingPublish(message);   <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//QOS=1的情况</span>   <span class="hljs-keyword">case</span> AT_LEAST_ONCE:   invokeHandlersForIncomingPublish(message);   <span class="hljs-keyword">if</span> (message.variableHeader().packetId() != -<span class="hljs-number">1</span>) &#123;   MqttFixedHeader fixedHeader = <span class="hljs-keyword">new</span> MqttFixedHeader(MqttMessageType.PUBACK, <span class="hljs-keyword">false</span>, MqttQoS.AT_MOST_ONCE, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);   MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(message.variableHeader().packetId());                       channel.writeAndFlush(<span class="hljs-keyword">new</span> MqttPubAckMessage(fixedHeader, variableHeader));   &#125;   <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//QOS=2的情况</span>   <span class="hljs-keyword">case</span> EXACTLY_ONCE:   <span class="hljs-keyword">if</span> (message.variableHeader().packetId() != -<span class="hljs-number">1</span>) &#123;   <span class="hljs-comment">// MqttFixedHeader:Mqtt固定报文头的封装格式</span>   MqttFixedHeader fixedHeader = <span class="hljs-keyword">new</span> MqttFixedHeader(MqttMessageType.PUBREC, <span class="hljs-keyword">false</span>, MqttQoS.AT_MOST_ONCE, <span class="hljs-keyword">false</span>, <span class="hljs-number">0</span>);   MqttMessageIdVariableHeader variableHeader = MqttMessageIdVariableHeader.from(message.variableHeader().packetId());   MqttMessage pubrecMessage = <span class="hljs-keyword">new</span> MqttMessage(fixedHeader, variableHeader);      MqttIncomingQos2Publish incomingQos2Publish = <span class="hljs-keyword">new</span> MqttIncomingQos2Publish(message, pubrecMessage);                      <span class="hljs-keyword">this</span>.client.getQos2PendingIncomingPublishes().put(message.variableHeader().packetId(), incomingQos2Publish);   message.payload().retain();   incomingQos2Publish.startPubrecRetransmitTimer(<span class="hljs-keyword">this</span>.client.getEventLoop().next(), <span class="hljs-keyword">this</span>.client::sendAndFlushPacket);   channel.writeAndFlush(pubrecMessage);   &#125;      <span class="hljs-keyword">break</span>;     &#125;   &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">   *处理入站报文</span><span class="hljs-comment">   **/</span>      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeHandlersForIncomingPublish</span><span class="hljs-params">(MqttPublishMessage message)</span> </span>&#123;           <span class="hljs-keyword">boolean</span> handlerInvoked = <span class="hljs-keyword">false</span>;          <span class="hljs-comment">//遍历所有的订阅,然后交给handler去处理</span>           <span class="hljs-keyword">for</span> (MqttSubscription subscription : ImmutableSet.copyOf(<span class="hljs-keyword">this</span>.client.getSubscriptions().values())) &#123;               <span class="hljs-keyword">if</span> (subscription.matches(message.variableHeader().topicName())) &#123;                   <span class="hljs-keyword">if</span> (subscription.isOnce() &amp;&amp; subscription.isCalled()) &#123;                       <span class="hljs-keyword">continue</span>;                   &#125;                   message.payload().markReaderIndex();                   subscription.setCalled(<span class="hljs-keyword">true</span>);                   subscription.getHandler().onMessage(message.variableHeader().topicName(), message.payload());                   <span class="hljs-keyword">if</span> (subscription.isOnce()) &#123;                       <span class="hljs-keyword">this</span>.client.off(subscription.getTopic(), subscription.getHandler());                   &#125;                   message.payload().resetReaderIndex();                   handlerInvoked = <span class="hljs-keyword">true</span>;               &#125;           &#125;           <span class="hljs-keyword">if</span> (!handlerInvoked &amp;&amp; client.getDefaultHandler() != <span class="hljs-keyword">null</span>) &#123;               client.getDefaultHandler().onMessage(message.variableHeader().topicName(), message.payload());           &#125;           message.payload().release();&#125;</code></pre><p>   ​        我们不难看出,其实就是按照MQTT协议的实现文档进行了Java Class封装和处理.技术难点在于吃透协议规范.</p><p>   ​        还有其他的协议报文大同小异,基本就都是精细活,按照官方文档,挨个实现即可.当我们掌握了Netty的这种用法以后,可以很容易实现各种协议,比如可以实现一个Redis客户端,或者是Mysql客户端等等,实现起来都是比较容易的.</p><p>   ​        Netty框架是十分强大的,如果精通以后可以开发出高性能,高并发的应用,很适合用在物联网或者通信相关的场景.用Java开发的MqttServer效率也是非常高,建议大家深入研究一下.</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>​        本文主要讲了Netty实现Mqtt协议的关键部分:协议报文处理.</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FRP注册为系统服务</title>
    <link href="/2019/12/30/clpqt1iuz004l4cueehf64u7f.html"/>
    <url>/2019/12/30/clpqt1iuz004l4cueehf64u7f.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲以下如何把FRP注册为Linux系统服务.</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>​        我们可以用FRP来搭建内网穿透环境,方便自己的内网主机映射到公网.本文主要讲如何把FRP配置为系统进程,每次开机自动加载运行.</p><p>​        请首先根据frp文档再服务端装好frps,然后下载对应平台的客户端.</p><h2 id="2-相关操作"><a href="#2-相关操作" class="headerlink" title="2.相关操作"></a>2.相关操作</h2><ol><li><p>首先在/lib/systemd/system/目录下，创建服务脚本：frpc.service,</p></li><li><p>设置让脚本开机自动启动</p><pre><code class="hljs routeros">sudo systemctl <span class="hljs-builtin-name">enable</span> frpc.service</code></pre></li><li><p>常用命令</p><pre><code class="hljs dsconfig">重新加载<span class="hljs-string">service</span>文件：<span class="hljs-string">systemctl</span> <span class="hljs-string">daemon-reload</span>启动一个服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>关闭一个服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">stop</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>重启一个服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>显示一个服务的状态：<span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>在开机时启用一个服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>在开机时禁用一个服务：<span class="hljs-string">systemctl</span> <span class="hljs-string">disable</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>查看服务是否开机启动：<span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> <span class="hljs-string">frpc</span>.<span class="hljs-string">service</span>查看已启动的服务列表：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files|grep</span> <span class="hljs-string">enabled</span>查看启动失败的服务列表：<span class="hljs-string">systemctl</span> <span class="hljs-built_in">--failed</span></code></pre></li></ol><h2 id="2-服务配置"><a href="#2-服务配置" class="headerlink" title="2.服务配置"></a>2.服务配置</h2><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><span class="hljs-attr">Type</span>=forking<span class="hljs-attr">User</span>=root<span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s<span class="hljs-attr">ExecStart</span>=/home/lubuntu/frp_0.<span class="hljs-number">30.0</span>_linux_amd64/frpc -c /home/lubuntu/frp_0.<span class="hljs-number">30.0</span>_linux_amd64/frpcw.ini<span class="hljs-attr">ExecReload</span>=/home/lubuntu/frp_0.<span class="hljs-number">30.0</span>_linux_amd64/frpc reload -c /home/lubuntu/frp_0.<span class="hljs-number">30.0</span>_linux_amd64/frpcw.ini<span class="hljs-section">[Install]</span><span class="hljs-attr">WantedBy</span>=multi-user.target</code></pre><p>​        相关路径需要换成自己的实际路径.</p><h2 id="3-frp配置"><a href="#3-frp配置" class="headerlink" title="3.frp配置"></a>3.frp配置</h2><pre><code class="hljs ini"><span class="hljs-section">[common]</span><span class="hljs-attr">server_addr</span> = 公网IP<span class="hljs-attr">server_port</span> = 公网端口(注意要开启网段安全组)<span class="hljs-attr">token</span>= *****<span class="hljs-section">[主机名,比如ubuntu]</span><span class="hljs-attr">type</span> = tcp/http<span class="hljs-attr">remote_port</span> = 公网服务器分配给服务端的端口(注意要开启网段安全组)<span class="hljs-attr">local_ip</span> = 本地IP地址<span class="hljs-attr">local_port</span> = 本地端口</code></pre><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>​        本文主要讲了如何把FRP配置到系统服务.</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
      <tag>骚技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX核心连接器-Esockd框架的使用</title>
    <link href="/2019/12/30/clpqt1itv000v4cuegkni303p.html"/>
    <url>/2019/12/30/clpqt1itv000v4cuegkni303p.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲EMQX开源出来的连接框架Esockd的基本使用</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>我们用Erlang开发TCP应用的时候,要么是用Erlang自己的库,要么是用一些用Erlang实现的三方库,比如lib_chan等.经过两个月的学习,我大概总结了一下,不能说是哪种做法不对或者对,一般都是按照实际业务选择框架,况且Erlang对TCP天然支持非常好,所以这里仁者见仁.</p><p>而今天我给大家带来的也是一个三方公司实现的高性能TCP框架:Esockd.</p><h2 id="2-Esockd基础"><a href="#2-Esockd基础" class="headerlink" title="2.Esockd基础"></a>2.Esockd基础</h2><p>说起这个esockd可能很多朋友还不知道,但是很多玩物联网的朋友可能听过EMQ这个物联网消息服务器,而Esockd框架就是EMQX的核心连接器实现框架.官方仓库在此;<a href="https://github.com/emqx/esockd">https://github.com/emqx/esockd</a>.</p><p>下面我就简单解读一下官方的Demo实现.</p><h2 id="3-一个简单的TCP服务器的实现"><a href="#3-一个简单的TCP服务器的实现" class="headerlink" title="3.一个简单的TCP服务器的实现"></a>3.一个简单的TCP服务器的实现</h2><p>这是官方给出的最简单的一个Demo:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(echo_server)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">2</span>, init/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Transport, Sock)</span> -&gt;</span>    &#123;ok, spawn_link(?MODULE, init, [Transport, Sock])&#125;.<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Transport, Sock)</span> -&gt;</span>    <span class="hljs-keyword">case</span> Transport:wait(Sock) <span class="hljs-keyword">of</span>        &#123;ok, NewSock&#125; -&gt;            loop(Transport, NewSock);        Error -&gt; Error    <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">loop</span><span class="hljs-params">(Transport, Sock)</span> -&gt;</span>    <span class="hljs-keyword">case</span> Transport:recv(Sock, <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>        &#123;ok, Data&#125; -&gt;            &#123;ok, Peername&#125; = Transport:peername(Sock),            Transport:send(Sock, Data),            loop(Transport, Sock);        &#123;error, Reason&#125; -&gt;            io:format(<span class="hljs-string">&quot;TCP Error: ~s~n&quot;</span>, [Reason]),            &#123;stop, Reason&#125;    <span class="hljs-keyword">end</span>.</code></pre><p>我们解读一下代码:</p><ol><li><p>启动</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Transport, Sock)</span> -&gt;</span>    &#123;ok, spawn_link(?MODULE, init, [Transport, Sock])&#125;.</code></pre><p>上面这段代码用到了一个高级函数:spawn_link,这个函数的作用是把当前模块变成一个系统进程.</p><pre><code class="hljs erlang">Transport:wait(Sock)</code></pre><p>上述代码是大家比较熟悉的等待连接的过程.</p></li><li><p>循环接受消息</p><pre><code class="hljs erlang">Transport:recv/<span class="hljs-number">2</span></code></pre><p>上述函数是接收消息,这个也何标准的库类似.有数据以后会返回元组:{ok, Data}.</p></li></ol><p>我们简单分析了一下esockd的demo发现好像和标准库区别不大,接下来我们再来看几个高级特性.</p><h2 id="4-API解读"><a href="#4-API解读" class="headerlink" title="4.API解读"></a>4.API解读</h2><ol><li><p>开启一个监听器</p><pre><code class="hljs erlang">esockd:open(echo, <span class="hljs-number">5000</span>, [&#123;tcp_options, [binary, &#123;reuseaddr, true&#125;]&#125;],            &#123;echo_server, start_link, []&#125;).</code></pre><p>​        上述代码表示开启一个名字为echo的服务器,监听5000端口,后面的元组则是大家熟悉的TCP Socket连接参数.</p><pre><code class="hljs erlang">esockd:open(echo, &#123;<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6000</span>&#125;, [&#123;tcp_options, [binary, &#123;reuseaddr, true&#125;]&#125;],            &#123;echo_server, start_link, []&#125;).</code></pre><p>​        上述代码不一样的是出现了一个元组:<code>&#123;&quot;127.0.0.1&quot;, 6000&#125;</code>,这个看起来也很熟悉,就是IP地址过滤,只允许本地连接.</p></li><li><p>ACL权限控制</p><pre><code class="hljs erlang">esockd:allow(&#123;echo, <span class="hljs-number">5000</span>&#125;, all).esockd:allow(&#123;echo, <span class="hljs-number">5000</span>&#125;, <span class="hljs-string">&quot;192.168.0.1/24&quot;</span>).esockd:deny(&#123;echo, <span class="hljs-number">5000</span>&#125;, all).esockd:deny(&#123;echo, <span class="hljs-number">5000</span>&#125;, <span class="hljs-string">&quot;10.10.0.0/16&quot;</span>).</code></pre><p>​        上述代码是ACL权限控制,表示允许的网段/IP,其中all表示连接所有.</p></li></ol><h2 id="5-服务器实战"><a href="#5-服务器实战" class="headerlink" title="5.服务器实战"></a>5.服务器实战</h2><p>​        学玩上面的基础知识,我们只需要稍微把之前写的标准库实现的TCP服务器改动一下,就可实现一个高性能的服务器.</p><p>​       下面是之前提到的trap协议服务器端的实现主要代码:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(trap_tcp_server)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(gen_server)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">2</span>, start/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([init/<span class="hljs-number">1</span>, handle_call/<span class="hljs-number">3</span>, handle_cast/<span class="hljs-number">2</span>, handle_info/<span class="hljs-number">2</span>, terminate/<span class="hljs-number">2</span>, code_change/<span class="hljs-number">3</span>])</span>.<span class="hljs-keyword">-record</span><span class="hljs-params">(trap_client_info, &#123;id, client_id, ip, socket, auth = false, mode&#125;)</span>.<span class="hljs-comment">%% Connection info,保存进进程</span><span class="hljs-keyword">-record</span><span class="hljs-params">(trap_connection_info, &#123;id, client_id, ip, transport, socket, auth = false, mode&#125;)</span>.<span class="hljs-comment">%% ETS 表名</span><span class="hljs-keyword">-define</span><span class="hljs-params">(CLIENT_TABLE, trap_connection_table)</span>.<span class="hljs-comment">%% 等待认证事件5S</span><span class="hljs-keyword">-define</span><span class="hljs-params">(EXPIRE_TIME, <span class="hljs-number">3000</span>)</span>.<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(Port)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_integer</span><span class="hljs-params">(Port)</span> -&gt;</span>  <span class="hljs-comment">%% Start ets</span>  ets:new(?CLIENT_TABLE, [named_table, public, set, &#123;keypos, #trap_client_info.id&#125;,    &#123;write_concurrency, true&#125;, &#123;read_concurrency, true&#125;]),  <span class="hljs-comment">%% Start esockd</span>  esockd:start(),  Options = [&#123;acceptors, <span class="hljs-number">8</span>&#125;,    &#123;max_connections, <span class="hljs-number">100000</span>&#125;,    &#123;tcp_options,      [binary,        &#123;reuseaddr, true&#125;,        &#123;backlog, <span class="hljs-number">512</span>&#125;,        &#123;packet, <span class="hljs-number">0</span>&#125;,        &#123;nodelay, false&#125;]&#125;],  MFA = &#123;?MODULE, start_link, []&#125;,  esockd:open(trap_server_connector, Port, Options, MFA).<span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Transport, Socket)</span> -&gt;</span>  &#123;ok, proc_lib:spawn_link(?MODULE, init, [[Transport, Socket]])&#125;.<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([Transport, Socket])</span> -&gt;</span>  <span class="hljs-keyword">case</span> Transport:wait(Socket) <span class="hljs-keyword">of</span>    &#123;ok, NewSocket&#125; -&gt;      &#123;ok, &#123;IP, Port&#125;&#125; = Transport:peername(NewSocket),      io:format(<span class="hljs-string">&quot;New socket connected: Ip is :~p and port is ~p ~n&quot;</span>, [IP, Port]),      Transport:setopts(Socket, [&#123;active, once&#125;]),      InitState = #trap_connection_info&#123;transport = Transport, socket = NewSocket, ip = IP&#125;,      <span class="hljs-comment">%% 先挂起来等认证,防止恶意连接</span>      erlang:send_after(?EXPIRE_TIME, self(), wait_for_auth),      <span class="hljs-comment">%% 进入下一次循环</span>      gen_server:enter_loop(?MODULE, [], InitState);    &#123;error, Reason&#125; -&gt;      &#123;stop, Reason&#125;  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">handle_call</span><span class="hljs-params">(_Request, _From, State)</span> -&gt;</span>  &#123;reply, ok, State&#125;.<span class="hljs-comment">%% ping包</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(ping, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;pong ~p~n&quot;</span>, [Socket]),  send_to_client(Transport, Socket, &lt;&lt;<span class="hljs-string">&quot;pong&quot;</span>&gt;&gt;),  &#123;noreply, State&#125;;<span class="hljs-comment">%% protocol_error</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(protocol_error, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;protocol_error ~p~n&quot;</span>, [Socket]),  send_to_client(Transport, Socket, &lt;&lt;<span class="hljs-string">&quot;protocol_error&quot;</span>&gt;&gt;),  gen_tcp:close(Socket),  &#123;stop, normal, State&#125;;<span class="hljs-comment">%% connect</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(connect, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;connect ~p~n&quot;</span>, [Socket]),  send_to_client(Transport, Socket, &lt;&lt;<span class="hljs-string">&quot;connect_ok&quot;</span>&gt;&gt;),  &#123;noreply, State&#125;;<span class="hljs-comment">%% auth 认证客户端,改变状态即可</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(&#123;auth, &#123;Mode, PayLoad&#125;&#125;, #trap_connection_info&#123;ip = IP, socket = Socket&#125; = State)</span> -&gt;</span>  &lt;&lt;ClientIdLength:<span class="hljs-number">16</span>, ClientId:ClientIdLength/binary&gt;&gt; = PayLoad,  <span class="hljs-keyword">case</span> (ClientId) <span class="hljs-keyword">of</span>    <span class="hljs-comment">%% 测试用的，后面会加入数据库支持</span>    &lt;&lt;<span class="hljs-string">&quot;client0012&quot;</span>&gt;&gt; -&gt;      io:format(<span class="hljs-string">&quot;Auth success and clientid is:~p ~n&quot;</span>, [ClientId]),      ID = <span class="hljs-keyword">case</span> ets:last(?CLIENT_TABLE) <span class="hljs-keyword">of</span>             &#x27;$end_of_table&#x27; -&gt;               <span class="hljs-number">1</span>;             I -&gt;               I + <span class="hljs-number">1</span>           <span class="hljs-keyword">end</span>,      ets:insert(?CLIENT_TABLE, &#123;ID, #trap_client_info&#123;id = ID, client_id = ClientId, ip = IP, socket = Socket, auth = true, mode = Mode&#125;&#125;),      gen_server:cast(self(), auth_ok),      &#123;noreply, State#trap_connection_info&#123;id = ID, auth = true, client_id = ClientId, mode = Mode&#125;&#125;;    _Other -&gt;      io:format(<span class="hljs-string">&quot;Auth failure and clientid is:~p ~n&quot;</span>, [ClientId]),      gen_server:cast(self(), auth_failure),      &#123;noreply, State&#125;  <span class="hljs-keyword">end</span>;<span class="hljs-comment">%% auth_ok</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(auth_ok, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  send_to_client(Transport, Socket, &lt;&lt;<span class="hljs-string">&quot;auth_ok&quot;</span>&gt;&gt;),  &#123;noreply, State&#125;;<span class="hljs-comment">%% send</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(&#123;send, &#123;Mode, PayLoad&#125;&#125;, State)</span> -&gt;</span>  <span class="hljs-comment">%% &lt;&lt;DataLength:16, ClientIdLength:8, ClientId:ClientIdLength/binary, Data/binary&gt;&gt;</span>  &lt;&lt;DataLength:<span class="hljs-number">16</span>, ClientIdLength:<span class="hljs-number">8</span>, ClientId:ClientIdLength/binary, Data:DataLength/binary&gt;&gt; = PayLoad,  <span class="hljs-comment">%% io:format(&quot;PayLoad is ~p~n&quot;, [PayLoad]),</span>  <span class="hljs-keyword">case</span> Mode <span class="hljs-keyword">of</span>    <span class="hljs-number">1</span> -&gt; io:format(<span class="hljs-string">&quot;TCP Mode ClientId is ~p Data is ~p~n&quot;</span>, [ClientId, Data]);    _ -&gt; io:format(<span class="hljs-string">&quot;Trap Mode ClientId is ~p Data is ~p~n&quot;</span>, [ClientId, Data])  <span class="hljs-keyword">end</span>,  &#123;noreply, State&#125;;<span class="hljs-comment">%% auth_failure</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(auth_failure, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Auth failure and Socket is:~p ~n&quot;</span>, [Socket]),  send_to_client(Transport, Socket, &lt;&lt;<span class="hljs-string">&quot;auth_failure&quot;</span>&gt;&gt;),  gen_tcp:close(Socket),  &#123;stop, normal, State&#125;;<span class="hljs-comment">%% packet_arrived</span><span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(&#123;packet_arrived, _RemoteSocket, BinData&#125;, State)</span> -&gt;</span>  DataLength = byte_size(BinData),  <span class="hljs-keyword">case</span> DataLength &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">of</span>    <span class="hljs-literal">false</span> -&gt;      gen_server:cast(self(), protocol_error),      &#123;noreply, State&#125;;    <span class="hljs-literal">true</span> -&gt;      <span class="hljs-keyword">try</span>        &lt;&lt;Mode:<span class="hljs-number">2</span>, Type:<span class="hljs-number">6</span>, PayLoad/binary&gt;&gt; = BinData,        io:format(<span class="hljs-string">&quot;Raw BinData is ~p~n&quot;</span>, [BinData]),        <span class="hljs-keyword">case</span> Mode <span class="hljs-keyword">of</span>          <span class="hljs-number">1</span> -&gt;            <span class="hljs-keyword">case</span> Type <span class="hljs-keyword">of</span>              <span class="hljs-number">0</span> -&gt;                gen_server:cast(self(), ping);              <span class="hljs-number">1</span> -&gt;                gen_server:cast(self(), connect);              <span class="hljs-number">4</span> -&gt;                gen_server:cast(self(), &#123;auth, &#123;Mode, PayLoad&#125;&#125;);              <span class="hljs-number">7</span> -&gt;                gen_server:cast(self(), &#123;send, &#123;Mode, PayLoad&#125;&#125;);              O -&gt;                io:format(<span class="hljs-string">&quot;Other type: ~p ~n&quot;</span>, [O])            <span class="hljs-keyword">end</span>,            &#123;noreply, State#trap_connection_info&#123;mode = Mode&#125;&#125;;          <span class="hljs-number">0</span> -&gt;            &#123;noreply, State#trap_connection_info&#123;mode = Mode&#125;&#125;;          _ -&gt;            &#123;noreply, State&#125;        <span class="hljs-keyword">end</span>      <span class="hljs-keyword">catch</span>        _Reason:_E -&gt;          io:format(<span class="hljs-string">&quot;Error :~p Reason : ~p ~n&quot;</span>, [_E, _Reason]),          gen_server:cast(self(), protocol_error),          &#123;noreply, State&#125;      <span class="hljs-keyword">end</span>  <span class="hljs-keyword">end</span>;<span class="hljs-function"><span class="hljs-title">handle_cast</span><span class="hljs-params">(&#123;error, Socket, Message&#125;, #trap_connection_info&#123;socket = Socket, transport = Transport&#125; = State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;error ~p~n&quot;</span>, [Socket]),  Transport:send(Socket, Message),  Transport:setopts(Socket, [&#123;active, once&#125;]),  &#123;stop, normal, State&#125;.<span class="hljs-comment">%%</span><span class="hljs-comment">%% 消息接收处理</span><span class="hljs-comment">%%</span><span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(&#123;tcp, RemoteSocket, BinData&#125;, State)</span> -&gt;</span>  gen_server:cast(self(), &#123;packet_arrived, RemoteSocket, BinData&#125;),  &#123;noreply, State&#125;;<span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(&#123;tcp_error, Socket, Reason&#125;, State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;handle_info tcp_error ~p , Error from: ~p~n&quot;</span>, [Reason, Socket]),  ets:match_delete(?CLIENT_TABLE, &#123;&#x27;_&#x27;, #trap_client_info&#123;socket = Socket, _ = &#x27;_&#x27;&#125;&#125;),  &#123;stop, normal, State&#125;;<span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(&#123;tcp_closed, Socket&#125;, State)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Socket cloesd: ~p ~n&quot;</span>, [Socket]),  ets:match_delete(?CLIENT_TABLE, &#123;&#x27;_&#x27;, #trap_client_info&#123;socket = Socket, _ = &#x27;_&#x27;&#125;&#125;),  &#123;stop, normal, State&#125;;<span class="hljs-comment">%%</span><span class="hljs-comment">%% 这个是定时检查认证状态,防止恶意连接</span><span class="hljs-comment">%%</span><span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(wait_for_auth, #trap_connection_info&#123;auth = Auth&#125; = State)</span> -&gt;</span>  <span class="hljs-keyword">case</span> Auth <span class="hljs-keyword">of</span>    <span class="hljs-literal">true</span> -&gt;      &#123;noreply, State&#125;;    <span class="hljs-literal">false</span> -&gt;      gen_server:cast(self(), auth_failure),      &#123;noreply, State&#125;;    _ -&gt;      &#123;stop, normal, State&#125;  <span class="hljs-keyword">end</span>;<span class="hljs-function"><span class="hljs-title">handle_info</span><span class="hljs-params">(_, State)</span> -&gt;</span>  &#123;noreply, State&#125;.<span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _State)</span> -&gt;</span>  ok.<span class="hljs-function"><span class="hljs-title">code_change</span><span class="hljs-params">(_OldVsn, State, _Extra)</span> -&gt;</span>  &#123;ok, State&#125;.<span class="hljs-comment">%% send to client</span><span class="hljs-function"><span class="hljs-title">send_to_client</span><span class="hljs-params">(Transport, Socket, Data)</span> -&gt;</span>  Transport:send(Socket, Data),  Transport:setopts(Socket, [&#123;active, once&#125;]).</code></pre><p>下面是监督者:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(trap_tcp_server_sup)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(supervisor)</span>.<span class="hljs-comment">%% API</span><span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([init/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-define</span><span class="hljs-params">(SERVER, ?MODULE)</span>.<span class="hljs-comment">%% 服务端启动</span><span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Port)</span> -&gt;</span>  supervisor:start_link(&#123;local, ?SERVER&#125;, ?MODULE, [Port]).<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">([Port])</span> -&gt;</span>  RestartStrategy = one_for_one,  MaxRestarts = <span class="hljs-number">1000</span>,  MaxSecondsBetweenRestarts = <span class="hljs-number">3600</span>,  SupFlags = &#123;RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts&#125;,  Restart = permanent,  Shutdown = <span class="hljs-number">2000</span>,  Type = worker,  AChild = &#123;trap_tcp_server, &#123;trap_tcp_server, start, [Port]&#125;,    Restart, Shutdown, Type, [trap_tcp_server]&#125;,  &#123;ok, &#123;SupFlags, [AChild]&#125;&#125;.</code></pre><p>启动app运行:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(trap_app)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(application)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">2</span>, stop/<span class="hljs-number">1</span>])</span>.<span class="hljs-keyword">-define</span><span class="hljs-params">(TCP_PORT, <span class="hljs-number">5000</span>)</span>.<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_StartType, _StartArgs)</span> -&gt;</span>  io:format(<span class="hljs-string">&quot;Trap Tcp Server Started at Port:~p~n&quot;</span>, [?TCP_PORT]),  trap_tcp_server_sup:start_link(?TCP_PORT).<span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">(_State)</span> -&gt;</span>  ok.</code></pre><p>我们把服务端运行在5000端口.</p><h2 id="6-客户端实现"><a href="#6-客户端实现" class="headerlink" title="6.客户端实现"></a>6.客户端实现</h2><p>下面的代码就是连接和登陆,send协议的实现,协议实现请看之前的&lt;&lt;TCP协议设计&gt;&gt;这篇文.</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(trap_client)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">1</span>, start/<span class="hljs-number">0</span>])</span>.<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(Port)</span> -&gt;</span>  <span class="hljs-keyword">case</span> gen_tcp:connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, Port, [binary, &#123;packet, <span class="hljs-number">0</span>&#125;, &#123;active, false&#125;, &#123;reuseaddr, true&#125;]) <span class="hljs-keyword">of</span>    &#123;ok, ServerSocket&#125; -&gt;      logger:info(<span class="hljs-string">&quot;Request login&quot;</span>),      auth(ServerSocket, &lt;&lt;<span class="hljs-string">&quot;client0012&quot;</span>&gt;&gt;),      ControlPid = spawn(<span class="hljs-keyword">fun</span>() -&gt; loop(ServerSocket) <span class="hljs-keyword">end</span>),      gen_tcp:controlling_process(ServerSocket, ControlPid),      ControlPid;    &#123;error, Why&#125; -&gt;      logger:error(<span class="hljs-string">&quot;Error ~p&quot;</span>, [Why])  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span>  start(<span class="hljs-number">5000</span>).<span class="hljs-function"><span class="hljs-title">loop</span><span class="hljs-params">(Socket)</span> -&gt;</span>  <span class="hljs-keyword">case</span> gen_tcp:recv(Socket, <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>    &#123;ok, Data&#125; -&gt;      <span class="hljs-keyword">case</span> Data <span class="hljs-keyword">of</span>        &lt;&lt;<span class="hljs-string">&quot;auth_ok&quot;</span>&gt;&gt; -&gt;          logger:info(<span class="hljs-string">&quot;Auth Ok.&quot;</span>),          send_packet(Socket, &lt;&lt;<span class="hljs-string">&quot;client0012&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;HeloWoodGoodJobAhahahahaha&quot;</span>&gt;&gt;);        &lt;&lt;<span class="hljs-string">&quot;auth_failure&quot;</span>&gt;&gt; -&gt;          logger:info(<span class="hljs-string">&quot;Auth Failure.&quot;</span>);        &lt;&lt;<span class="hljs-string">&quot;send_ok&quot;</span>&gt;&gt; -&gt;          logger:info(<span class="hljs-string">&quot;Receive data ~p&quot;</span>, [Data])      <span class="hljs-keyword">end</span>,      loop(Socket);    &#123;error, closed&#125; -&gt;      logger:error(<span class="hljs-string">&quot;Socket [~p] close&quot;</span>, [Socket])  <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% auth</span><span class="hljs-function"><span class="hljs-title">auth</span><span class="hljs-params">(Socket, ClientId)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_binary</span><span class="hljs-params">(ClientId)</span> -&gt;</span>  <span class="hljs-comment">%% Tcp</span>  Mode = <span class="hljs-number">1</span>,  <span class="hljs-comment">%% Auth</span>  Type = <span class="hljs-number">4</span>,  <span class="hljs-comment">%% Length</span>  DataLength = byte_size(ClientId),  gen_tcp:send(Socket, &lt;&lt;Mode:<span class="hljs-number">2</span>, Type:<span class="hljs-number">6</span>, DataLength:<span class="hljs-number">16</span>, ClientId/binary&gt;&gt;).<span class="hljs-comment">%% send</span><span class="hljs-function"><span class="hljs-title">send_packet</span><span class="hljs-params">(Socket, ClientId, Data)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_binary</span><span class="hljs-params">(Data)</span> -&gt;</span>  <span class="hljs-comment">%% Tcp</span>  Mode = <span class="hljs-number">1</span>,  <span class="hljs-comment">%% Auth</span>  Type = <span class="hljs-number">7</span>,  <span class="hljs-comment">%% Length</span>  ClientIdLength = byte_size(ClientId),  DataLength = byte_size(Data),  gen_tcp:send(Socket, &lt;&lt;Mode:<span class="hljs-number">2</span>, Type:<span class="hljs-number">6</span>, DataLength:<span class="hljs-number">16</span>, ClientIdLength:<span class="hljs-number">8</span>, ClientId:ClientIdLength/binary, Data:DataLength/binary&gt;&gt;).</code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>本文主要讲了esockd框架的基础知识和一个最简单协议服务端实现实战.</p>]]></content>
    
    
    <categories>
      
      <category>Erlang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>emqx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用数据库配置常量标记之一种简单的查字典方式</title>
    <link href="/2019/12/30/clpqt1iuz004n4cue3dbhbcep.html"/>
    <url>/2019/12/30/clpqt1iuz004n4cue3dbhbcep.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲如何通过Mysql实现配置常量查字典</p><span id="more"></span><h2 id="1-背景简介"><a href="#1-背景简介" class="headerlink" title="1.背景简介"></a>1.背景简介</h2><p>我们在开发过程中,经常会遇到一些枚举常量,例如性别有男女,公司成员有员工和老板等等.诸如此类的场景下,常量就需要统一配置管理了,在WEB系统设计中,一般作为字典形式来使用.说白了就是根据某个key来查value,从而实现枚举效果.</p><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h2><p>接下来我们就设计一个最简单的字典.字典分为项和值,我们分别建表如下:</p><ol><li><p>字典项表</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `ez_dictionary_key` (  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;PK&#x27;</span>,  `table_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;表名&#x27;</span>,  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;名称&#x27;</span>,  `label` <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;显示的文本&#x27;</span>,  `record_version` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;记录版本&#x27;</span>,  `x` tinyint(<span class="hljs-number">1</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;删除&#x27;</span>,  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;字典的项&#x27;</span>;</code></pre></li><li><p>字典值表</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `ez_dictionary_value` (  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;PK&#x27;</span>,  `key_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,  `<span class="hljs-keyword">value</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;名称&#x27;</span>,  `label` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;显示的文本&#x27;</span>,  `record_version` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;记录版本&#x27;</span>,  `x` tinyint(<span class="hljs-number">1</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,  `create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;字典的值&#x27;</span>;</code></pre></li><li><p>插入记录</p><ol><li><p>插入一条字典项</p><p><img src="/uploads/image-20191230143909122.png" alt="image-20191230143909122"></p></li><li><p>插入两条字典值.</p><p><img src="/uploads/image-20191230143929809.png" alt="image-20191230143929809"></p></li></ol></li></ol><h2 id="3-应用案例"><a href="#3-应用案例" class="headerlink" title="3.应用案例"></a>3.应用案例</h2><p>我们如何去用字典查询?接下来用一个小案例来阐述.假设我们的用户帐户有状态如下:</p><pre><code class="hljs sql">....省略....`status` <span class="hljs-type">int</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;账户状态：正常【1】，冻结【2】，过期【3】&#x27;</span>....省略....</code></pre><p>当用户的status字段值不同时,对应不同的文本显示,我们写如下SQL:</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>A.<span class="hljs-operator">*</span>, D.label <span class="hljs-keyword">AS</span> `account_status`<span class="hljs-keyword">FROM</span>ez_user <span class="hljs-keyword">AS</span> A<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span>B.label,B.`<span class="hljs-keyword">value</span>`<span class="hljs-keyword">FROM</span>ez_dictionary_value B<span class="hljs-keyword">WHERE</span>B.key_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span>C.id<span class="hljs-keyword">FROM</span>ez_dictionary_key C<span class="hljs-keyword">WHERE</span>C.table_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ez_user&#x27;</span><span class="hljs-keyword">AND</span> C.`name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;status&#x27;</span>)) <span class="hljs-keyword">AS</span> D <span class="hljs-keyword">ON</span> (A.`status` <span class="hljs-operator">=</span> D.`<span class="hljs-keyword">value</span>`)</code></pre><p>通过匹配,一次性即可显示出所有用户的帐户状态码和文本含义.如果需要查询ID为1的用户的状态,只需要修改上述SQL为下面的即可:</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>A.id, D.label <span class="hljs-keyword">AS</span> `account_status`<span class="hljs-keyword">FROM</span>ez_user <span class="hljs-keyword">AS</span> A<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span>B.label,B.`<span class="hljs-keyword">value</span>`<span class="hljs-keyword">FROM</span>ez_dictionary_value B<span class="hljs-keyword">WHERE</span>B.key_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span>C.id<span class="hljs-keyword">FROM</span>ez_dictionary_key C<span class="hljs-keyword">WHERE</span>C.table_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ez_user&#x27;</span><span class="hljs-keyword">AND</span> C.`name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;status&#x27;</span>)) <span class="hljs-keyword">AS</span> D <span class="hljs-keyword">ON</span> (A.`status` <span class="hljs-operator">=</span> D.`<span class="hljs-keyword">value</span>`)<span class="hljs-keyword">WHERE</span>A.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre><p>查询结果如下:</p><p><img src="/uploads/image-20191230143238325.png" alt="image-20191230143238325"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4,总结"></a>4,总结</h2><p>本文我们学习了一种简单的通过数据库配置常量来实现类似查询字典的形式.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Emqx插件开发实战</title>
    <link href="/2019/12/25/clpqt1iu0001h4cue3tbtanh9.html"/>
    <url>/2019/12/25/clpqt1iu0001h4cue3tbtanh9.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲如何开发一个完整的数据转发插件,通过该插件可以把EMQX产生的数据发送到任一接口.</p><span id="more"></span><h2 id="1-本文概述"><a href="#1-本文概述" class="headerlink" title="1.本文概述"></a>1.本文概述</h2><p>EMQX的官方插件满足不了的时候,我们可以自定义开发插件.本文就以一个简单的插件入手,演示如何为EMQX开发可使用的插件.</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h2><ol><li>Erlang环境;</li><li>一个编辑器,建议VScode;</li><li>git;</li><li>rebar3;</li><li>rebar3的EMQX插件模板.</li></ol><p>上面的环境确保安装成功以后再进行下一步,如果没有安装请查阅之前的文章进行安装.</p><h2 id="3-开发实战"><a href="#3-开发实战" class="headerlink" title="3.开发实战"></a>3.开发实战</h2><p>本插件是一个把EMQX的消息发布到WEB端的简单模块,接下来我们按照软件开发流程来走一遍.其中我们的插件名字叫:advisory_plugin.</p><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><ol><li><p>切换到自己的工作目录</p></li><li><p>执行命令:</p><pre><code class="hljs shell">rebar3 new emqx-plugin advisory_plugin</code></pre></li><li><p>输出成功以后,会生成如下目录结构:</p></li></ol><p><img src="/uploads/image-20191225091715849.png" alt="image-20191225091715849"></p><p>其中我们的源码在src下.</p><h3 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2.实现接口"></a>2.实现接口</h3><p>此处我们拿当客户端连接成功这个事件来作为案例:当设备连接成功以后,给WEB端 一个上线通知,写入一些记录.</p><p>解析来找到上线的响应函数:<code>on_client_connected</code></p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">on_client_connected</span><span class="hljs-params">(ClientInfo = #&#123;clientid := ClientId, username := Username, peerhost :=Host&#125;, <span class="hljs-number">0</span>, _ConnInfo, _Env)</span> -&gt;</span>  emqx_metrics:inc(&#x27;advisory_plugin.client_connected&#x27;),  Params = [    &#123;action, connected&#125;,    &#123;clientid, ClientId&#125;,    &#123;username, Username&#125;,    &#123;ip, iolist_to_binary(ntoa(Host))&#125;  ],  ?LOG(debug, <span class="hljs-string">&quot;on_client_connected ~p~n&quot;</span>, [ClientInfo]),  send_http_post(<span class="hljs-string">&quot;connected&quot;</span>, Params),  ok;<span class="hljs-function"><span class="hljs-title">on_client_connected</span><span class="hljs-params">(#&#123;&#125;, _ConnAck, _ConnInfo, _Env)</span> -&gt;</span>  ok.</code></pre><p>其中<code>send_http_post</code>函数便是推送函数,具体代码如下:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">send_http_post</span><span class="hljs-params">(Api, Params)</span> -&gt;</span>  Json = jsx:encode(Params),  Url = application:get_env(?APP, destination, <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>),  <span class="hljs-keyword">case</span> request(post, &#123;string:concat(Url, Api), [], <span class="hljs-string">&quot;application/json&quot;</span>, Json&#125;, [&#123;timeout, <span class="hljs-number">5000</span>&#125;], [], <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>    &#123;ok, _&#125; -&gt;      ?LOG(debug, <span class="hljs-string">&quot;Post to:[~p], Params:~s success~n&quot;</span>, [Url, Json]),      ok;    &#123;error, Reason&#125; -&gt;      ?LOG(error, <span class="hljs-string">&quot;HTTP request error: ~p&quot;</span>, [Reason]),      error  <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">request</span><span class="hljs-params">(Method, Req, HTTPOpts, Opts, Times)</span> -&gt;</span>  <span class="hljs-comment">%% Resend request, when TCP closed by remotely</span>  <span class="hljs-keyword">case</span> httpc:request(Method, Req, HTTPOpts, Opts) <span class="hljs-keyword">of</span>    &#123;error, socket_closed_remotely&#125; <span class="hljs-keyword">when</span> Times &lt; <span class="hljs-number">3</span> -&gt;      timer:sleep(trunc(math:pow(<span class="hljs-number">10</span>, Times))),      request(Method, Req, HTTPOpts, Opts, Times + <span class="hljs-number">1</span>);    Other -&gt; Other  <span class="hljs-keyword">end</span>.</code></pre><p>其中我们用到了jsx库,这是一个erlang的JSON解析器实现.</p><pre><code class="hljs ini"><span class="hljs-attr">Url</span> = application:get_env(?APP, destination, <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>)</code></pre><p>上述代码先从配置文件中获取推送的目标,如果不存在就是<code>http://127.0.0.1</code>,然后把数据post上去.代码看起来比较简单,接下来我们增加配置项.</p><p>找到<code>priv</code>目录下的schema文件,最后加入以下代码:</p><pre><code class="hljs elm">&#123;mapping, <span class="hljs-string">&quot;advisory_plugin.destination&quot;</span>, <span class="hljs-string">&quot;advisory_plugin.destination&quot;</span>, [  &#123;data<span class="hljs-keyword">type</span>, string&#125;]&#125;.</code></pre><p>这里表示的是从配置文件中映射配置项,下面是配置文件<code>etc</code>目录下的conf文件:</p><pre><code class="hljs awk">advisory_plugin.destination = http:<span class="hljs-regexp">//</span>localhost:端口<span class="hljs-regexp">/data/</span></code></pre><p>到这步,我们的插件就开发完成了,然后来实现WEB端的接口.</p><h3 id="3-WEB推送接口实现"><a href="#3-WEB推送接口实现" class="headerlink" title="3.WEB推送接口实现"></a>3.WEB推送接口实现</h3><p>我拿SpringMVC为例:</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/connected&quot;)</span><span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> ConnectedMessage message)</span> <span class="hljs-keyword">throws</span> XException </span>&#123;System.out.println(<span class="hljs-string">&quot;设备 Clientid is:&quot;</span> + message.getClientid() + <span class="hljs-string">&quot; Username is:&quot;</span> + message.getUsername() + <span class="hljs-string">&quot; 上线&quot;</span>);&#125;</code></pre><p>此时我们就能监听客户端的数据了.</p><h3 id="4-插件安装"><a href="#4-插件安装" class="headerlink" title="4.插件安装"></a>4.插件安装</h3><p>在这里我使用了编译的形式安装插件.首先我们打开emqx-rel项目,没有的话可以先git克隆下来:</p><pre><code class="hljs shell">git clone https://github.com/emqx/emqx-rel.git</code></pre><p>找到rebar.config文件,加入插件,在deps节点下加入(这里我用了自己的仓库):</p><pre><code class="hljs erlang">&#123; advisory_plugin, &#123; git , <span class="hljs-string">&quot;https://gitee.com/lagrangewang/advisory_plugin.git&quot;</span> , &#123;branch, <span class="hljs-string">&quot;master&quot;</span>&#125; &#125; &#125;</code></pre><p>然后配置插件加载,在relx节点下加入:</p><pre><code class="hljs erlang">&#123;advisory_plugin,load&#125;</code></pre><p>然后执行make.经过漫长的等待以后,不出问题,我们的项目可以编译成功,执行下面的命令:</p><pre><code class="hljs shell">cd _build/emqx/rel/emqx &amp;&amp; ./bin/emqx console</code></pre><p>会有如下输出:</p><p><img src="/uploads/image-20191225093324490.png" alt="image-20191225093324490"></p><p>此时表示已经成功运行起了EMQX,我们看看插件情况,打开<code>http://localhost:18083/</code>,我们看到插件已经加载到了EMQX里面.</p><p><img src="/uploads/image-20191225093425903.png" alt="image-20191225093425903"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>本文我们主要讲了EMQX插件的开发流程和一个简单的Demo.WEB接口可自定义去实现功能.</p>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX二次开发之自定义Listener</title>
    <link href="/2019/12/01/clpqt1itz001d4cueapus7yc9.html"/>
    <url>/2019/12/01/clpqt1itz001d4cueapus7yc9.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲解如何在EMQX中添加自定义Listener</p><span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><img src="/uploads/image-20191201190852642.png" alt="image-20191201190852642"></p><p>​        EMQX目前支持的Listener(监听器)如上图所示:</p><ul><li>MQTT监听器</li><li>SSL监听器</li><li>WebSocket监听器</li><li>Http监听器</li><li>WSS监听器</li></ul><p>​        这些监听器构成了EMQX的协议核心入口,客户端首先链接监听器,然后把数据传输给EMQX内核,进行转发或者处理.简而言之,监听器就是监控某个端口的一个进程,用来提供某种数据服务.</p><p>​        了解了上面的基础以后,我们会有这样的疑问:目前看起来仅仅支持MQTT协议和HTTP协议,如果我自己有个新的协议接入,是不是就不行了?答案是:没错,EMQX并没有支持更多的协议,所以我们的自定义协议不可能接入进来,但是难道没有办法吗?EMQX的官方文档里面也没有提这个,于是我自己稍微研究了一下,总结出来一个办法:我们的自定义协议完全可以融入进EMQX内核,只不过需要自定义二次开发.说到这里其实就有门槛了,首先你得熟悉点Erlang语言,然后就是熟悉一下EMQX的源码.</p><p>​         好了,我们直接开始讲如何开发自定义监听器,或者说是如何把自定义协议接入进EMQX,让EMQX成为我们的一个私有化协议服务器.</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h2><p>​        下面的工作都基于你已经准备好Erlang/OTP环境,注意一下:必须是22以上的版本 .</p><ol><li><p>克隆EMQX源码</p><pre><code class="hljs shell">git clone https://github.com/wwhai/emqx.git</code></pre></li><li><p>克隆emqx-rel源码</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/wwhai/</span>emqx-rel.git</code></pre></li></ol><h2 id="3-代码结构"><a href="#3-代码结构" class="headerlink" title="3.代码结构"></a>3.代码结构</h2><ol><li>emqx的代码结构如图所示:</li></ol><p><img src="/uploads/image-20191201191908028.png" alt="image-20191201191908028"></p><ol start="2"><li><p>emqx-rel的代码架构如下:</p><p><img src="/uploads/image-20191201192054291.png" alt="image-20191201192054291"></p></li></ol><p>​        熟悉Erlang开发的人是不是看起来很眼熟?没错,其实就是一个标准的rebar项目,细节我就不说了,首先我们来看下EMQX项目,emqx-rel项目最后会分析.</p><h2 id="4-EMQX源码简单解析"><a href="#4-EMQX源码简单解析" class="headerlink" title="4.EMQX源码简单解析"></a>4.EMQX源码简单解析</h2><p>​        我们切换到emqx项目下的src目录,文件结构如下:</p><p><img src="/uploads/image-20191201192303160.png" alt="image-20191201192303160"></p><p>​        其他的文件我暂时没有去研究,我们找到我们的目标:listener,进来看下源码内容:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(emqx_listeners)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;emqx_mqtt.hrl&quot;</span>)</span>.<span class="hljs-comment">%% APIs</span><span class="hljs-keyword">-export</span><span class="hljs-params">([start/<span class="hljs-number">0</span></span><span class="hljs-params">    , restart/<span class="hljs-number">0</span></span><span class="hljs-params">    , stop/<span class="hljs-number">0</span></span><span class="hljs-params">])</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start_listener/<span class="hljs-number">1</span></span><span class="hljs-params">    , start_listener/<span class="hljs-number">3</span></span><span class="hljs-params">    , stop_listener/<span class="hljs-number">1</span></span><span class="hljs-params">    , stop_listener/<span class="hljs-number">3</span></span><span class="hljs-params">    , restart_listener/<span class="hljs-number">1</span></span><span class="hljs-params">    , restart_listener/<span class="hljs-number">3</span></span><span class="hljs-params">])</span>.-type<span class="hljs-params">(listener() :: &#123;esockd:proto(), esockd:listen_on(), [esockd:option()]&#125;)</span>.<span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-comment">%% APIs</span><span class="hljs-comment">%%--------------------------------------------------------------------</span><span class="hljs-comment">%% @doc Start all listeners.</span><span class="hljs-keyword">-spec</span><span class="hljs-params">(start() -&gt; ok)</span>.<span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span>    Config = emqx:get_env(listeners, []),    lists:foreach(fun start_listener/1, Config).<span class="hljs-keyword">-spec</span><span class="hljs-params">(start_listener(listener()) -&gt; &#123;ok, pid()&#125; | &#123;error, term()&#125;)</span>.<span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(&#123;Proto, ListenOn, Options&#125;)</span> -&gt;</span>    io:format(<span class="hljs-string">&quot;Proto:~p, ListenOn:~p, Options:~p&quot;</span>, [Proto, ListenOn, Options]),    StartRet = start_listener(Proto, ListenOn, Options),    <span class="hljs-keyword">case</span> StartRet <span class="hljs-keyword">of</span>        &#123;ok, _&#125; -&gt; io:format(<span class="hljs-string">&quot;Start ~s listener on ~s successfully.~n&quot;</span>,            [Proto, format(ListenOn)]);        &#123;error, Reason&#125; -&gt;            io:format(standard_error, <span class="hljs-string">&quot;Failed to start ~s listener on ~s - ~p~n!&quot;</span>,                [Proto, format(ListenOn), Reason])    <span class="hljs-keyword">end</span>,    StartRet.<span class="hljs-comment">%% Start MQTT/TCP listener</span><span class="hljs-keyword">-spec</span><span class="hljs-params">(start_listener(esockd:proto(), esockd:listen_on(), [esockd:option()])</span><span class="hljs-params">        -&gt; &#123;ok, pid()&#125; | &#123;error, term()&#125;)</span>.<span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(tcp, ListenOn, Options)</span> -&gt;</span>    start_mqtt_listener(&#x27;mqtt:tcp&#x27;, ListenOn, Options);<span class="hljs-comment">%% Trap</span><span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(tcp, ListenOn, Options)</span> -&gt;</span>    start_trap_listener(&#x27;trap:tcp&#x27;, ListenOn, Options);<span class="hljs-comment">%% Start MQTT/TLS listener</span><span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(Proto, ListenOn, Options)</span> <span class="hljs-title">when</span> P<span class="hljs-title">roto</span> == <span class="hljs-title">ssl</span>; P<span class="hljs-title">roto</span> == <span class="hljs-title">tls</span> -&gt;</span>    start_mqtt_listener(&#x27;mqtt:ssl&#x27;, ListenOn, Options);<span class="hljs-comment">%% Start MQTT/WS listener</span><span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(Proto, ListenOn, Options)</span> <span class="hljs-title">when</span> P<span class="hljs-title">roto</span> == <span class="hljs-title">http</span>; P<span class="hljs-title">roto</span> == <span class="hljs-title">ws</span> -&gt;</span>    start_http_listener(<span class="hljs-keyword">fun</span> cowboy:start_clear/<span class="hljs-number">3</span>, &#x27;mqtt:ws&#x27;, ListenOn,        ranch_opts(Options), ws_opts(Options));<span class="hljs-comment">%% Start MQTT/WSS listener</span>start_listener(Proto, ListenOn, Options) <span class="hljs-keyword">when</span> Proto == https; Proto == wss -&gt;    start_http_listener(<span class="hljs-keyword">fun</span> cowboy:start_tls/<span class="hljs-number">3</span>, &#x27;mqtt:wss&#x27;, ListenOn,        ranch_opts(Options), ws_opts(Options)).start_mqtt_listener(Name, ListenOn, Options) -&gt;    SockOpts = esockd:parse_opt(Options),    esockd:open(Name, ListenOn, merge_default(SockOpts),        &#123;emqx_connection, start_link, [Options -- SockOpts]&#125;).<span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><span class="hljs-comment">%% 2019-11-29</span><span class="hljs-comment">%% Trap listener</span><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>start_trap_listener(Name, ListenOn, Options) -&gt;    io:format(<span class="hljs-string">&quot;start_trap_listener: Name :~p ListenOn:~p Options:~p &quot;</span>, [Name, ListenOn, Options]),    SockOpts = esockd:parse_opt(Options),    esockd:open(&#x27;trap:tcp&#x27;, ListenOn, merge_default(SockOpts),        &#123;emqx_trap_connection, start_link, [Options -- SockOpts]&#125;).start_http_listener(Start, Name, ListenOn, RanchOpts, ProtoOpts) -&gt;    Start(Name, with_port(ListenOn, RanchOpts), ProtoOpts).<span class="hljs-comment">%% For websocket mqtt path</span>mqtt_path(Options) -&gt;    proplists:get_value(mqtt_path, Options, <span class="hljs-string">&quot;/mqtt&quot;</span>).ws_opts(Options) -&gt;    WsPaths = [&#123;mqtt_path(Options), emqx_ws_connection, Options&#125;],    Dispatch = cowboy_router:compile([&#123;&#x27;_&#x27;, WsPaths&#125;]),    ProxyProto = proplists:get_value(proxy_protocol, Options, false),    #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;, proxy_header =&gt; ProxyProto&#125;.ranch_opts(Options) -&gt;    NumAcceptors = proplists:get_value(acceptors, Options, <span class="hljs-number">4</span>),    MaxConnections = proplists:get_value(max_connections, Options, <span class="hljs-number">1024</span>),    TcpOptions = proplists:get_value(tcp_options, Options, []),    RanchOpts = #&#123;num_acceptors =&gt; NumAcceptors,        max_connections =&gt; MaxConnections,        socket_opts =&gt; TcpOptions&#125;,    <span class="hljs-keyword">case</span> proplists:get_value(ssl_options, Options) <span class="hljs-keyword">of</span>        undefined -&gt; RanchOpts;        SslOptions -&gt; RanchOpts#&#123;socket_opts =&gt; TcpOptions ++ SslOptions&#125;    <span class="hljs-keyword">end</span>.with_port(Port, Opts = #&#123;socket_opts := SocketOption&#125;) <span class="hljs-keyword">when</span> is_integer(Port) -&gt;    Opts#&#123;socket_opts =&gt; [&#123;port, Port&#125; | SocketOption]&#125;;with_port(&#123;Addr, Port&#125;, Opts = #&#123;socket_opts := SocketOption&#125;) -&gt;    Opts#&#123;socket_opts =&gt; [&#123;ip, Addr&#125;, &#123;port, Port&#125; | SocketOption]&#125;.<span class="hljs-comment">%% @doc Restart all listeners</span>-spec(restart() -&gt; ok).restart() -&gt;    lists:foreach(fun restart_listener/1, emqx:get_env(listeners, [])).-spec(restart_listener(listener()) -&gt; any()).restart_listener(&#123;Proto, ListenOn, Options&#125;) -&gt;    restart_listener(Proto, ListenOn, Options).-spec(restart_listener(esockd:proto(), esockd:listen_on(), [esockd:option()]) -&gt; any()).restart_listener(tcp, ListenOn, _Options) -&gt;    esockd:reopen(&#x27;mqtt:tcp&#x27;, ListenOn);restart_listener(Proto, ListenOn, _Options) <span class="hljs-keyword">when</span> Proto == ssl; Proto == tls -&gt;    esockd:reopen(&#x27;mqtt:ssl&#x27;, ListenOn);restart_listener(Proto, ListenOn, Options) <span class="hljs-keyword">when</span> Proto == http; Proto == ws -&gt;    cowboy:stop_listener(&#x27;mqtt:ws&#x27;),    start_listener(Proto, ListenOn, Options);restart_listener(Proto, ListenOn, Options) <span class="hljs-keyword">when</span> Proto == https; Proto == wss -&gt;    cowboy:stop_listener(&#x27;mqtt:wss&#x27;),    start_listener(Proto, ListenOn, Options);restart_listener(Proto, ListenOn, _Opts) -&gt;    esockd:reopen(Proto, ListenOn).<span class="hljs-comment">%% @doc Stop all listeners.</span>-spec(stop() -&gt; ok).stop() -&gt;    lists:foreach(fun stop_listener/1, emqx:get_env(listeners, [])).-spec(stop_listener(listener()) -&gt; ok | &#123;error, term()&#125;).stop_listener(&#123;Proto, ListenOn, Opts&#125;) -&gt;    StopRet = stop_listener(Proto, ListenOn, Opts),    <span class="hljs-keyword">case</span> StopRet <span class="hljs-keyword">of</span>        ok -&gt; io:format(<span class="hljs-string">&quot;Stop mqtt:~s listener on ~s successfully.~n&quot;</span>,            [Proto, format(ListenOn)]);        &#123;error, Reason&#125; -&gt;            io:format(standard_error, <span class="hljs-string">&quot;Failed to stop mqtt:~s listener on ~s - ~p~n.&quot;</span>,                [Proto, format(ListenOn), Reason])    <span class="hljs-keyword">end</span>,    StopRet.-spec(stop_listener(esockd:proto(), esockd:listen_on(), [esockd:option()])        -&gt; ok | &#123;error, term()&#125;).stop_listener(tcp, ListenOn, _Opts) -&gt;    esockd:close(&#x27;mqtt:tcp&#x27;, ListenOn);stop_listener(Proto, ListenOn, _Opts) <span class="hljs-keyword">when</span> Proto == ssl; Proto == tls -&gt;    esockd:close(&#x27;mqtt:ssl&#x27;, ListenOn);stop_listener(Proto, _ListenOn, _Opts) <span class="hljs-keyword">when</span> Proto == http; Proto == ws -&gt;    cowboy:stop_listener(&#x27;mqtt:ws&#x27;);stop_listener(Proto, _ListenOn, _Opts) <span class="hljs-keyword">when</span> Proto == https; Proto == wss -&gt;    cowboy:stop_listener(&#x27;mqtt:wss&#x27;);stop_listener(Proto, ListenOn, _Opts) -&gt;    esockd:close(Proto, ListenOn).merge_default(Options) -&gt;    <span class="hljs-keyword">case</span> lists:keytake(tcp_options, <span class="hljs-number">1</span>, Options) <span class="hljs-keyword">of</span>        &#123;value, &#123;tcp_options, TcpOpts&#125;, Options1&#125; -&gt;            [&#123;tcp_options, emqx_misc:merge_opts(?MQTT_SOCKOPTS, TcpOpts)&#125; | Options1];        <span class="hljs-literal">false</span> -&gt;            [&#123;tcp_options, ?MQTT_SOCKOPTS&#125; | Options]    <span class="hljs-keyword">end</span>.format(Port) <span class="hljs-keyword">when</span> is_integer(Port) -&gt;    io_lib:format(<span class="hljs-string">&quot;0.0.0.0:~w&quot;</span>, [Port]);format(&#123;Addr, Port&#125;) <span class="hljs-keyword">when</span> is_list(Addr) -&gt;    io_lib:format(<span class="hljs-string">&quot;~s:~w&quot;</span>, [Addr, Port]);format(&#123;Addr, Port&#125;) <span class="hljs-keyword">when</span> is_tuple(Addr) -&gt;    io_lib:format(<span class="hljs-string">&quot;~s:~w&quot;</span>, [inet:ntoa(Addr), Port]).</code></pre><p>​        我们来分析一下代码:首先start函数是入口,启动以后,通过get_env函数来拿到配置参数文件,分别启动不同协议支持的listener.</p><pre><code class="hljs erlang"><span class="hljs-comment">%% 模块入口函数</span><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> -&gt;</span>    Config = emqx:get_env(listeners, []),    lists:foreach(fun start_listener/1, Config).</code></pre><p>​        其中我们重点来看下<code>stasrt_listener/1</code>函数:</p><pre><code class="hljs erlang"><span class="hljs-comment">%% 启动监听器</span><span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(&#123;Proto, ListenOn, Options&#125;)</span> -&gt;</span>    StartRet = start_listener(Proto, ListenOn, Options),    <span class="hljs-keyword">case</span> StartRet <span class="hljs-keyword">of</span>        &#123;ok, _&#125; -&gt; io:format(<span class="hljs-string">&quot;Start ~s listener on ~s successfully.~n&quot;</span>,            [Proto, format(ListenOn)]);        &#123;error, Reason&#125; -&gt;            io:format(standard_error, <span class="hljs-string">&quot;Failed to start ~s listener on ~s - ~p~n!&quot;</span>,                [Proto, format(ListenOn), Reason])    <span class="hljs-keyword">end</span>,    StartRet.</code></pre><p>其中<code>emqx:get_env(listeners, [])</code>这里取到了配置参数,然后封装成<code>&#123;Proto, ListenOn, Options&#125;</code>,第一个是协议的名字,第二个是监听的端口和IP,第三个是esockd(EMQX内部使用的一个异步连接库,大家可以去github上看相关资料)连接参数.</p><p>下面的代码是启动系统自己的mqtt监听器:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start_mqtt_listener</span><span class="hljs-params">(Name, ListenOn, Options)</span> -&gt;</span>    SockOpts = esockd:parse_opt(Options),    esockd:open(Name, ListenOn, merge_default(SockOpts),        &#123;emqx_connection, start_link, [Options -- SockOpts]&#125;).</code></pre><p>其实到这里我们已经熟悉了EMQX的监听器启动过程:</p><ol><li>通过get_env拿到参数;</li><li>调用stasrt_listener函数启动.</li></ol><p>到这里是不是我们就可以照葫芦画瓢来自己实现个监听器加进去?答案是Yes,完全可以,下面这段代码就是我自己的监听器:</p><pre><code class="hljs erlang"><span class="hljs-comment">%% Trap</span>    <span class="hljs-comment">%% ........省略其他部分.....</span><span class="hljs-function"><span class="hljs-title">start_listener</span><span class="hljs-params">(trap, ListenOn, Options)</span> -&gt;</span>    start_trap_listener(&#x27;trap:tcp&#x27;, ListenOn, Options);    <span class="hljs-comment">%% ........省略其他部分.....</span><span class="hljs-function"><span class="hljs-title">start_trap_listener</span><span class="hljs-params">(Name, ListenOn, Options)</span> -&gt;</span>    io:format(<span class="hljs-string">&quot;start_trap_listener: Name :~p ListenOn:~p Options:~p &quot;</span>, [Name, ListenOn, Options]),    SockOpts = esockd:parse_opt(Options),    esockd:open(&#x27;trap:tcp&#x27;, ListenOn, merge_default(SockOpts),        &#123;emqx_trap_connection, start_link, [Options -- SockOpts]&#125;).    <span class="hljs-comment">%% ........省略其他部分.....</span></code></pre><p>​        其中trap是我自定义的协议名字,通过esockd:open函数启动.<code>emqx_trap_connection</code>是我们自定义协议的处理模块,其实就是个很普通的Erlang 模块:</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(emqx_trap_connection)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;emqx.hrl&quot;</span>)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;emqx_mqtt.hrl&quot;</span>)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;logger.hrl&quot;</span>)</span>.<span class="hljs-keyword">-include</span><span class="hljs-params">(<span class="hljs-string">&quot;types.hrl&quot;</span>)</span>.-logger_header<span class="hljs-params">(<span class="hljs-string">&quot;[TRAP]&quot;</span>)</span>.<span class="hljs-keyword">-export</span><span class="hljs-params">([start_link/<span class="hljs-number">2</span>, init/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">start_link</span><span class="hljs-params">(Transport, ListenSocket)</span> -&gt;</span>    &#123;ok, spawn_link(?MODULE, init, [Transport, ListenSocket])&#125;.<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Transport, ListenSocket)</span> -&gt;</span>    <span class="hljs-keyword">case</span> Transport:wait(ListenSocket) <span class="hljs-keyword">of</span>        &#123;ok, NewSock&#125; -&gt;            loop(Transport, NewSock);        Error -&gt; Error    <span class="hljs-keyword">end</span>.<span class="hljs-function"><span class="hljs-title">loop</span><span class="hljs-params">(Transport, RemoteSocket)</span> -&gt;</span>    <span class="hljs-keyword">case</span> Transport:recv(RemoteSocket, <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>        &#123;ok, BinData&#125; -&gt;            &#123;ok, PeerName&#125; = Transport:peername(RemoteSocket),            io:format(<span class="hljs-string">&quot;BinData from ~s: and data is : ~p ~n&quot;</span>, [esockd_net:format(peername, PeerName), BinData]),            Transport:send(RemoteSocket, &lt;&lt;<span class="hljs-string">&quot;OK&quot;</span>&gt;&gt;),            loop(Transport, RemoteSocket);        &#123;error, Reason&#125; -&gt;            io:format(<span class="hljs-string">&quot;TCP Error: ~s~n&quot;</span>, [Reason]),            &#123;stop, Reason&#125;    <span class="hljs-keyword">end</span>.</code></pre><p> start_link以后通过init函数开启一个监听服务,到此为止,我们的监听器已经适配成功.</p><p>​        可能有的小伙伴比较开心,终于搞定了!但是我还没说Ok呢,到这里完了吗?这样就能跑起来了吗?答案当然是不能,前面提到的配置在哪里?还没讲呢,这样仅仅是把监听器的Erlang部分处理好了,但是还没有处理配置部分.接下来我们处理配置文件.</p><h2 id="5-自定义协议配置"><a href="#5-自定义协议配置" class="headerlink" title="5.自定义协议配置"></a>5.自定义协议配置</h2><p>​        EMQX的配置文件是通过cuttlefish这个框架来做映射处理的,因此我们得熟悉一下cuttlefish.因为上一篇文章已经大概讲了,这里不做赘述,我们直接看相关代码即可.</p><p>​        首先找到priv目录下的schema文件:</p><p><img src="/uploads/image-20191201194121823.png" alt="image-20191201194121823"></p><p>​        找到大概1780行:</p><p><img src="/uploads/image-20191201194246035.png" alt="image-20191201194246035"></p><p>​        为甚看这里?主要这里就是用来处理自定义协议配置的,仔细观察发现这行关键代码:</p><pre><code class="hljs erlang">cuttlefish_variable:filter_by_prefix(<span class="hljs-string">&quot;listener.tcp&quot;</span>, Conf)</code></pre><p>​        表示cuttlefish筛选listener.tcp开头的配置,然后解析出来供给get_env函数使用,上面的函数抽象一下就是如下形式:</p><pre><code class="hljs erlang">cuttlefish_variable:filter_by_prefix(<span class="hljs-string">&quot;listener.自定义协议名字&quot;</span>, Conf)</code></pre><p>​        我们的案例是自定义的trap协议,所以我直接加了trap协议配置的处理函数:</p><pre><code class="hljs erlang">cuttlefish_variable:filter_by_prefix(<span class="hljs-string">&quot;listener.trap&quot;</span>, Conf)</code></pre><p>​        cuttlefish解决的问题是:让用户看得懂的配置,所以我们目前仅仅是配置了开发阶段的,还没有配置用户的入口.接下来我们配置用户的入口.</p><h2 id="6-用户配置"><a href="#6-用户配置" class="headerlink" title="6.用户配置"></a>6.用户配置</h2><ol><li>打开etc目录下的emqx.conf文件</li></ol><p>​        <img src="/uploads/image-20191201201456984.png" alt="image-20191201201456984"></p><ol start="2"><li><p>加入自定义协议的配置</p><p>​        直接拉到最下面,加入以下内容:</p><pre><code class="hljs properties"><span class="hljs-comment">##--------------------------------------------------------------------</span><span class="hljs-comment">## Trap listener</span><span class="hljs-comment">##--------------------------------------------------------------------</span><span class="hljs-meta">listener.trap.external</span> = <span class="hljs-string">0.0.0.0:2600</span><span class="hljs-meta">listener.trap.external.acceptors</span> = <span class="hljs-string">8</span><span class="hljs-meta">listener.trap.external.max_connections</span> = <span class="hljs-string">1024000</span><span class="hljs-meta">listener.trap.external.max_conn_rate</span> = <span class="hljs-string">1000</span><span class="hljs-meta">listener.trap.external.active_n</span> = <span class="hljs-string">100</span><span class="hljs-meta">listener.trap.external.zone</span> = <span class="hljs-string">external</span><span class="hljs-meta">listener.trap.external.access.1</span> = <span class="hljs-string">allow all</span><span class="hljs-meta">listener.trap.external.backlog</span> = <span class="hljs-string">1024</span><span class="hljs-meta">listener.trap.external.send_timeout</span> = <span class="hljs-string">15s</span><span class="hljs-meta">listener.trap.external.send_timeout_close</span> = <span class="hljs-string">on</span><span class="hljs-meta">listener.trap.external.nodelay</span> = <span class="hljs-string">true</span><span class="hljs-meta">listener.trap.external.reuseaddr</span> = <span class="hljs-string">true</span></code></pre><p>​        可以看出我们这里的协议名字和cuttlefish里面配置的一样:trap.到此为止,我们总算是完成了所有的基本配置操作,接下来我们开始编译.</p><h2 id="7-EMQX编译"><a href="#7-EMQX编译" class="headerlink" title="7.EMQX编译"></a>7.EMQX编译</h2><p>回到我们刚开始拉下来的emqx-rel项目,打开rebar.config文件,找到15行左右:</p><p><img src="/uploads/image-20191201202205235.png" alt="image-20191201202205235"></p><p>指定一个仓库,我自己指定的是:</p><pre><code class="hljs shell">&#123;emqx,&#123;git,&quot;https://github.com/emqx/emqx&quot;,&#123;branch,&quot;master&quot;&#125;&#125;&#125;</code></pre><p>然后把之前修改过的emqx 源码push到上面的仓库,表示是emqx从这里构建,不然默认是emqx的官方仓库.</p><p>最后执行下面的命令:</p><pre><code class="hljs shell">make./_build/emqx/rel/emqx/bin/emqx console</code></pre><p>如果没有问题,你可以看见自己的监听器:</p><p><img src="/uploads/image-20191201190852642.png" alt="image-20191201190852642"></p></li></ol><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><ol><li>如何获得源码</li><li>如何修改emqx源码</li><li>如何配置cuttlefish</li><li>如何编译自定义的emqx</li></ol>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX插件开发:自定义参数配置</title>
    <link href="/2019/11/26/clpqt1itz001a4cued67k2v0n.html"/>
    <url>/2019/11/26/clpqt1itz001a4cued67k2v0n.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要介绍EMQX插件开发中的一些细节.</p><span id="more"></span><p><img src="/uploads/image-20191126223605770.png" alt="image-20191126223605770"></p><h2 id="1-背景概述"><a href="#1-背景概述" class="headerlink" title="1. 背景概述"></a>1. 背景概述</h2><p>本文主要讲一下最新版的EMQX的插件开发.关于插件开发环境准备,请看之前的文章,这里讲讲插件开发中的高级功能:自定义参数配置.</p><h2 id="2-案例学习"><a href="#2-案例学习" class="headerlink" title="2. 案例学习"></a>2. 案例学习</h2><p>在此时前我们先看下几个典型的插件:</p><h3 id="1-Mysql插件"><a href="#1-Mysql插件" class="headerlink" title="1. Mysql插件"></a>1. Mysql插件</h3><p><img src="/uploads/image-20191126214116896.png" alt="image-20191126214116896"></p><p>大概熟悉一下插件的基本结构:其实我们发现EMQX的插件就是一个很普通的OTP应用,其中代码在src目录下,配置在etc下.</p><p>我们首先看下Mysql插件的的配置:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># MySQL server address.</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 为了节省篇幅,我把不重要的全部删了,留下关键几个配置</span></span>auth.mysql.server = 127.0.0.1:3306auth.mysql.pool = 8auth.mysql.username =auth.mysql.password =auth.mysql.database = mqtt</code></pre><p>这些配置主要用来配置Mysql的Host,端口,密码等等,我们可以很容易集成进我们的应用中.</p><h3 id="2-MongoDb插件"><a href="#2-MongoDb插件" class="headerlink" title="2. MongoDb插件"></a>2. MongoDb插件</h3><p><img src="/uploads/image-20191126214558153.png" alt="image-20191126214558153"></p><p>其中MongoDB插件和Mysql插件没区别,结构都是完全一样的,因此我们可以按照这个结构来设计插件.</p><p>下面是MongoDb插件的配置:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># MongoDB Topology Type.</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 为了节省篇幅,我把不重要的全部删了,留下关键几个配置</span></span>auth.mongo.type = singleauth.mongo.server = 127.0.0.1:27017auth.mongo.pool = 8</code></pre><p>同样和Mysql一样,都是方便用户自定义配置参数进来.</p><h2 id="4-自定义插件"><a href="#4-自定义插件" class="headerlink" title="4. 自定义插件"></a>4. 自定义插件</h2><p>看完了上面两个插件的配置以后,我们发现个规律:配置文件基本都是满足Key-Value这种形式,Key作为配置项,Value作为参数值.理解了这种格式以后,我们可在自定义插件开发中加入进来.</p><blockquote><p>​        因为EMQX的参数配置使用了一个库:cuttlefish,大家可以去github上找找文档,这个库中文文档比较少,建议大家直接看库文档即可.</p></blockquote><h3 id="1-新建插件"><a href="#1-新建插件" class="headerlink" title="1. 新建插件"></a>1. 新建插件</h3><pre><code class="hljs awk"><span class="hljs-comment">## 如果没安装插件模板,先安装插件模板</span>wget https:<span class="hljs-regexp">//</span>s3.amazonaws.com<span class="hljs-regexp">/rebar3/</span>rebar3 &amp;&amp; chmod +x rebar3./rebar3 local installmkdir -p ~<span class="hljs-regexp">/.config/</span>rebar3/templatesgit clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/emqx/</span>rebar3_emqx_plugin ~<span class="hljs-regexp">/.config/</span>rebar3/templates<span class="hljs-comment">## 如果上面的工作都已经完成的话,直接新建插件模板</span>rebar3 new emqx-plugin &lt;plugin-name&gt;</code></pre><p>经过上述步骤,我们已经新建了一个插件模板,比如我新建了一个:advisory_plugin.项目结构如下:</p><p><img src="/uploads/image-20191126221244880.png" alt="image-20191126221244880"></p><h3 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2. 配置插件"></a>2. 配置插件</h3><p>接下来我们把插件配置进EMQX里面.</p><p>首先需要clone下emqx-rel项目,这个是编译EMQX的入口.</p><pre><code class="hljs shell">git clone https://github.com/emqx/emqx-rel.git emqx-relcd emqx-rel &amp;&amp; make./_build/emqx/rel/emqx/bin/emqx console</code></pre><p>确认没问题以后,我们开始配置插件.在配置插件之前,记得把代码提交到git服务器上,这里我用gitee做演示,因为国内速度比较快.</p><ol><li><p>打开rebar.config文件,在<code>deps</code>节点找到合适的位置加入自己的插件地址:</p><pre><code class="hljs erlang">&#123; advisory_plugin, &#123; git , <span class="hljs-string">&quot;https://gitee.com/lagrangewang/advisory_plugin.git&quot;</span> , &#123;branch, <span class="hljs-string">&quot;master&quot;</span>&#125; &#125; &#125;</code></pre><p><img src="/uploads/image-20191126222939838.png" alt="image-20191126222939838"></p></li><li><p>在relx节点找到合适的位置,加入以下内容:</p><pre><code class="hljs clojure">&#123;advisory_plugin, load&#125;</code></pre><p><img src="/uploads/image-20191126223252312.png" alt="image-20191126223252312"></p></li></ol><p>到此为止我们的插件就装好了.我们按照EMQX的官网文档,编译完成,启动EMQX,可以看到如下:</p><h3 id="3-配置参数"><a href="#3-配置参数" class="headerlink" title="3. 配置参数"></a>3. 配置参数</h3><p>接下来进入比较重要的环节:自定义插件参数.我们在本案例里面演示了如何配置单个或者,多个URL地址.</p><p>首先打开插件目录下的etc目录,找到conf文件,加入我们自己的配置项:</p><pre><code class="hljs sh"><span class="hljs-comment"># 单个配置项</span>advisory_plugin.destination = http://localhost:2500/ezlinker/data/<span class="hljs-keyword">in</span><span class="hljs-comment"># 多个配置项</span>advisory_plugin.server.1 = http://1:2500/ezlinker/data/<span class="hljs-keyword">in</span>advisory_plugin.server.2 = http://2:2500/ezlinker/data/<span class="hljs-keyword">in</span></code></pre><p>这里需要注意的是,单个配置项一般为K-V键值对的形式.而多个项需要满足如下格式:</p><pre><code class="hljs shell">k.$&#123;name&#125;</code></pre><p>其中${name}是个占位符,可以自定义表示多个参数的序号,或者名字,建议用序号来表示.</p><h3 id="4-映射参数"><a href="#4-映射参数" class="headerlink" title="4. 映射参数"></a>4. 映射参数</h3><p>接下来,最后一个环节,映射自定义参数:</p><p>打开priv目录下的schema文件,首先映射我们的单配置项:</p><pre><code class="hljs erlang"><span class="hljs-comment">%% advisory_plugin config</span>&#123;mapping, <span class="hljs-string">&quot;advisory_plugin.destination&quot;</span>, <span class="hljs-string">&quot;advisory_plugin.destination&quot;</span>, [  &#123;datatype, string&#125;]&#125;.</code></pre><p>其中:mapping表示参数映射,第二个参数表示etc下的conf文件中的名称,第三个参数表示配置文件的键,用来在程序中获取.</p><h3 id="5-转换参数"><a href="#5-转换参数" class="headerlink" title="5. 转换参数"></a>5. 转换参数</h3><p>多项参数比较麻烦,还需要一个转换器,同样在schema文件中,定义一个转换器:</p><pre><code class="hljs erlang">&#123;translation, <span class="hljs-string">&quot;advisory_plugin.server&quot;</span>,  <span class="hljs-keyword">fun</span>(Conf) -&gt;      Urls = cuttlefish_variable:filter_by_prefix(<span class="hljs-string">&quot;advisory_plugin.server&quot;</span>, Conf),      [ Url || Url &lt;- Urls]  <span class="hljs-keyword">end</span>&#125;.</code></pre><p>这段代码可以理解为:获取配置中advisory_plugin.server对应的值,返回一个列表,配置文件之间的关系如图所示:</p><p><img src="/uploads/image-20191126230712872.png" alt="image-20191126230712872"></p><h3 id="6-获取参数"><a href="#6-获取参数" class="headerlink" title="6. 获取参数"></a>6. 获取参数</h3><ol><li>单项参数获取</li></ol><pre><code class="hljs erlang"><span class="hljs-comment">%%参数说明</span><span class="hljs-comment">%%?APP:插件模块</span><span class="hljs-comment">%%destination:mapping的第二个参数的Key</span><span class="hljs-comment">%%&quot;http://127.0.0.1&quot;:如果获取失败的默认值</span>Url = application:get_env(?APP, destination, <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>)</code></pre><ol start="2"><li><p>多项参数获取</p><pre><code class="hljs erlang">Urls = application:get_env(?APP, server, <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>),lists:foreach(<span class="hljs-keyword">fun</span>(U) -&gt;     &#123;[_N,_K,_S],Url&#125; = U,    io:format(<span class="hljs-string">&quot;Url is : ~p~n&quot;</span>, [Url]) <span class="hljs-keyword">end</span>, Urls),</code></pre></li></ol><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>本文主要讲了以下知识点:</p><ol><li><p>创建插件</p></li><li><p>注册插件</p></li><li><p>编译测试</p></li><li><p>自定义开发</p></li><li><p>单项参数的配置和获取</p></li><li><p>多项参数的定义和获取</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python科学计算库pandas的简单应用</title>
    <link href="/2019/11/19/clpqt1iuw00494cue8esifwzp.html"/>
    <url>/2019/11/19/clpqt1iuw00494cue8esifwzp.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：简单数据分析，使用的是Python的pandas库-&gt;</p><span id="more"></span><p>我的课题选项是：假设有一次购物活动，来自福建省几个主要城市的人参加了这次购物活动，活动结束了，然后我们掌握了这些购买数据，然后进一步分析，便于掌握规律，提供数据给市场运营部去参考。</p><p>数据量：10000条购买数据,前面是人的基本信息，后面是所购买的商品种类列表。</p><p><img src="https://static.oschina.net/uploads/space/2016/1124/173644_H2Go_2702126.png" alt=""></p><p>福建省几个主要地区：</p><p>“福州”, “泉州”, “厦门”, “三明”, “龙岩”。。。。等等</p><p>①第一个任务，搭建环境</p><p>我这里用了这些主要依赖库</p><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> random</code></pre><p>如果没有，你可以通过pip  或者其他三方安装工具，或者直接去官网下载【安装过程很痛苦】。</p><p>好了，基本环境搞完了，接下来就是怎么来分析了</p><p>下面是我的常量表：百家姓和一些人名，便于随机生成人名。</p><pre><code class="hljs livescript">MAX_AGE = <span class="hljs-number">55</span>MIN_AGE = <span class="hljs-number">15</span>SHOPPING_LIST = <span class="hljs-string">\[&quot;女装&quot;,</span> <span class="hljs-string">&quot;男装&quot;</span>, <span class="hljs-string">&quot;内衣&quot;</span>, <span class="hljs-string">&quot;鞋靴&quot;</span>, <span class="hljs-string">&quot;箱包&quot;</span>, <span class="hljs-string">&quot;配件&quot;</span>, <span class="hljs-string">&quot;童装玩具&quot;</span>, <span class="hljs-string">&quot;孕产&quot;</span>, <span class="hljs-string">&quot;用品&quot;</span>, <span class="hljs-string">&quot;家电&quot;</span>, <span class="hljs-string">&quot;数码&quot;</span>, <span class="hljs-string">&quot;手机&quot;</span>, <span class="hljs-string">&quot;美妆&quot;</span>, <span class="hljs-string">&quot;洗护&quot;</span>, <span class="hljs-string">&quot;保健品&quot;</span>, <span class="hljs-string">&quot;珠宝&quot;</span>,                 <span class="hljs-string">&quot;眼镜&quot;</span>, <span class="hljs-string">&quot;手表&quot;</span>, <span class="hljs-string">&quot;运动&quot;</span>, <span class="hljs-string">&quot;户外&quot;</span>, <span class="hljs-string">&quot;乐器&quot;</span>, <span class="hljs-string">&quot;游戏&quot;</span>, <span class="hljs-string">&quot;动漫&quot;</span>, <span class="hljs-string">&quot;影视&quot;</span>, <span class="hljs-string">&quot;美食&quot;</span>, <span class="hljs-string">&quot;生鲜&quot;</span>, <span class="hljs-string">&quot;零食&quot;</span>, <span class="hljs-string">&quot;鲜花&quot;</span>, <span class="hljs-string">&quot;农资&quot;</span>, <span class="hljs-string">&quot;房产&quot;</span>, <span class="hljs-string">&quot;装修&quot;</span>, <span class="hljs-string">&quot;建材&quot;</span>, <span class="hljs-string">&quot;家具&quot;</span>,                 <span class="hljs-string">&quot;家饰&quot;</span>, <span class="hljs-string">&quot;家纺&quot;</span>, <span class="hljs-string">&quot;汽车&quot;</span>, <span class="hljs-string">&quot;二手车&quot;</span>, <span class="hljs-string">&quot;用品&quot;</span>, <span class="hljs-string">&quot;办公&quot;</span>, <span class="hljs-string">&quot;DIY&quot;</span>, <span class="hljs-string">&quot;五金电子&quot;</span>, <span class="hljs-string">&quot;百货&quot;</span>, <span class="hljs-string">&quot;餐厨&quot;</span>, <span class="hljs-string">&quot;家庭保健&quot;</span>, <span class="hljs-string">&quot;学习&quot;</span>, <span class="hljs-string">&quot;卡券&quot;</span>, <span class="hljs-string">&quot;本地服务&quot;</span><span class="hljs-string">\]</span>FIRST<span class="hljs-string">\_NAME\_TABLE</span> = <span class="hljs-string">\[&quot;赵&quot;,</span> <span class="hljs-string">&quot;钱&quot;</span>, <span class="hljs-string">&quot;孙&quot;</span>, <span class="hljs-string">&quot;李&quot;</span>, <span class="hljs-string">&quot;周&quot;</span>, <span class="hljs-string">&quot;吴&quot;</span>, <span class="hljs-string">&quot;郑&quot;</span>, <span class="hljs-string">&quot;王&quot;</span>, <span class="hljs-string">&quot;冯&quot;</span>, <span class="hljs-string">&quot;陈&quot;</span>, <span class="hljs-string">&quot;褚&quot;</span>, <span class="hljs-string">&quot;卫&quot;</span>, <span class="hljs-string">&quot;蒋&quot;</span>, <span class="hljs-string">&quot;沈&quot;</span>, <span class="hljs-string">&quot;韩&quot;</span>, <span class="hljs-string">&quot;杨&quot;</span>, <span class="hljs-string">&quot;朱&quot;</span>, <span class="hljs-string">&quot;秦&quot;</span>, <span class="hljs-string">&quot;尤&quot;</span>,                    <span class="hljs-string">&quot;许&quot;</span>, <span class="hljs-string">&quot;何&quot;</span>, <span class="hljs-string">&quot;吕&quot;</span>, <span class="hljs-string">&quot;施&quot;</span>, <span class="hljs-string">&quot;张&quot;</span>, <span class="hljs-string">&quot;孔&quot;</span>, <span class="hljs-string">&quot;曹&quot;</span>, <span class="hljs-string">&quot;严&quot;</span>, <span class="hljs-string">&quot;华&quot;</span>, <span class="hljs-string">&quot;金&quot;</span>, <span class="hljs-string">&quot;魏&quot;</span>, <span class="hljs-string">&quot;陶&quot;</span>, <span class="hljs-string">&quot;姜&quot;</span>, <span class="hljs-string">&quot;戚&quot;</span>, <span class="hljs-string">&quot;谢&quot;</span>, <span class="hljs-string">&quot;邹&quot;</span>, <span class="hljs-string">&quot;喻&quot;</span>, <span class="hljs-string">&quot;柏&quot;</span>, <span class="hljs-string">&quot;水&quot;</span>, <span class="hljs-string">&quot;窦&quot;</span>,                    <span class="hljs-string">&quot;章&quot;</span>,                    <span class="hljs-string">&quot;云&quot;</span>, <span class="hljs-string">&quot;苏&quot;</span>, <span class="hljs-string">&quot;潘&quot;</span>, <span class="hljs-string">&quot;葛&quot;</span>, <span class="hljs-string">&quot;奚&quot;</span>, <span class="hljs-string">&quot;范&quot;</span>, <span class="hljs-string">&quot;彭&quot;</span>, <span class="hljs-string">&quot;郎&quot;</span>, <span class="hljs-string">&quot;鲁&quot;</span>, <span class="hljs-string">&quot;韦&quot;</span>, <span class="hljs-string">&quot;昌&quot;</span>, <span class="hljs-string">&quot;马&quot;</span>, <span class="hljs-string">&quot;苗&quot;</span>, <span class="hljs-string">&quot;凤&quot;</span>, <span class="hljs-string">&quot;花&quot;</span>, <span class="hljs-string">&quot;方&quot;</span>, <span class="hljs-string">&quot;俞&quot;</span>, <span class="hljs-string">&quot;任&quot;</span>, <span class="hljs-string">&quot;袁&quot;</span>, <span class="hljs-string">&quot;柳&quot;</span>,                    <span class="hljs-string">&quot;酆&quot;</span>,                    <span class="hljs-string">&quot;鲍&quot;</span>, <span class="hljs-string">&quot;史&quot;</span>, <span class="hljs-string">&quot;唐&quot;</span>, <span class="hljs-string">&quot;费&quot;</span>, <span class="hljs-string">&quot;廉&quot;</span>, <span class="hljs-string">&quot;岑&quot;</span>, <span class="hljs-string">&quot;薛&quot;</span>, <span class="hljs-string">&quot;雷&quot;</span>, <span class="hljs-string">&quot;贺&quot;</span>, <span class="hljs-string">&quot;倪&quot;</span>, <span class="hljs-string">&quot;汤&quot;</span>, <span class="hljs-string">&quot;滕&quot;</span>, <span class="hljs-string">&quot;殷&quot;</span>, <span class="hljs-string">&quot;罗&quot;</span>, <span class="hljs-string">&quot;毕&quot;</span>, <span class="hljs-string">&quot;郝&quot;</span>, <span class="hljs-string">&quot;邬&quot;</span>, <span class="hljs-string">&quot;安&quot;</span>, <span class="hljs-string">&quot;常&quot;</span>, <span class="hljs-string">&quot;乐&quot;</span>,                    <span class="hljs-string">&quot;于&quot;</span>,                    <span class="hljs-string">&quot;时&quot;</span>, <span class="hljs-string">&quot;傅&quot;</span>, <span class="hljs-string">&quot;皮&quot;</span>, <span class="hljs-string">&quot;卞&quot;</span>, <span class="hljs-string">&quot;齐&quot;</span>, <span class="hljs-string">&quot;康&quot;</span>, <span class="hljs-string">&quot;伍&quot;</span>, <span class="hljs-string">&quot;余&quot;</span>, <span class="hljs-string">&quot;元&quot;</span>, <span class="hljs-string">&quot;卜&quot;</span>, <span class="hljs-string">&quot;顾&quot;</span>, <span class="hljs-string">&quot;孟&quot;</span>, <span class="hljs-string">&quot;平&quot;</span>, <span class="hljs-string">&quot;黄&quot;</span>, <span class="hljs-string">&quot;和&quot;</span>, <span class="hljs-string">&quot;穆&quot;</span>, <span class="hljs-string">&quot;萧&quot;</span>, <span class="hljs-string">&quot;尹&quot;</span>, <span class="hljs-string">&quot;姚&quot;</span>, <span class="hljs-string">&quot;邵&quot;</span>,                    <span class="hljs-string">&quot;湛&quot;</span>,                    <span class="hljs-string">&quot;汪&quot;</span>, <span class="hljs-string">&quot;禹&quot;</span>, <span class="hljs-string">&quot;狄&quot;</span>, <span class="hljs-string">&quot;米&quot;</span>, <span class="hljs-string">&quot;贝&quot;</span>, <span class="hljs-string">&quot;明&quot;</span>, <span class="hljs-string">&quot;臧&quot;</span>, <span class="hljs-string">&quot;计&quot;</span>, <span class="hljs-string">&quot;伏&quot;</span>, <span class="hljs-string">&quot;成&quot;</span>, <span class="hljs-string">&quot;戴&quot;</span>, <span class="hljs-string">&quot;谈&quot;</span>, <span class="hljs-string">&quot;宋&quot;</span>, <span class="hljs-string">&quot;茅&quot;</span>, <span class="hljs-string">&quot;庞&quot;</span>, <span class="hljs-string">&quot;熊&quot;</span>, <span class="hljs-string">&quot;纪&quot;</span>, <span class="hljs-string">&quot;舒&quot;</span>, <span class="hljs-string">&quot;屈&quot;</span>, <span class="hljs-string">&quot;项&quot;</span>,                    <span class="hljs-string">&quot;祝&quot;</span>,                    <span class="hljs-string">&quot;董&quot;</span>, <span class="hljs-string">&quot;梁&quot;</span>, <span class="hljs-string">&quot;杜&quot;</span>, <span class="hljs-string">&quot;阮&quot;</span>, <span class="hljs-string">&quot;蓝&quot;</span>, <span class="hljs-string">&quot;闵&quot;</span>, <span class="hljs-string">&quot;席&quot;</span>, <span class="hljs-string">&quot;季&quot;</span>, <span class="hljs-string">&quot;麻&quot;</span>, <span class="hljs-string">&quot;强&quot;</span>, <span class="hljs-string">&quot;贾&quot;</span>, <span class="hljs-string">&quot;路&quot;</span>, <span class="hljs-string">&quot;娄&quot;</span>, <span class="hljs-string">&quot;危&quot;</span>, <span class="hljs-string">&quot;江&quot;</span>, <span class="hljs-string">&quot;童&quot;</span>, <span class="hljs-string">&quot;颜&quot;</span>, <span class="hljs-string">&quot;郭&quot;</span>, <span class="hljs-string">&quot;梅&quot;</span>, <span class="hljs-string">&quot;盛&quot;</span>,                    <span class="hljs-string">&quot;林&quot;</span>,                    <span class="hljs-string">&quot;刁&quot;</span>, <span class="hljs-string">&quot;钟&quot;</span>, <span class="hljs-string">&quot;徐&quot;</span>, <span class="hljs-string">&quot;邱&quot;</span>, <span class="hljs-string">&quot;骆&quot;</span>, <span class="hljs-string">&quot;高&quot;</span>, <span class="hljs-string">&quot;夏&quot;</span>, <span class="hljs-string">&quot;蔡&quot;</span>, <span class="hljs-string">&quot;田&quot;</span>, <span class="hljs-string">&quot;樊&quot;</span>, <span class="hljs-string">&quot;胡&quot;</span>, <span class="hljs-string">&quot;凌&quot;</span>, <span class="hljs-string">&quot;霍&quot;</span>, <span class="hljs-string">&quot;虞&quot;</span>, <span class="hljs-string">&quot;万&quot;</span>, <span class="hljs-string">&quot;支&quot;</span>, <span class="hljs-string">&quot;柯&quot;</span>, <span class="hljs-string">&quot;昝&quot;</span>, <span class="hljs-string">&quot;管&quot;</span>, <span class="hljs-string">&quot;卢&quot;</span>,                    <span class="hljs-string">&quot;莫&quot;</span>,                    <span class="hljs-string">&quot;经&quot;</span>, <span class="hljs-string">&quot;房&quot;</span>, <span class="hljs-string">&quot;裘&quot;</span>, <span class="hljs-string">&quot;缪&quot;</span>, <span class="hljs-string">&quot;干&quot;</span>, <span class="hljs-string">&quot;解&quot;</span>, <span class="hljs-string">&quot;应&quot;</span>, <span class="hljs-string">&quot;宗&quot;</span>, <span class="hljs-string">&quot;丁&quot;</span>, <span class="hljs-string">&quot;宣&quot;</span>, <span class="hljs-string">&quot;贲&quot;</span>, <span class="hljs-string">&quot;邓&quot;</span>, <span class="hljs-string">&quot;郁&quot;</span>, <span class="hljs-string">&quot;单&quot;</span>, <span class="hljs-string">&quot;杭&quot;</span>, <span class="hljs-string">&quot;洪&quot;</span>, <span class="hljs-string">&quot;包&quot;</span>, <span class="hljs-string">&quot;诸&quot;</span>, <span class="hljs-string">&quot;左&quot;</span>, <span class="hljs-string">&quot;石&quot;</span>,                    <span class="hljs-string">&quot;崔&quot;</span>,                    <span class="hljs-string">&quot;吉&quot;</span>, <span class="hljs-string">&quot;钮&quot;</span>, <span class="hljs-string">&quot;龚&quot;</span>, <span class="hljs-string">&quot;程&quot;</span>, <span class="hljs-string">&quot;嵇&quot;</span>, <span class="hljs-string">&quot;邢&quot;</span>, <span class="hljs-string">&quot;滑&quot;</span>, <span class="hljs-string">&quot;裴&quot;</span>, <span class="hljs-string">&quot;陆&quot;</span>, <span class="hljs-string">&quot;荣&quot;</span>, <span class="hljs-string">&quot;翁&quot;</span>, <span class="hljs-string">&quot;荀&quot;</span>, <span class="hljs-string">&quot;羊&quot;</span>, <span class="hljs-string">&quot;於&quot;</span>, <span class="hljs-string">&quot;惠&quot;</span>, <span class="hljs-string">&quot;甄&quot;</span>, <span class="hljs-string">&quot;曲&quot;</span>, <span class="hljs-string">&quot;家&quot;</span>, <span class="hljs-string">&quot;封&quot;</span>, <span class="hljs-string">&quot;芮&quot;</span>,                    <span class="hljs-string">&quot;羿&quot;</span>,                    <span class="hljs-string">&quot;储&quot;</span>, <span class="hljs-string">&quot;靳&quot;</span>, <span class="hljs-string">&quot;汲&quot;</span>, <span class="hljs-string">&quot;邴&quot;</span>, <span class="hljs-string">&quot;糜&quot;</span>, <span class="hljs-string">&quot;松&quot;</span>, <span class="hljs-string">&quot;井&quot;</span>, <span class="hljs-string">&quot;段&quot;</span>, <span class="hljs-string">&quot;富&quot;</span>, <span class="hljs-string">&quot;巫&quot;</span>, <span class="hljs-string">&quot;乌&quot;</span>, <span class="hljs-string">&quot;焦&quot;</span>, <span class="hljs-string">&quot;巴&quot;</span>, <span class="hljs-string">&quot;弓&quot;</span>, <span class="hljs-string">&quot;牧&quot;</span>, <span class="hljs-string">&quot;隗&quot;</span>, <span class="hljs-string">&quot;山&quot;</span>, <span class="hljs-string">&quot;谷&quot;</span>, <span class="hljs-string">&quot;车&quot;</span>, <span class="hljs-string">&quot;侯&quot;</span>,                    <span class="hljs-string">&quot;宓&quot;</span>,                    <span class="hljs-string">&quot;蓬&quot;</span>, <span class="hljs-string">&quot;全&quot;</span>, <span class="hljs-string">&quot;郗&quot;</span>, <span class="hljs-string">&quot;班&quot;</span>, <span class="hljs-string">&quot;仰&quot;</span>, <span class="hljs-string">&quot;秋&quot;</span>, <span class="hljs-string">&quot;仲&quot;</span>, <span class="hljs-string">&quot;伊&quot;</span>, <span class="hljs-string">&quot;宫&quot;</span>, <span class="hljs-string">&quot;宁&quot;</span>, <span class="hljs-string">&quot;仇&quot;</span>, <span class="hljs-string">&quot;栾&quot;</span>, <span class="hljs-string">&quot;暴&quot;</span>, <span class="hljs-string">&quot;甘&quot;</span>, <span class="hljs-string">&quot;钭&quot;</span>, <span class="hljs-string">&quot;厉&quot;</span>, <span class="hljs-string">&quot;戎&quot;</span>, <span class="hljs-string">&quot;祖&quot;</span>, <span class="hljs-string">&quot;武&quot;</span>, <span class="hljs-string">&quot;符&quot;</span>,                    <span class="hljs-string">&quot;刘&quot;</span>,                    <span class="hljs-string">&quot;景&quot;</span>, <span class="hljs-string">&quot;詹&quot;</span>, <span class="hljs-string">&quot;束&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-string">&quot;叶&quot;</span>, <span class="hljs-string">&quot;幸&quot;</span>, <span class="hljs-string">&quot;司&quot;</span>, <span class="hljs-string">&quot;韶&quot;</span>, <span class="hljs-string">&quot;郜&quot;</span>, <span class="hljs-string">&quot;黎&quot;</span>, <span class="hljs-string">&quot;蓟&quot;</span>, <span class="hljs-string">&quot;薄&quot;</span>, <span class="hljs-string">&quot;印&quot;</span>, <span class="hljs-string">&quot;宿&quot;</span>, <span class="hljs-string">&quot;白&quot;</span>, <span class="hljs-string">&quot;怀&quot;</span>, <span class="hljs-string">&quot;蒲&quot;</span>, <span class="hljs-string">&quot;台&quot;</span>, <span class="hljs-string">&quot;从&quot;</span>, <span class="hljs-string">&quot;鄂&quot;</span>,                    <span class="hljs-string">&quot;索&quot;</span>,                    <span class="hljs-string">&quot;咸&quot;</span>, <span class="hljs-string">&quot;籍&quot;</span>, <span class="hljs-string">&quot;赖&quot;</span>, <span class="hljs-string">&quot;卓&quot;</span>, <span class="hljs-string">&quot;蔺&quot;</span>, <span class="hljs-string">&quot;屠&quot;</span>, <span class="hljs-string">&quot;蒙&quot;</span>, <span class="hljs-string">&quot;池&quot;</span>, <span class="hljs-string">&quot;乔&quot;</span>, <span class="hljs-string">&quot;阴&quot;</span>, <span class="hljs-string">&quot;郁&quot;</span>, <span class="hljs-string">&quot;胥&quot;</span>, <span class="hljs-string">&quot;能&quot;</span>, <span class="hljs-string">&quot;苍&quot;</span>, <span class="hljs-string">&quot;双&quot;</span>, <span class="hljs-string">&quot;闻&quot;</span>, <span class="hljs-string">&quot;莘&quot;</span>, <span class="hljs-string">&quot;党&quot;</span>, <span class="hljs-string">&quot;翟&quot;</span>, <span class="hljs-string">&quot;谭&quot;</span>,                    <span class="hljs-string">&quot;贡&quot;</span>,                    <span class="hljs-string">&quot;劳&quot;</span>, <span class="hljs-string">&quot;逄&quot;</span>, <span class="hljs-string">&quot;姬&quot;</span>, <span class="hljs-string">&quot;申&quot;</span>, <span class="hljs-string">&quot;扶&quot;</span>, <span class="hljs-string">&quot;堵&quot;</span>, <span class="hljs-string">&quot;冉&quot;</span>, <span class="hljs-string">&quot;宰&quot;</span>, <span class="hljs-string">&quot;郦&quot;</span>, <span class="hljs-string">&quot;雍&quot;</span>, <span class="hljs-string">&quot;却&quot;</span>, <span class="hljs-string">&quot;璩&quot;</span>, <span class="hljs-string">&quot;桑&quot;</span>, <span class="hljs-string">&quot;桂&quot;</span>, <span class="hljs-string">&quot;濮&quot;</span>, <span class="hljs-string">&quot;牛&quot;</span>, <span class="hljs-string">&quot;寿&quot;</span>, <span class="hljs-string">&quot;通&quot;</span>, <span class="hljs-string">&quot;边&quot;</span>, <span class="hljs-string">&quot;扈&quot;</span>,                    <span class="hljs-string">&quot;燕&quot;</span>,                    <span class="hljs-string">&quot;冀&quot;</span>, <span class="hljs-string">&quot;郏&quot;</span>, <span class="hljs-string">&quot;浦&quot;</span>, <span class="hljs-string">&quot;尚&quot;</span>, <span class="hljs-string">&quot;农&quot;</span>, <span class="hljs-string">&quot;温&quot;</span>, <span class="hljs-string">&quot;别&quot;</span>, <span class="hljs-string">&quot;庄&quot;</span>, <span class="hljs-string">&quot;晏&quot;</span>, <span class="hljs-string">&quot;柴&quot;</span>, <span class="hljs-string">&quot;瞿&quot;</span>, <span class="hljs-string">&quot;阎&quot;</span>, <span class="hljs-string">&quot;充&quot;</span>, <span class="hljs-string">&quot;慕&quot;</span>, <span class="hljs-string">&quot;连&quot;</span>, <span class="hljs-string">&quot;茹&quot;</span>, <span class="hljs-string">&quot;习&quot;</span>, <span class="hljs-string">&quot;宦&quot;</span>, <span class="hljs-string">&quot;艾&quot;</span>, <span class="hljs-string">&quot;鱼&quot;</span>,                    <span class="hljs-string">&quot;容&quot;</span>,                    <span class="hljs-string">&quot;向&quot;</span>, <span class="hljs-string">&quot;古&quot;</span>, <span class="hljs-string">&quot;易&quot;</span>, <span class="hljs-string">&quot;慎&quot;</span>, <span class="hljs-string">&quot;戈&quot;</span>, <span class="hljs-string">&quot;廖&quot;</span>, <span class="hljs-string">&quot;庚&quot;</span>, <span class="hljs-string">&quot;终&quot;</span>, <span class="hljs-string">&quot;暨&quot;</span>, <span class="hljs-string">&quot;居&quot;</span>, <span class="hljs-string">&quot;衡&quot;</span>, <span class="hljs-string">&quot;步&quot;</span>, <span class="hljs-string">&quot;都&quot;</span>, <span class="hljs-string">&quot;耿&quot;</span>, <span class="hljs-string">&quot;满&quot;</span>, <span class="hljs-string">&quot;弘&quot;</span>, <span class="hljs-string">&quot;匡&quot;</span>, <span class="hljs-string">&quot;国&quot;</span>, <span class="hljs-string">&quot;文&quot;</span>, <span class="hljs-string">&quot;寇&quot;</span>,                    <span class="hljs-string">&quot;广&quot;</span>,                    <span class="hljs-string">&quot;禄&quot;</span>, <span class="hljs-string">&quot;阙&quot;</span>, <span class="hljs-string">&quot;东&quot;</span>, <span class="hljs-string">&quot;殴&quot;</span>, <span class="hljs-string">&quot;殳&quot;</span>, <span class="hljs-string">&quot;沃&quot;</span>, <span class="hljs-string">&quot;利&quot;</span>, <span class="hljs-string">&quot;蔚&quot;</span>, <span class="hljs-string">&quot;越&quot;</span>, <span class="hljs-string">&quot;夔&quot;</span>, <span class="hljs-string">&quot;隆&quot;</span>, <span class="hljs-string">&quot;师&quot;</span>, <span class="hljs-string">&quot;巩&quot;</span>, <span class="hljs-string">&quot;厍&quot;</span>, <span class="hljs-string">&quot;聂&quot;</span>, <span class="hljs-string">&quot;晁&quot;</span>, <span class="hljs-string">&quot;勾&quot;</span>, <span class="hljs-string">&quot;敖&quot;</span>, <span class="hljs-string">&quot;融&quot;</span>, <span class="hljs-string">&quot;冷&quot;</span>,                    <span class="hljs-string">&quot;訾&quot;</span>,                    <span class="hljs-string">&quot;辛&quot;</span>, <span class="hljs-string">&quot;阚&quot;</span>, <span class="hljs-string">&quot;那&quot;</span>, <span class="hljs-string">&quot;简&quot;</span>, <span class="hljs-string">&quot;饶&quot;</span>, <span class="hljs-string">&quot;空&quot;</span>, <span class="hljs-string">&quot;曾&quot;</span>, <span class="hljs-string">&quot;毋&quot;</span>, <span class="hljs-string">&quot;沙&quot;</span>, <span class="hljs-string">&quot;乜&quot;</span>, <span class="hljs-string">&quot;养&quot;</span>, <span class="hljs-string">&quot;鞠&quot;</span>, <span class="hljs-string">&quot;须&quot;</span>, <span class="hljs-string">&quot;丰&quot;</span>, <span class="hljs-string">&quot;巢&quot;</span>, <span class="hljs-string">&quot;关&quot;</span>, <span class="hljs-string">&quot;蒯&quot;</span>, <span class="hljs-string">&quot;相&quot;</span>, <span class="hljs-string">&quot;查&quot;</span>, <span class="hljs-string">&quot;后&quot;</span>,                    <span class="hljs-string">&quot;荆&quot;</span>, <span class="hljs-string">&quot;红&quot;</span>, <span class="hljs-string">&quot;游&quot;</span>, <span class="hljs-string">&quot;竺&quot;</span>, <span class="hljs-string">&quot;权&quot;</span>, <span class="hljs-string">&quot;逯&quot;</span>, <span class="hljs-string">&quot;盖&quot;</span>, <span class="hljs-string">&quot;益&quot;</span>, <span class="hljs-string">&quot;岳&quot;</span>, <span class="hljs-string">&quot;帅&quot;</span>, <span class="hljs-string">&quot;缑&quot;</span>, <span class="hljs-string">&quot;亢&quot;</span>, <span class="hljs-string">&quot;况&quot;</span>, <span class="hljs-string">&quot;后&quot;</span>, <span class="hljs-string">&quot;有&quot;</span>, <span class="hljs-string">&quot;琴&quot;</span>, <span class="hljs-string">\]</span>LAST<span class="hljs-string">\_NAME\_TABLE</span> = <span class="hljs-string">\[&quot;小明&quot;,</span> <span class="hljs-string">&quot;红&quot;</span>, <span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-string">&quot;国强&quot;</span>, <span class="hljs-string">&quot;建国&quot;</span>, <span class="hljs-string">&quot;军&quot;</span>, <span class="hljs-string">&quot;波&quot;</span>, <span class="hljs-string">&quot;良&quot;</span>, <span class="hljs-string">&quot;小芳&quot;</span>, <span class="hljs-string">&quot;芳&quot;</span>, <span class="hljs-string">&quot;燕&quot;</span>, <span class="hljs-string">&quot;敏&quot;</span>, <span class="hljs-string">&quot;小敏&quot;</span>, <span class="hljs-string">&quot;文明&quot;</span>, <span class="hljs-string">&quot;建军&quot;</span>, <span class="hljs-string">&quot;文&quot;</span>, <span class="hljs-string">&quot;平&quot;</span>, <span class="hljs-string">&quot;之明&quot;</span>,                   <span class="hljs-string">&quot;小燕&quot;</span>, <span class="hljs-string">&quot;英&quot;</span>,                   <span class="hljs-string">&quot;轩懿&quot;</span>, <span class="hljs-string">&quot;伟烨&quot;</span>, <span class="hljs-string">&quot;博苑&quot;</span>, <span class="hljs-string">&quot;泽伟&quot;</span>, <span class="hljs-string">&quot;彤熠&quot;</span>, <span class="hljs-string">&quot;煊鸿&quot;</span>, <span class="hljs-string">&quot;涛博&quot;</span>, <span class="hljs-string">&quot;霖烨&quot;</span>, <span class="hljs-string">&quot;华 烨&quot;</span>, <span class="hljs-string">&quot;祺煜&quot;</span>, <span class="hljs-string">&quot;宸智&quot;</span>, <span class="hljs-string">&quot;豪正&quot;</span>, <span class="hljs-string">&quot;然昊&quot;</span>, <span class="hljs-string">&quot;杰明&quot;</span>, <span class="hljs-string">&quot;诚立&quot;</span>, <span class="hljs-string">&quot;轩立&quot;</span>,                   <span class="hljs-string">&quot;辉立&quot;</span>, <span class="hljs-string">&quot;熙峻&quot;</span>,                   <span class="hljs-string">&quot;文弘&quot;</span>, <span class="hljs-string">&quot;彤熠&quot;</span>, <span class="hljs-string">&quot;煊鸿&quot;</span>, <span class="hljs-string">&quot;霖烨&quot;</span>, <span class="hljs-string">&quot;瀚哲&quot;</span>, <span class="hljs-string">&quot;鹏鑫&quot;</span>, <span class="hljs-string">&quot;远致&quot;</span>, <span class="hljs-string">&quot;驰俊&quot;</span>, <span class="hljs-string">&quot;泽雨&quot;</span>, <span class="hljs-string">&quot;磊烨&quot;</span>, <span class="hljs-string">&quot;睿晟&quot;</span>, <span class="hljs-string">&quot;佑天&quot;</span>, <span class="hljs-string">&quot;昊文&quot;</span>, <span class="hljs-string">&quot;洁修&quot;</span>, <span class="hljs-string">&quot;昕黎&quot;</span>, <span class="hljs-string">&quot;航远&quot;</span>,                   <span class="hljs-string">&quot;尧旭&quot;</span>, <span class="hljs-string">&quot;涛鸿&quot;</span>,                   <span class="hljs-string">&quot;祺伟&quot;</span>, <span class="hljs-string">&quot;轩荣&quot;</span>, <span class="hljs-string">&quot;泽越&quot;</span>, <span class="hljs-string">&quot;宇浩&quot;</span>, <span class="hljs-string">&quot;瑜瑾&quot;</span>, <span class="hljs-string">&quot;轩皓&quot;</span>, <span class="hljs-string">&quot;苍擎&quot;</span>, <span class="hljs-string">&quot;宇擎&quot;</span>, <span class="hljs-string">&quot;泽志&quot;</span>, <span class="hljs-string">&quot;渊睿&quot;</span>, <span class="hljs-string">&quot;瑞楷&quot;</span>, <span class="hljs-string">&quot;轩子&quot;</span>, <span class="hljs-string">&quot;文弘&quot;</span>, <span class="hljs-string">&quot;瀚哲&quot;</span>, <span class="hljs-string">&quot;泽雨&quot;</span>, <span class="hljs-string">&quot;磊鑫&quot;</span>,                   <span class="hljs-string">&quot;杰修&quot;</span>, <span class="hljs-string">&quot;诚伟&quot;</span>,                   <span class="hljs-string">&quot;辉建&quot;</span>, <span class="hljs-string">&quot;鹏晋&quot;</span>, <span class="hljs-string">&quot;磊天&quot;</span>, <span class="hljs-string">&quot;辉绍&quot;</span>, <span class="hljs-string">&quot;洋泽&quot;</span>, <span class="hljs-string">&quot;轩明&quot;</span>, <span class="hljs-string">&quot;柏健&quot;</span>, <span class="hljs-string">&quot;煊鹏&quot;</span>, <span class="hljs-string">&quot;强昊&quot;</span>, <span class="hljs-string">&quot;宸伟&quot;</span>, <span class="hljs-string">&quot;超博&quot;</span>, <span class="hljs-string">&quot;浩君&quot;</span>, <span class="hljs-string">&quot;骞子&quot;</span>, <span class="hljs-string">&quot;辉明&quot;</span>, <span class="hljs-string">&quot;涛鹏&quot;</span>, <span class="hljs-string">&quot;彬炎&quot;</span>,                   <span class="hljs-string">&quot;轩鹤&quot;</span>, <span class="hljs-string">&quot;彬越&quot;</span>,                   <span class="hljs-string">&quot;华风&quot;</span>, <span class="hljs-string">&quot;琪靖&quot;</span>, <span class="hljs-string">&quot;诚明&quot;</span>, <span class="hljs-string">&quot;格高&quot;</span>, <span class="hljs-string">&quot;华光&quot;</span>, <span class="hljs-string">&quot;源国&quot;</span>, <span class="hljs-string">&quot;宇冠&quot;</span>, <span class="hljs-string">&quot;昱晗&quot;</span>, <span class="hljs-string">&quot;润涵&quot;</span>, <span class="hljs-string">&quot;飞翰&quot;</span>, <span class="hljs-string">&quot;海翰&quot;</span>, <span class="hljs-string">&quot;乾昊&quot;</span>, <span class="hljs-string">&quot;博浩&quot;</span>, <span class="hljs-string">&quot;安和&quot;</span>, <span class="hljs-string">&quot;博弘&quot;</span>, <span class="hljs-string">&quot;恺宏&quot;</span>,                   <span class="hljs-string">&quot;朗鸿&quot;</span>, <span class="hljs-string">&quot;奥华&quot;</span>,                   <span class="hljs-string">&quot;灿华&quot;</span>, <span class="hljs-string">&quot;慕嘉&quot;</span>, <span class="hljs-string">&quot;秉坚&quot;</span>, <span class="hljs-string">&quot;明建&quot;</span>, <span class="hljs-string">&quot;鑫金&quot;</span>, <span class="hljs-string">&quot;程锦&quot;</span>, <span class="hljs-string">&quot;瑜瑾&quot;</span>, <span class="hljs-string">&quot;鹏晋&quot;</span>, <span class="hljs-string">&quot;赋经&quot;</span>, <span class="hljs-string">&quot;同景&quot;</span>, <span class="hljs-string">&quot;琪靖&quot;</span>, <span class="hljs-string">&quot;昊君&quot;</span>, <span class="hljs-string">&quot;明俊&quot;</span>, <span class="hljs-string">&quot;同季&quot;</span>, <span class="hljs-string">&quot;济开&quot;</span>, <span class="hljs-string">&quot;安凯&quot;</span>,                   <span class="hljs-string">&quot;成康&quot;</span>, <span class="hljs-string">&quot;语乐&quot;</span>,                   <span class="hljs-string">&quot;勤力&quot;</span>, <span class="hljs-string">&quot;哲良&quot;</span>, <span class="hljs-string">&quot;群理&quot;</span>, <span class="hljs-string">&quot;彦茂&quot;</span>, <span class="hljs-string">&quot;博敏&quot;</span>, <span class="hljs-string">&quot;达明&quot;</span>, <span class="hljs-string">&quot;义朋&quot;</span>, <span class="hljs-string">&quot;泽彭&quot;</span>, <span class="hljs-string">&quot;举鹏&quot;</span>, <span class="hljs-string">&quot;存濮&quot;</span>, <span class="hljs-string">&quot;心溥&quot;</span>, <span class="hljs-string">&quot;瑜璞&quot;</span>, <span class="hljs-string">&quot;泽浦&quot;</span>, <span class="hljs-string">&quot;邃奇&quot;</span>, <span class="hljs-string">&quot;祥祺&quot;</span>, <span class="hljs-string">&quot;轩荣&quot;</span>,                   <span class="hljs-string">&quot;达锐&quot;</span>, <span class="hljs-string">&quot;慈睿&quot;</span>,                   <span class="hljs-string">&quot;祺绍&quot;</span>, <span class="hljs-string">&quot;杰圣&quot;</span>, <span class="hljs-string">&quot;睿晟&quot;</span>, <span class="hljs-string">&quot;源思&quot;</span>, <span class="hljs-string">&quot;年斯&quot;</span>, <span class="hljs-string">&quot;宁泰&quot;</span>, <span class="hljs-string">&quot;佑天&quot;</span>, <span class="hljs-string">&quot;巍同&quot;</span>, <span class="hljs-string">&quot;伟奕&quot;</span>, <span class="hljs-string">&quot;温祺&quot;</span>, <span class="hljs-string">&quot;虹文&quot;</span>, <span class="hljs-string">&quot;笛向&quot;</span>, <span class="hljs-string">&quot;远心&quot;</span>, <span class="hljs-string">&quot;德欣&quot;</span>, <span class="hljs-string">&quot;翰新&quot;</span>, <span class="hljs-string">&quot;言兴&quot;</span>,                   <span class="hljs-string">&quot;阑星&quot;</span>, <span class="hljs-string">&quot;为修&quot;</span>,                   <span class="hljs-string">&quot;尧旭&quot;</span>, <span class="hljs-string">&quot;明炫&quot;</span>, <span class="hljs-string">&quot;真学&quot;</span>, <span class="hljs-string">&quot;风雪&quot;</span>, <span class="hljs-string">&quot;昶雅&quot;</span>, <span class="hljs-string">&quot;曦阳&quot;</span>, <span class="hljs-string">&quot;熠烨&quot;</span>, <span class="hljs-string">&quot;韶英&quot;</span>, <span class="hljs-string">&quot;贞永&quot;</span>, <span class="hljs-string">&quot;德咏&quot;</span>, <span class="hljs-string">&quot;寰宇&quot;</span>, <span class="hljs-string">&quot;泽雨&quot;</span>, <span class="hljs-string">&quot;韵玉&quot;</span>, <span class="hljs-string">&quot;彬越&quot;</span>, <span class="hljs-string">&quot;和蕴&quot;</span>, <span class="hljs-string">&quot;彦哲&quot;</span>,                   <span class="hljs-string">&quot;海振&quot;</span>, <span class="hljs-string">&quot;志正&quot;</span>,                   <span class="hljs-string">&quot;晋子&quot;</span><span class="hljs-string">\]</span></code></pre><p>然后是城市列表，因为，根据概率论，如果我们不加权的话，最后，随着数据的增加，我们的结果会南辕北辙。所以，我用了最简单的加权方法：直接列表里面的地名按照个数比来加权：</p><pre><code class="hljs ini"><span class="hljs-attr">CITY_TABLE</span> = \[<span class="hljs-string">&quot;福州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;南平&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;福清&quot;</span>, <span class="hljs-string">&quot;宁德&quot;</span>,              <span class="hljs-string">&quot;莆田&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>,              <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;福州&quot;</span>, <span class="hljs-string">&quot;福州&quot;</span>, <span class="hljs-string">&quot;福州&quot;</span>, <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>\]</code></pre><p>注意到了没：几个城市的数目是成比例的，为了随机数产生的时候，按照一定的比例。当然，这是很不科学的，但是因为是简单入门案例，所以我这里用了模拟数据。</p><pre><code class="hljs ini"><span class="hljs-attr">SEX_TABLE</span> = \[<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>\]<span class="hljs-attr">EXCEL_PATH</span> = <span class="hljs-string">&quot;../temp/sheet.xls&quot;</span><span class="hljs-attr">SHOPPING_COUNT</span> = <span class="hljs-number">100</span></code></pre><p>上面是一些常量，相信大家可以看得懂</p><p>最后，附上项目目录：</p><p><img src="https://static.oschina.net/uploads/space/2016/1124/174358_qyAF_2702126.png" alt=""></p><p>好了，直接看代码：</p><p>首先是，数据分析工具模块：</p><pre><code class="hljs livescript"><span class="hljs-comment"># coding=&#x27;utf-8&#x27;</span><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> app.my_utils.paraments <span class="hljs-keyword">as</span> paradef create<span class="hljs-string">\_shopping\_list():</span>    res = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 假设购买了100件商品</span>        res += str(random.randint(<span class="hljs-number">1</span>, para.SHOPPING_COUNT)) + <span class="hljs-string">&quot;,&quot;</span>    <span class="hljs-keyword">return</span> resdef create_excel(path):    data_list = <span class="hljs-string">\[\]</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10000</span>):        data_list.append(            <span class="hljs-string">\[random.choice(para.FIRST\_NAME\_TABLE)</span> + random.choice(para.LAST<span class="hljs-string">\_NAME\_TABLE),</span>             random.randint(para.MIN<span class="hljs-string">\_AGE,</span> para.MAX<span class="hljs-string">\_AGE),</span> random.choice(para.CITY_TABLE),             random.choice(para.SEX_TABLE),             create<span class="hljs-string">\_shopping\_list()\])</span>    data<span class="hljs-string">\_array</span> = np.array(data<span class="hljs-string">\_list)</span>    data<span class="hljs-string">\_frame</span> = pd.DataFrame(data=data<span class="hljs-string">\_array,</span> index=None, columns=<span class="hljs-string">\[&quot;name&quot;,</span> <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;city&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;shopping_list&quot;</span><span class="hljs-string">\])</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Start to write data in Excel sheet......&quot;</span>)    data<span class="hljs-string">\_frame.to\_excel(path)</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Excel Write Finished!&quot;</span>)def get_point(path):    <span class="hljs-comment"># \[&quot;福州&quot;, &quot;泉州&quot;, &quot;厦门&quot;, &quot;三明&quot;, &quot;龙岩&quot;, &quot;南平&quot;, &quot;漳州&quot;, &quot;福清&quot;, &quot;宁德&quot;, &quot;莆田&quot;\]</span>    excel = None    fuzhou_num = <span class="hljs-number">0</span>    quanzhou_num = <span class="hljs-number">0</span>    xiamen_num = <span class="hljs-number">0</span>    sanming_num = <span class="hljs-number">0</span>    longyan_num = <span class="hljs-number">0</span>    nanping_num = <span class="hljs-number">0</span>    zhangzhou_num = <span class="hljs-number">0</span>    fuqing_num = <span class="hljs-number">0</span>    ningde_num = <span class="hljs-number">0</span>    putian_num = <span class="hljs-number">0</span>    try:        excel = pd.DataFrame(pd.read_excel(path))    except Exception <span class="hljs-keyword">as</span> e:        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error!&quot;</span>)    finally:        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(excel)):            item = excel.values<span class="hljs-string">\[i\].tolist()</span>            <span class="hljs-keyword">if</span> item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;福州&quot;</span>:                fuzhou_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;泉州&quot;</span>:                quanzhou_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;厦门&quot;</span>:                xiamen_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;三明&quot;</span>:                sanming_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;龙岩&quot;</span>:                longyan_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;南平&quot;</span>:                nanping_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;漳州&quot;</span>:                zhangzhou_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;福清&quot;</span>:                fuqing_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;宁德&quot;</span>:                ningde_num += <span class="hljs-number">1</span>            elif item<span class="hljs-string">\[2\]</span> == <span class="hljs-string">&quot;莆田&quot;</span>:                putian_num += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">\[fuzhou\_num,</span> quanzhou<span class="hljs-string">\_num,</span> xiamen<span class="hljs-string">\_num,</span> sanming<span class="hljs-string">\_num,</span> longyan<span class="hljs-string">\_num,</span> nanping<span class="hljs-string">\_num,</span> zhangzhou<span class="hljs-string">\_num,</span> fuqing<span class="hljs-string">\_num,</span>                ningde<span class="hljs-string">\_num,</span> putian<span class="hljs-string">\_num\]</span><span class="hljs-keyword">if</span> <span class="hljs-string">\_\_name\_\_</span> == <span class="hljs-string">&quot;\_\_main\_\_&quot;</span>:    create<span class="hljs-string">\_excel(para.EXCEL\_PATH)</span>    ll = get<span class="hljs-string">\_point(para.EXCEL\_PATH)</span>    <span class="hljs-built_in">print</span>(ll)</code></pre><p>数据分析模块，是为了产生数据和简单分析数据。</p><p>然后是主模块：</p><pre><code class="hljs livescript"><span class="hljs-comment"># -*-coding:gbk-*-</span><span class="hljs-keyword">import</span> pylabpylab.mpl.rcParams<span class="hljs-string">\[&#x27;font.sans-serif&#x27;\]</span> = <span class="hljs-string">\[&#x27;SimHei&#x27;\]</span>pylab.mpl.rcParams<span class="hljs-string">\[&#x27;axes.unicode_minus&#x27;\]</span> = False<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> app.my_utils.utils <span class="hljs-keyword">as</span> ut<span class="hljs-keyword">import</span> app.my_utils.paraments <span class="hljs-keyword">as</span> paraindex = np.arange(<span class="hljs-number">5</span>)X = <span class="hljs-string">\[1,</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span><span class="hljs-string">\]</span>Y = ut.get<span class="hljs-string">\_point(para.EXCEL\_PATH)</span>plt.title(<span class="hljs-string">&quot;购物数据分析表&quot;</span>)plt.xticks(X, <span class="hljs-string">\[&quot;福州&quot;,</span> <span class="hljs-string">&quot;泉州&quot;</span>, <span class="hljs-string">&quot;厦门&quot;</span>, <span class="hljs-string">&quot;三明&quot;</span>, <span class="hljs-string">&quot;龙岩&quot;</span>, <span class="hljs-string">&quot;南平&quot;</span>, <span class="hljs-string">&quot;漳州&quot;</span>, <span class="hljs-string">&quot;福清&quot;</span>, <span class="hljs-string">&quot;宁德&quot;</span>, <span class="hljs-string">&quot;莆田&quot;</span><span class="hljs-string">\])</span>plt.xlabel(<span class="hljs-string">&quot;福建各个城市名称&quot;</span>)plt.ylabel(<span class="hljs-string">&quot;参加购物人数/城市&quot;</span>, color=<span class="hljs-string">&quot;red&quot;</span>)plt.legend(<span class="hljs-string">\[&quot;人数:&quot;\],</span> loc=<span class="hljs-number">0</span>)plt.bar(X, Y, color=<span class="hljs-string">&quot;green&quot;</span>)plt.show()</code></pre><p>最后，产生一个效果图：</p><p><img src="https://static.oschina.net/uploads/space/2016/1124/174841_ZFEn_2702126.png" alt=""></p><p>哈哈，是不是可以打出：厦门，泉州，漳州人比较有钱？（数据没有说服力，仅仅是测试而已）。</p><p>好了，最简单的入门程序到这里就完了，如果你有兴趣，还可以再深度挖掘：比如，来自福州的男性喜欢购买什么，来自厦门的女性喜欢购买什么等等。</p><p>喜欢的话，欢迎转载。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>numpy</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt5 Http简单应用</title>
    <link href="/2019/11/19/clpqt1iux004d4cue1su1b8tr.html"/>
    <url>/2019/11/19/clpqt1iux004d4cue1su1b8tr.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲Qt5如何通过HTTP协议获取数据</p><span id="more"></span><p>最近这几天，没项目做了，突然想起来，听同学说qt做软件也还是很好玩的，无奈我不会C++ ，只能摸索，本来很简单的一个APP,做了四天，算是基本功能实现了，BUG目前没有。</p><p>总结：C++的学习成本是java的 3倍以上，想学习的可要做好心理准备。我默默的关了IDE，开始学习Java，我就不是一个学习C++的料。</p><p>【里面用到的数据来自<a href="http://www.showapi.com,想使用的，可以去注册申请】">www.showapi.com,想使用的，可以去注册申请】</a></p><p>软件截图：</p><p><img src="https://static.oschina.net/uploads/space/2017/0506/224909_ySNe_2702126.png" alt=""></p><p>这个简单的应用使用Qt5写的，目的为了学习QT的Http和JSON解析相关知识。</p><p>项目结构：</p><p><img src="https://static.oschina.net/uploads/space/2017/0506/225020_mQMw_2702126.png" alt=""></p><p>chartitem.h</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CHARTITEM_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHARTITEM_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QGraphicsItem&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChartItem</span> :</span> <span class="hljs-keyword">public</span> QGraphicsItem&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">ChartItem</span>();    <span class="hljs-built_in">ChartItem</span>(QString title, <span class="hljs-keyword">double</span> level  );    <span class="hljs-function">QRectF <span class="hljs-title">boundingRect</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(QPainter *painter,<span class="hljs-keyword">const</span> QStyleOptionGraphicsItem *option,</span></span><span class="hljs-params"><span class="hljs-function">               QWidget *widget)</span></span>;<span class="hljs-keyword">private</span>:    QString title;    <span class="hljs-keyword">double</span> level ;    <span class="hljs-keyword">long</span> heat;    <span class="hljs-keyword">int</span> trend;    <span class="hljs-keyword">int</span> xPos, yPos;    <span class="hljs-keyword">int</span> r ;    <span class="hljs-keyword">int</span> g ;    <span class="hljs-keyword">int</span> b ;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// CHARTITEM_H</span></span></code></pre><p>mainwindow.h</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAINWINDOW_H</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QGraphicsScene&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QString&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtScript/QScriptEngine&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QNetworkAccessManager&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QTextCodec&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QNetworkReply&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QNetworkRequest&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QUrl&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPaintEvent&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QAction&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMenu&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMenuBar&gt;</span></span><span class="hljs-keyword">namespace</span> Ui &#123;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow&#123;    Q_OBJECT<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MainWindow</span><span class="hljs-params">(QWidget *parent = <span class="hljs-number">0</span>)</span></span>;    ~<span class="hljs-built_in">MainWindow</span>();<span class="hljs-keyword">private</span> slots:    <span class="hljs-function">QString <span class="hljs-title">replyFinished</span><span class="hljs-params">(QNetworkReply *reply)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">about</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">help</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:    QNetworkAccessManager *manager;    QString urlString=<span class="hljs-string">&quot;http://route.showapi.com/307-2?showapi_appid=showAPI APP ID&amp;showapi_sign=秘钥&amp;subjectId=%2&amp;branchId=%3&amp;showapi_timestamp=%4&quot;</span>;    Ui::MainWindow *ui;    QGraphicsScene *scene;    QString originId;    QString subjectId;    QString branchId;    QMenu *menu;    QAction *aboutAction;    QAction *helpAction;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// MAINWINDOW_H</span></span></code></pre><p>chartitem.cpp</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;chartitem.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPainter&gt;</span></span>ChartItem::<span class="hljs-built_in">ChartItem</span>()&#123;&#125;ChartItem::<span class="hljs-built_in">ChartItem</span>(QString title, <span class="hljs-keyword">double</span> level)&#123;     r=<span class="hljs-built_in">qrand</span>() % <span class="hljs-number">255</span>;     g=<span class="hljs-built_in">qrand</span>() % <span class="hljs-number">255</span>;     b=<span class="hljs-built_in">qrand</span>() % <span class="hljs-number">255</span>;    <span class="hljs-keyword">this</span>-&gt;title=title;    <span class="hljs-keyword">this</span>-&gt;level=level;&#125;<span class="hljs-function">QRectF <span class="hljs-title">ChartItem::boundingRect</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-built_in">QRectF</span>(<span class="hljs-number">-5</span>,<span class="hljs-number">-5</span>, <span class="hljs-number">60</span>, <span class="hljs-number">20</span>+<span class="hljs-keyword">this</span>-&gt;level*<span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChartItem::paint</span><span class="hljs-params">(QPainter *painter, <span class="hljs-keyword">const</span> QStyleOptionGraphicsItem *option, QWidget *widget)</span></span><span class="hljs-function"></span>&#123;    painter-&gt;<span class="hljs-built_in">setBrush</span>(<span class="hljs-built_in">QColor</span>(r,g,b));    painter-&gt;<span class="hljs-built_in">drawText</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>-&gt;title);    painter-&gt;<span class="hljs-built_in">drawRect</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">50</span>,<span class="hljs-keyword">this</span>-&gt;level*<span class="hljs-number">2</span>);    painter-&gt;<span class="hljs-built_in">drawText</span>(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>+<span class="hljs-keyword">this</span>-&gt;level*<span class="hljs-number">2</span>, QString::<span class="hljs-built_in">number</span>( <span class="hljs-keyword">this</span>-&gt;level));&#125;</code></pre><p>mainwindow.cpp</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDebug&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QUrl&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDateTime&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMessageBox&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QJsonDocument&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QJsonObject&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QJsonArray&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QJsonParseError&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPen&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPainter&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;chartitem.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;chartdir.h&quot;</span></span>MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent) :    <span class="hljs-built_in">QMainWindow</span>(parent),    <span class="hljs-built_in">ui</span>(<span class="hljs-keyword">new</span> Ui::MainWindow)&#123;    ui-&gt;<span class="hljs-built_in">setupUi</span>(<span class="hljs-keyword">this</span>);    ui-&gt;titleLabel-&gt;<span class="hljs-built_in">setAlignment</span>(Qt::AlignCenter);    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setFixedSize</span>(<span class="hljs-number">684</span>,<span class="hljs-number">426</span>);    scene = <span class="hljs-keyword">new</span> QGraphicsScene;    helpAction=<span class="hljs-keyword">new</span> <span class="hljs-built_in">QAction</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;操作帮助&quot;</span>), <span class="hljs-keyword">this</span>);    aboutAction=<span class="hljs-keyword">new</span> <span class="hljs-built_in">QAction</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;作者信息&quot;</span>), <span class="hljs-keyword">this</span>);    <span class="hljs-built_in">connect</span>(helpAction, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">triggered</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">help</span>()));    <span class="hljs-built_in">connect</span>(aboutAction, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">triggered</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">about</span>()));    menu = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">menuBar</span>()-&gt;<span class="hljs-built_in">addMenu</span>(<span class="hljs-built_in">tr</span>(<span class="hljs-string">&quot;菜单&quot;</span>));    menu-&gt;<span class="hljs-built_in">addAction</span>(helpAction);    menu-&gt;<span class="hljs-built_in">addAction</span>(aboutAction);    manager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QNetworkAccessManager</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-built_in">connect</span>(ui-&gt;searchButton,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">clicked</span>()),<span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">getData</span>()));    <span class="hljs-built_in">connect</span>(manager,<span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">finished</span>(QNetworkReply*)), <span class="hljs-keyword">this</span>,<span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">replyFinished</span>(QNetworkReply*)));&#125;MainWindow::~<span class="hljs-built_in">MainWindow</span>()&#123;    <span class="hljs-keyword">delete</span> ui;&#125;<span class="hljs-function">QString <span class="hljs-title">MainWindow::replyFinished</span><span class="hljs-params">(QNetworkReply *reply)</span></span><span class="hljs-function"></span>&#123;    QJsonParseError error;    QJsonDocument jsonDocument = QJsonDocument::<span class="hljs-built_in">fromJson</span>(reply-&gt;<span class="hljs-built_in">readAll</span>(),&amp;error);    QJsonObject apiRootObj= jsonDocument.<span class="hljs-built_in">object</span>();    QJsonObject apiBodyObj= apiRootObj[<span class="hljs-string">&quot;showapi_res_body&quot;</span>].<span class="hljs-built_in">toObject</span>();    QJsonArray dataArray= apiBodyObj[<span class="hljs-string">&quot;list&quot;</span>].<span class="hljs-built_in">toArray</span>();    <span class="hljs-keyword">if</span>(!dataArray.<span class="hljs-built_in">isEmpty</span>())&#123;        scene-&gt;<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;dataArray.<span class="hljs-built_in">size</span>();i++)&#123;            QJsonObject obj = dataArray.<span class="hljs-built_in">at</span>(i).<span class="hljs-built_in">toObject</span>();            QString title=obj.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;title&quot;</span>).<span class="hljs-built_in">toString</span>();            <span class="hljs-keyword">double</span> level =obj.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;level&quot;</span>).<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">toDouble</span>();            ChartItem *item=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ChartItem</span>(title,  level );            item-&gt;<span class="hljs-built_in">setPos</span>( i*<span class="hljs-number">90</span>,<span class="hljs-number">20</span>);            scene-&gt;<span class="hljs-built_in">addItem</span>(item);        &#125;        ui-&gt;chartView-&gt;<span class="hljs-built_in">setScene</span>(scene);    &#125;<span class="hljs-keyword">else</span> &#123;        QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示！&quot;</span>,<span class="hljs-string">&quot;当前暂时没有数据\n请认真查看专业是否和科目对应!&quot;</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::getData</span><span class="hljs-params">()</span></span>&#123;    QString queryUrl=urlString.<span class="hljs-built_in">arg</span>(ui-&gt;originBox-&gt;<span class="hljs-built_in">currentText</span>())            .<span class="hljs-built_in">arg</span>(ui-&gt;subjectBox-&gt;<span class="hljs-built_in">currentText</span>())            .<span class="hljs-built_in">arg</span>(ui-&gt;branchBox-&gt;<span class="hljs-built_in">currentText</span>())            .<span class="hljs-built_in">arg</span>(QDateTime::<span class="hljs-built_in">currentDateTime</span>().<span class="hljs-built_in">toString</span>(<span class="hljs-string">&quot;yyyyMMddHHmmss&quot;</span>));    manager-&gt;<span class="hljs-built_in">get</span>(<span class="hljs-built_in">QNetworkRequest</span>(<span class="hljs-built_in">QUrl</span>(queryUrl)));&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::help</span><span class="hljs-params">()</span></span>&#123;    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;帮助信息！&quot;</span>,<span class="hljs-string">&quot;注意:\n1.软件所有数据来源于网络，仅仅具有参考性;\n2.文科、理科要选择正确，否则没有数据。\n3.软件作为学习交流使用，任何人都可以拿去玩。&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::about</span><span class="hljs-params">()</span></span>&#123;    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;关于软件！&quot;</span>,<span class="hljs-string">&quot;版本 1.0\n作者：gnik\n极光工作室出品\nwww.plstudio.xyz&quot;</span>);&#125;</code></pre><p>最后是main.cpp</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QApplication&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    MainWindow w;    w.<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java回调写法实践</title>
    <link href="/2019/11/19/clpqt1iuw00484cuean6nf2cq.html"/>
    <url>/2019/11/19/clpqt1iuw00484cuean6nf2cq.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：快速实现一个Http回调组件-&gt;</p><span id="more"></span><h1 id="快速实现一个Http回调组件"><a href="#快速实现一个Http回调组件" class="headerlink" title="快速实现一个Http回调组件"></a>快速实现一个Http回调组件</h1><h2 id="一、前情回顾"><a href="#一、前情回顾" class="headerlink" title="一、前情回顾"></a>一、前情回顾</h2><blockquote><p>​     我们平时在使用一些库的时候，会遇到一些看起来很舒服的写法，用起来感觉很简单，而且写法也很优雅，比如OkHttp，或者是Java Swing的事件模式。</p><p>​    我们先看看Java的事件是怎么写的：</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;JFrame jf = <span class="hljs-keyword">new</span> JFrame(<span class="hljs-string">&quot;事件监听测试&quot;</span>);jf.setVisible(<span class="hljs-keyword">true</span>);jf.setSize(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);JButton jb = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;触发事件&quot;</span>);jf.add(jb);jb.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;<span class="hljs-comment">// 进行逻辑处理即可</span>System.out.println(<span class="hljs-string">&quot;触发了事件&quot;</span>);&#125;&#125;);&#125;</code></pre><blockquote><p>​    我们看到Swing的写法是直接给组件添加了一个监听器，然后回调里面的参数，这种写法看起来仿佛就是组件自带了某种动作一样。</p><p>​    我们接下来也实现一个简单的Http get请求回调。</p></blockquote><h2 id="二、组件设计"><a href="#二、组件设计" class="headerlink" title="二、组件设计"></a>二、组件设计</h2><h3 id="1-回调接口"><a href="#1-回调接口" class="headerlink" title="1.回调接口"></a>1.回调接口</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String result)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onException</span><span class="hljs-params">(Exception e)</span></span>;&#125;</code></pre><h3 id="2-处理器"><a href="#2-处理器" class="headerlink" title="2.处理器"></a>2.处理器</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.net.HttpURLConnection;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestProxy</span> </span>&#123;    <span class="hljs-keyword">private</span> HttpRequestHandler httpRequestHandler;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestProxy</span><span class="hljs-params">(HttpRequestHandler httpRequestHandler)</span> </span>&#123;        <span class="hljs-keyword">this</span>.httpRequestHandler = httpRequestHandler;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 模拟GET</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> urlString</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String urlString)</span> </span>&#123;        HttpURLConnection connection = <span class="hljs-keyword">null</span>;        InputStream is = <span class="hljs-keyword">null</span>;        BufferedReader br = <span class="hljs-keyword">null</span>;        String result = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 返回结果字符串</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 创建远程url连接对象</span>            URL url = <span class="hljs-keyword">new</span> URL(urlString);            <span class="hljs-comment">// 通过远程url连接对象打开一个连接，强转成httpURLConnection类</span>            connection = (HttpURLConnection) url.openConnection();            <span class="hljs-comment">// 设置连接方式：get</span>            connection.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);            <span class="hljs-comment">// 设置连接主机服务器的超时时间：15000毫秒</span>            connection.setConnectTimeout(<span class="hljs-number">15000</span>);            <span class="hljs-comment">// 设置读取远程返回的数据时间：60000毫秒</span>            connection.setReadTimeout(<span class="hljs-number">60000</span>);            <span class="hljs-comment">// 发送请求</span>            connection.connect();            <span class="hljs-comment">// 通过connection连接，获取输入流</span>            <span class="hljs-keyword">if</span> (connection.getResponseCode() == <span class="hljs-number">200</span>) &#123;                is = connection.getInputStream();                <span class="hljs-comment">// 封装输入流is，并指定字符集</span>                br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is, <span class="hljs-string">&quot;UTF-8&quot;</span>));                <span class="hljs-comment">// 存放数据</span>                StringBuffer sbf = <span class="hljs-keyword">new</span> StringBuffer();                String temp;                <span class="hljs-keyword">while</span> ((temp = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;                    sbf.append(temp);                    sbf.append(<span class="hljs-string">&quot;\r\n&quot;</span>);                &#125;                result = sbf.toString();                <span class="hljs-keyword">this</span>.httpRequestHandler.onSuccess(result);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">this</span>.httpRequestHandler.onException(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">// 关闭资源</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != br) &#123;                <span class="hljs-keyword">try</span> &#123;                    br.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != is) &#123;                <span class="hljs-keyword">try</span> &#123;                    is.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            <span class="hljs-keyword">assert</span> connection != <span class="hljs-keyword">null</span>;            connection.disconnect();<span class="hljs-comment">// 关闭远程连接</span>        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h3 id="3-调用"><a href="#3-调用" class="headerlink" title="3.调用"></a>3.调用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> HttpRequestProxy(<span class="hljs-keyword">new</span> HttpRequestHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String result)</span> </span>&#123;                System.out.println(result);            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onException</span><span class="hljs-params">(Exception e)</span> </span>&#123;                e.printStackTrace();            &#125;        &#125;).get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8Lambda表达式写法</title>
    <link href="/2019/11/19/clpqt1iuv00434cue92v7000s.html"/>
    <url>/2019/11/19/clpqt1iuv00434cue92v7000s.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：Java8的lambda的简单实践</p><span id="more"></span><pre><code>java8支持lambda表达式，常见的一些操作都可以通过lambda来实现，比如遍历List，或者是实现某个事件接口，还有我们熟悉的Swing的事件，如下案例所示：</code></pre><pre><code class="hljs java"><span class="hljs-comment">// Java 8之前：</span>JButton b1=  <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;BeforeJava8&quot;</span>);b.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;    System.out.println(<span class="hljs-string">&quot;Button push&quot;</span>);    &#125;&#125;);<span class="hljs-comment">// Java 8方式：</span>JButton b2=  <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;Java8&quot;</span>);b2.addActionListener((e) -&gt; &#123;    System.out.println(<span class="hljs-string">&quot;Button push&quot;</span>);&#125;);</code></pre><pre><code>有时候我们比较迷惑：Java明明是OOP语言，Lambda表达式岂不是破坏了OOP的封装特性？实则不然，Lambda其实是用接口实现的，而这个接口只有一个方法。我们看下面的案例：</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wangwenhai</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrintHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, PrintHandler printHandler)</span> </span>&#123;        printHandler.print(array);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> array[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;        print(array, <span class="hljs-keyword">new</span> PrintHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;                    System.out.println(<span class="hljs-string">&quot;数组:&quot;</span> + i);                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre><p>这是一个简单的遍历数组的写法，通过传一个接口进去，然后用户去实现具体的遍历方法，上面看上去是一个很普通的匿名接口实现，但是如果我们用了Java8以后，这段代码会变得更加精简：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wangwenhai</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PrintHandler</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, PrintHandler printHandler)</span> </span>&#123;        printHandler.print(array);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;        print(array, array1 -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) &#123;                System.out.println(<span class="hljs-string">&quot;数组:&quot;</span> + i);            &#125;        &#125;);    &#125;&#125;</code></pre><pre><code>大家也许已经注意到了，此处的匿名接口实现不见了，仿佛出现了一段从没见过的代码，其实这就是Java8的lambda的实现：</code></pre><pre><code class="hljs java">print(array, array1 -&gt; &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) &#123;        System.out.println(<span class="hljs-string">&quot;数组:&quot;</span> + i);    &#125;&#125;);</code></pre><pre><code>其中array1是传给接口的参数，在这里直接省略了接口的实现过程，因为就一个方法，所以这个参数直接被传进print方法里面。我们用个图来表示从OOP到FP（函数式编程）的过程。</code></pre><p><img src="https://oscimg.oschina.net/oscnet/2f08422ddd760c12aafcfc9e784d5c1e2db.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网终端设计</title>
    <link href="/2019/11/19/clpqt1iwc00ab4cue5o04bdqf.html"/>
    <url>/2019/11/19/clpqt1iwc00ab4cue5o04bdqf.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：物联网设备终端硬件设计思路。</p><span id="more"></span><h1 id="一、-硬件概述"><a href="#一、-硬件概述" class="headerlink" title="一、 硬件概述"></a>一、 硬件概述</h1><h2 id="1-终端节点设备设计背景"><a href="#1-终端节点设备设计背景" class="headerlink" title="1. 终端节点设备设计背景"></a>1. 终端节点设备设计背景</h2><p>Esp8266成本非常低内置TCP/IP协议栈和WLAN可以通过arduino IDE、lua脚本开发，目前物联网的软件开发非常的破碎，也没有统一的数据传输模式，我们通过arduino IDE开发的easyiot_cli框架可以通过简单地命令配置接入后台内部包含有mqtt、tcp/ip、udp、coap等常见协议。简化物联网开发流程降低开发难度。</p><p>硬件部分采用esp8266，使用easyiot_cli作为基础可拓展的嵌入式程序，适配DHT11、OLED、LED、蜂鸣器，可拓展使用I/O的外设。基础架构如图1所示。</p><p><img src="/uploads/wps1.jpg" alt="img"></p><p>图一</p><h2 id="2-整体架构"><a href="#2-整体架构" class="headerlink" title="2. 整体架构"></a>2. 整体架构</h2><p>未来通过嵌入式系统的开发和移植，实现多设备统一标准开发如图二所示，以RTOS为容器开发硬件接口实现外设驱动，内部通过移植mqtt等协议栈实现通信，对用户层暴露一定的硬件接口完成用户逻辑，尽量抽象化，使用户通过实现接口完成自己需要的业务代码。如有必要可以增加显示设备，如无必要勿增实体。<img src="/uploads/wps2.jpg" alt="img"></p><p>图二</p><h3 id="3-商业鉴权"><a href="#3-商业鉴权" class="headerlink" title="3. 商业鉴权"></a>3. 商业鉴权</h3><p>商业版在代码核心中增加uuid，通过在服务端注册实现鉴权。</p><h3 id="4-网关设计"><a href="#4-网关设计" class="headerlink" title="4. 网关设计"></a>4. 网关设计</h3><p>通过嵌入式操作系统结合多种通信模块实现网关对终端节点的管理，通过与云服务器通信实现网关节点命令下发、数据采集、状态查询等任务。在应对密集设备环境下通过此架构可以降低决服务器载荷，节省硬件设备资源。架构如图三所示</p><p><img src="/uploads/wps3-1574158407191.png" alt="img"></p><p>图三</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web模拟终端设计</title>
    <link href="/2019/11/19/clpqt1iwa00a54cue9ljp6smq.html"/>
    <url>/2019/11/19/clpqt1iwa00a54cue9ljp6smq.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：准备结合MQTT协议做一个Web Terminal，功能就是通过外网管理内网Linux主机或者运行Linux的设备。</p><span id="more"></span><h1 id="WebTerminal功能设计"><a href="#WebTerminal功能设计" class="headerlink" title="WebTerminal功能设计"></a>WebTerminal功能设计</h1><p>准备结合MQTT协议做一个Web Terminal，功能就是通过外网管理内网Linux主机或者运行Linux的设备。</p><p>效果图如下:</p><p>架构设计：</p><p>主要原理就是使用Mqtt协议联通内外网，然后，通过Mqtt协议传输数据到内网Linux，从而实现WebTerminal的效果</p><p><img src="/uploads/wps9.jpg" alt="img"> </p><p>目前基于Python实现了Mqtt SDK封装和Paramiko模块封装</p><p>MqttSDk：</p><p>目前的进度暂时在这里，后面继续跟进实现这个</p><h2 id="计划表："><a href="#计划表：" class="headerlink" title="计划表："></a>计划表：</h2><ol><li><p>实现完整web terminal</p></li><li><p>支持FTP/SFTP</p></li><li><p>支持VNC远程桌面</p></li><li><p>增加一些常见操作：</p></li></ol><p>·一键安装Java</p><p>·一键安装其他库等等，根据用户需求来装</p><h2 id="版本计划："><a href="#版本计划：" class="headerlink" title="版本计划："></a>版本计划：</h2><h3 id="V0-0-1"><a href="#V0-0-1" class="headerlink" title="V0.0.1"></a>V0.0.1</h3><p>·客户端的CURD操作</p><p>·Web Terminal完全支持</p><h3 id="V0-1-0"><a href="#V0-1-0" class="headerlink" title="V0.1.0"></a>V0.1.0</h3><p>·VNC支持</p><p>·一键配置环境，装软件</p><p>FTP</p><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><p>关于权限表的一些设计：内网主机连接进来以后，全部按照以下步骤处理</p><ol><li><p>自动分配权限（Permission），Permission数据结构如下：最终的Topic 生成规则如下：/client/group/{client_id}</p></li><li><p>可以选择分组订阅，这样就能接收广播【分组不支持WebTerminal】</p></li></ol><table><thead><tr><th>字段</th><th>类型</th><th>长度</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>11</td><td>主键</td></tr><tr><td>client_id</td><td>INT</td><td>11</td><td>客户端的ID</td></tr><tr><td>group</td><td>VARCHAR</td><td>20</td><td>分组</td></tr><tr><td>topic</td><td>VARCHAR</td><td>20</td><td>自己的topic</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>消息表设计：</p><p>Topic:消息的主题</p><p>Content:消息内容</p><h3 id="创建客户端凭据"><a href="#创建客户端凭据" class="headerlink" title="创建客户端凭据"></a>创建客户端凭据</h3><p>·输入设备相关信息：名称，SSH账户</p><p>·选择分组【默认分组为：DEFAULT_GROUP，需要手动创建其他分组】</p><p>·生成配置文件和客户端的安装包:</p><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;serverIp&quot;</span>: <span class="hljs-string">&quot;服务器IP&quot;</span>,<span class="hljs-attr">&quot;serverPort&quot;</span>: 服务器MQTT端口,<span class="hljs-attr">&quot;clientId&quot;</span>: <span class="hljs-string">&quot;随机生成字10位符串&quot;</span>,<span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;随机生成字10位符串&quot;</span>,<span class="hljs-attr">&quot;password&quot;</span>: <span class="hljs-string">&quot;随机生成字10位符串&quot;</span>,<span class="hljs-attr">&quot;sshUsername&quot;</span>: <span class="hljs-string">&quot;SSH用户名&quot;</span>,<span class="hljs-attr">&quot;sshPassword&quot;</span>: <span class="hljs-string">&quot;SSH密码&quot;</span>&#125;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="基本操作流程"><a href="#基本操作流程" class="headerlink" title="基本操作流程"></a>基本操作流程</h3><p>·登录后台</p><p>·查看客户端列表</p><p>·选择在线客户端</p><p>·点击【WebShell】打开登录窗口，此时会从客户端那边提取配置好的SSH用户和密码，配置如下：</p><p><img src="/uploads/wps10.jpg" alt="img"> </p><p>然后进行登录，如果登录成功了，然会一个标记，然后前端弹出WebTerminal，通过WebSocket连接起来，所有的通信到此完成</p><p>操作完毕，点击【退出】，关闭Socket，关闭弹出的窗口</p><h2 id="基本的功能："><a href="#基本的功能：" class="headerlink" title="基本的功能："></a>基本的功能：</h2><p><img src="/uploads/wps11.png" alt="img"> </p><p>·用户管理：注册（邮箱）、登录、激活、修改资料</p><p>·客户端管理：客户端的CURD操作</p><p>·WebShell：核心功能，通过HTML页面联通内网主机</p><h1 id="整体功能设计："><a href="#整体功能设计：" class="headerlink" title="整体功能设计："></a>整体功能设计：</h1><p>用户的角色有：管理员，普通用户</p><p>管理员可以添加用户，管理用户，限制用户登录 等等</p><p>同时可以查看所有的客户端状况（但是不能操作终端）</p><p>用户可以创建终端设备，操作终端</p><h1 id="关键界面原型图"><a href="#关键界面原型图" class="headerlink" title="关键界面原型图"></a>关键界面原型图</h1><p>添加</p><p><img src="/uploads/wps12.jpg" alt="img"> </p><h1 id="功能需求-用户"><a href="#功能需求-用户" class="headerlink" title="功能需求-用户"></a>功能需求-用户</h1><h2 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h2><table><thead><tr><th>功能</th><th>描述</th><th></th></tr></thead><tbody><tr><td>用户登录</td><td></td><td></td></tr><tr><td>用户注册</td><td></td><td></td></tr><tr><td>资料修改</td><td></td><td></td></tr><tr><td>获取当前用户资料</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="设备相关"><a href="#设备相关" class="headerlink" title="设备相关"></a>设备相关</h2><table><thead><tr><th>设备列表</th><th></th></tr></thead><tbody><tr><td>添加设备</td><td></td></tr><tr><td>修改设备</td><td></td></tr><tr><td>删除设备</td><td></td></tr><tr><td>查找设备</td><td>根据关键字查找设备：clientId name  备注 等字段</td></tr><tr><td>设备添加/移除进某群组</td><td>考虑到群控功能</td></tr><tr><td>设备转让</td><td>吧自己的设备转让给别人使用</td></tr><tr><td>设备分布</td><td>用地图显示设备位置</td></tr></tbody></table><h2 id="群组功能"><a href="#群组功能" class="headerlink" title="群组功能"></a>群组功能</h2><table><thead><tr><th>添加群组</th><th></th></tr></thead><tbody><tr><td>群组列表</td><td></td></tr><tr><td>删除群组</td><td></td></tr><tr><td>修改群组</td><td></td></tr><tr><td>列出当前群组下面所有的设备</td><td></td></tr></tbody></table><h2 id="系统首页"><a href="#系统首页" class="headerlink" title="系统首页"></a>系统首页</h2><table><thead><tr><th>首页统计</th><th>设备数 分组数 在线数 离线数服务器CPU 服务器负载 服务器。。。</th></tr></thead><tbody><tr><td>广告</td><td>打一下广告</td></tr><tr><td>使用方法</td><td>简单的列表一下使用教程</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h1><table><thead><tr><th>查看所有用户</th></tr></thead><tbody><tr><td>查看所有设备</td></tr><tr><td>控制用户账户</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多状态开关设计</title>
    <link href="/2019/11/19/clpqt1iwb00a94cuefvprdl2b.html"/>
    <url>/2019/11/19/clpqt1iwb00a94cuefvprdl2b.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文讲如何设计一个多状态开关</p><span id="more"></span><h1 id="多状态开关数据表现形式"><a href="#多状态开关数据表现形式" class="headerlink" title="多状态开关数据表现形式"></a>多状态开关数据表现形式</h1><p><img src="/uploads/image-20191119180352073.png" alt="image-20191119180352073"></p><p>一般情况下，开关只有2个状态，0和1，这是大都数应用场景里面的开关。但是在复杂场景下，这个开关可能叫开关不合适，应该叫：多状态开关（或者选择器）。回顾以下，我们的家庭电饭煲，是不是可以有多个挡位：1000W，2000W；还有吹风机，也有一档，二档，类似于这种设备我们称之为：多状态开关。</p><p>开关拥有的挡位记作N，每一个挡位有2个状态：1和0，所以，N个挡位的开关，应该有2N个组合。</p><p>我们看一下吹风机的挡位，架设有2个挡位：A：冷风，B：热风，那转换成数据描述性是就是：</p><p><code>S=[[0],[0]]</code></p><p>当开关状态变化的时候，可以通过挡位的值来表示：</p><p><code>S=[[1],[0]]</code></p><p>此时表示冷风挡</p><p>但是开关又有互斥，串联，并联的形式，互斥表示只能有一个生效，串联表示每一个都生效，并联表示一起生效，但是我们在上层不负责维护这个关系，终端去实现即可，上层只需要发送开关的控制指令即可。</p><p>一个有2个挡位的开关JSON数据结构如下：</p>]]></content>
    
    
    <categories>
      
      <category>物联网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RestFul风格权限系统设计</title>
    <link href="/2019/11/19/clpqt1iuy004g4cue4kay73em.html"/>
    <url>/2019/11/19/clpqt1iuy004g4cue4kay73em.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：概要-&gt;在认真分析了传统Rolebase设计西路以后，和Restful风格接口进行对比，提炼了一些通用的思路和不同的思路，设计了一套权限管理系统。</p><span id="more"></span><h1 id="RestFul风格权限系统设计"><a href="#RestFul风格权限系统设计" class="headerlink" title="RestFul风格权限系统设计"></a>RestFul风格权限系统设计</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>  近期在做物联网管理平台，准备采用传统的RBAC设计思路，但是目前的后端接口我们按照严格的Restful风格来设计，因此传统的Rolebase（角色为主）的设计方法此时就出现了弊端。在认真分析了传统Rolebase设计西路以后，和Restful风格接口进行对比，提炼了一些通用的思路和不同的思路，设计了一套权限管理系统。</p><h2 id="2-Restful"><a href="#2-Restful" class="headerlink" title="2.Restful"></a>2.Restful</h2><p>关于Restful其实网上资料很多，主要就是面向资源的接口形式，通过HTTP语义化形式来提供API接口服务，和传统的接口设计稍有不同：</p><p>案例：实现增加、删除、修改、查询博客（表名为Blog）的功能。</p><p>我们先用传统的形式来实现：</p><table><thead><tr><th>接口名</th><th>HTTP方法</th><th>路径</th></tr></thead><tbody><tr><td>增加</td><td>POST</td><td>http://://blog/addBlog</td></tr><tr><td>删除</td><td>DELETE</td><td>http://://blog/deleteBlog</td></tr><tr><td>修改</td><td>UPDATE</td><td>http://://blog/updateBlog</td></tr><tr><td>查询</td><td>GET</td><td>http://://blog/queryBlog?title=”XXX”…..</td></tr></tbody></table><p>上面给出的是传统写法，一个博客的CURD对应了4个接口地址,这样做的好处是方便了后端开发人员的代码定位，还有业务特点，看见接口就知道是什么含义，有助于理解业务流程。</p><p>接下来用Restful形式来实现：</p><table><thead><tr><th>接口名</th><th>HTTP方法</th><th>路径</th></tr></thead><tbody><tr><td>增加</td><td>POST</td><td>http://://blogs</td></tr><tr><td>删除</td><td>DELETE</td><td>http://://blogs</td></tr><tr><td>修改</td><td>UPDATE</td><td>http://://blogs</td></tr><tr><td>查询</td><td>GET</td><td>http://://blogs</td></tr></tbody></table><p>你会发现其实都是同一个接口，也就是说针对一个确定的资源，就一个统一入口，我们根据HTTP协议的语义来做业务区分：POST就是创建资源，DELETE就是删除······；都是一一对应的关系。</p><h2 id="3-权限系统"><a href="#3-权限系统" class="headerlink" title="3.权限系统"></a>3.权限系统</h2><p>如果我们现在要实现一套权限管理系统，针对传统接口风格，我们拟采用Rolebase的设计思路来实现权限控制。</p><p>假设系统有A，B两个用户，A的身份是管理员，拥有所有的CURD权限，但是B是一个新用户，只有看博客的权限，即查询权限，我们针对这个场景来设计个模式。</p><p>系统角色：ADMIN，USER，其中ADMIN的权限是CURD，USER的权限是R，见下表：</p><table><thead><tr><th>角色</th><th>权限</th></tr></thead><tbody><tr><td>ADMIN</td><td>新建</td></tr><tr><td>更新</td><td></td></tr><tr><td>删除</td><td></td></tr><tr><td>查询</td><td></td></tr><tr><td>USER</td><td>查询</td></tr></tbody></table><p>其中给A用户ADMIN的角色，B用户USER角色，到这一步就设计好了，角色对应的权限不同，从而实现了资源隔离。</p><p>目前比较流行的框架，比如Shiro，SpringSecurity都是这种形式，这种做法在WEB系统开发中很常见。</p><p>接下来我们分析一下这样做的弊端：</p><p>1 .每个功能对应一个接口，浪费接口数量；</p><p>2 .系统的角色控制是确定的，比如：/blog/addUser的权限就是ADMIN，后端比如明确指定角色，比如Shiro用了@RequireRole注解来标记。假如说用户的角色和权限是动态的，此时我就要USER来访问/blog/addUser，这时怎么办？貌似只能去改源码。因此这样不适合灵活变动的角色行为；</p><p>为了应变灵活的角色权限变动，我们设计了一套基于Restful风格的权限机制。</p><p>Restful风格建议面向资源，因此我们设计的一个接口有多个功能，区分是HTTP的Method，所以传统的做法到Method的时候就拦截不了。我们做了如下设计：</p><p>权限格式：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/uploads/wps1.png" alt="img"></td></tr></tbody></table><p>格式解释：</p><p>·user permissions method:用户在resource的允许的方法权限；</p><p>·Resource：资源路径；</p><p>·allow method：该资源要求的的权限。</p><p>我们来描述一个“管理员可以创建删除blog”的权限可以如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/uploads/wps2.png" alt="img"></td></tr></tbody></table><p>表示：/blog下的资源允许的HTTP请求有POST,DELETE,GET,PUT，但是管理员只能POST和DELETE。</p><p>我们如何去处理权限？当用户请求过来的时候，我们做一个拦截，首先提取出用户的权限列表，然后进行检查对比。具体的检查步骤如下：</p><p>1 .提取资源路径R；</p><p>2 .提取用户在此处的权限P;</p><p>3 .提取资源R的权限S；</p><p>4 .做对比：P是否是R的权限的完全子集，也就是说P的每一个Method都必须在S里面存在。伪代码如下：</p><p><img src="/uploads/wps3.png" alt="img"> </p><h2 id="4-表设计"><a href="#4-表设计" class="headerlink" title="4.表设计"></a>4.表设计</h2><p>表结构继续按照USER-ROLE-PERMISSION形式，形成三级关联：</p><p><img src="/uploads/wps4.jpg" alt="img"> </p><p>下面看下权限表的内容：</p><p><img src="/uploads/wps5.jpg" alt="img"> </p><p>methods表示资源的允许方法。</p><p>而role和权限的关联表则记录了用户的资源权限，allow表示用户的权限。</p><p><img src="/uploads/wps6.jpg" alt="img"> </p><h2 id="5-后端拦截器设计"><a href="#5-后端拦截器设计" class="headerlink" title="5.后端拦截器设计"></a>5.后端拦截器设计</h2><p>拦截器先对请求进行拦截，然后解析出当前请求的资源路径，查看当前用户的权限和资源的权限，做一个全子集判断，流程图如下：</p><p><img src="/uploads/wps7.jpg" alt="img"> </p><p>目标资源R：/blog</p><p>用户权限U：[GET]</p><p>资源权限S：[GET,POST,DELETE,PUT]</p><p>简单用伪代码描述一下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="/uploads/wps8.png" alt="img"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纪念来之不易的爱情</title>
    <link href="/2019/11/19/clpqt1ivx008h4cuefx5xh0ee.html"/>
    <url>/2019/11/19/clpqt1ivx008h4cuefx5xh0ee.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：纪念我和女朋友这三年来之不易的爱情。</p><span id="more"></span><blockquote><p> 这个脚本是1688商品图片爬取器，2017年10月为了减轻女票的重复工作量，搞了这个脚本帮她工作。</p></blockquote><p>2017年那个夏天，她转行做互联网，刚进互联网公司的时候，不会做东西，急得在出租屋里哭，我看着非常难受，于是当初准备写个爬虫脚本，希望能帮助她。可惜的是这个脚本还没写出来，她就辞职了，后来她经历了一系列的坎坷，换了好几家公司，每天生活过的奔波艰苦，最窘迫的时候房子都租不起住在集体宿舍，但是还是咬牙坚持和我在一起，等我大学毕业。终于坚持到今天，好的是我们都熬过来了。2020年我们准备结婚。</p><p>那是让我最心痛最难忘的一段时间，激励我不能忘了这段岁月，也是我们爱情的见证。不忘初心，方得始终。</p><p>今天是2019年11月某一天，我又翻出了那些代码，然后跑起来了，可是曾经的那些页面已经404。</p><p><img src="/uploads/image-20191119101316202.png" alt="image-20191119101316202"></p><p><img src="/uploads/image-20191119101635327.png" alt="image-20191119101635327"></p><h4 id="唯一不变的就是自己的内心吧。"><a href="#唯一不变的就是自己的内心吧。" class="headerlink" title="唯一不变的就是自己的内心吧。"></a>唯一不变的就是自己的内心吧。</h4><p>下面是代码，用的selnium和phantomjs。</p><ol><li><h3 id="form-py"><a href="#form-py" class="headerlink" title="form.py"></a>form.py</h3></li></ol><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-keyword">import</span> _thread<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> tkinter<span class="hljs-keyword">import</span> tkinter.filedialog<span class="hljs-keyword">import</span> tkinter.filedialog<span class="hljs-keyword">import</span> tkinter.messagebox<span class="hljs-keyword">import</span> tkinter.messagebox<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> urllib3<span class="hljs-keyword">import</span> xlrd<span class="hljs-keyword">import</span> xlwt<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriverDRIVER_PATH = <span class="hljs-string">&quot;../driver/phantomjs.exe&quot;</span>EXCEL = <span class="hljs-string">&#x27;../excel/data.xlsx&#x27;</span>requests.packages.urllib3.disable_warnings()browser = webdriver.PhantomJS(executable_path=<span class="hljs-string">&quot;C:/Users/admin/Github/Shabao-master/driver/phantomjs.exe&quot;</span>)excel = xlrd.open_workbook(<span class="hljs-string">&quot;C:\\Users\\admin\\Github\\Shabao-master\\excel\\data.xlsx&quot;</span>)sheet1 = excel.sheet_by_name(<span class="hljs-string">u&#x27;Sheet1&#x27;</span>)http_client = urllib3.PoolManager()<span class="hljs-comment"># 图片列表</span>picture_list = []<span class="hljs-comment"># 商品详情列表</span>details_info_list = []<span class="hljs-comment"># 颜色 尺码 价格 子字典</span>color_size_list = []filename = <span class="hljs-string">&quot;&quot;</span>lis = [    &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;1111111&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;26.00&#x27;</span>&#125;,    &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;2222222&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>,     <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;27.00&#x27;</span>&#125;,    &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;3333333&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>,     <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;28.00&#x27;</span>&#125;]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;总共有%d个数据&quot;</span> % sheet1.nrows)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span>(<span class="hljs-params">self, info</span>):</span>        self.console[<span class="hljs-string">&quot;text&quot;</span>] += info + <span class="hljs-string">&quot;\n&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span>(<span class="hljs-params">self, info</span>):</span>        _thread.start_new_thread(self.log, (info,))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_excel</span>(<span class="hljs-params">self, color_size_list</span>):</span>        <span class="hljs-comment"># 写excel</span>        write_excel = xlwt.Workbook()  <span class="hljs-comment"># 创建工作簿</span>        write_sheet1 = write_excel.add_sheet(<span class="hljs-string">u&#x27;sheet1&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 创建sheet</span>        header = [<span class="hljs-string">u&#x27;编号&#x27;</span>, <span class="hljs-string">u&#x27;名称&#x27;</span>, <span class="hljs-string">u&#x27;颜色&#x27;</span>, <span class="hljs-string">u&#x27;尺码&#x27;</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):            write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])            write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])            write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])            write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(color_size_list)):            info = color_size_list[i]            write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, info[<span class="hljs-string">&quot;id&quot;</span>])            write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, info[<span class="hljs-string">&quot;name&quot;</span>])            write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, info[<span class="hljs-string">&quot;color&quot;</span>])            write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, info[<span class="hljs-string">&quot;size&quot;</span>])        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">        从第四列开始插入数据</span><span class="hljs-string">        1 2 3 4</span><span class="hljs-string">        q w e r</span><span class="hljs-string"></span><span class="hljs-string">        &#x27;&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sheet1.nrows):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>, sheet1.ncols):                write_sheet1.write(i, j, sheet1.row_values(i)[j])        write_excel.save(<span class="hljs-string">&quot;./&quot;</span> + <span class="hljs-built_in">str</span>(time.asctime(time.localtime(time.time()))).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>).replace(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>) + <span class="hljs-string">&quot;_data.xlsx&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_excel_data</span>(<span class="hljs-params">self</span>):</span>        browser.get(<span class="hljs-string">&quot;https://detail.1688.com/&quot;</span>)        <span class="hljs-comment"># 表格的URL在第六列</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, sheet1.nrows - <span class="hljs-number">1</span>):            row = sheet1.row_values(i)            self.debug(<span class="hljs-string">&quot;正在获取连接:[&quot;</span> + row[<span class="hljs-number">6</span>] + <span class="hljs-string">&quot;]的数据&quot;</span>)            <span class="hljs-comment"># 开始解析第六列的数据</span>            <span class="hljs-keyword">try</span>:                browser.get(row[<span class="hljs-number">6</span>])                <span class="hljs-comment"># 获取商品名称</span>                title = browser.find_element_by_class_name(<span class="hljs-string">&quot;d-title&quot;</span>).text                <span class="hljs-comment"># 获取价格</span>                price = browser.find_element_by_class_name(<span class="hljs-string">&quot;value&quot;</span>).text                <span class="hljs-comment"># 详情在第4个DIV里面</span>                details = browser.find_elements_by_class_name(<span class="hljs-string">&quot;obj-content&quot;</span>)[<span class="hljs-number">4</span>]                <span class="hljs-comment"># 点击一下&#x27;加载更多&#x27;</span>                browser.find_elements_by_class_name(<span class="hljs-string">&quot;obj-expand&quot;</span>)[<span class="hljs-number">1</span>].click()                <span class="hljs-comment"># 构建详情列表</span>                temp_color_size_dict = &#123;&#125;                <span class="hljs-keyword">for</span> td <span class="hljs-keyword">in</span> details.find_elements_by_tag_name(<span class="hljs-string">&quot;td&quot;</span>):                    <span class="hljs-keyword">if</span> td.text <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(td.text) != <span class="hljs-number">0</span>:                        details_info_list.append(td.text)                <span class="hljs-comment"># 把详情列表里面的颜色 尺码提取出来</span>                temp_color_size_dict[<span class="hljs-string">&quot;id&quot;</span>] = i + <span class="hljs-number">1</span>                temp_color_size_dict[<span class="hljs-string">&quot;name&quot;</span>] = title                temp_color_size_dict[<span class="hljs-string">&quot;color&quot;</span>] = details_info_list[details_info_list.index(<span class="hljs-string">&quot;颜色&quot;</span>) + <span class="hljs-number">1</span>]                temp_color_size_dict[<span class="hljs-string">&quot;size&quot;</span>] = details_info_list[details_info_list.index(<span class="hljs-string">&quot;尺码&quot;</span>) + <span class="hljs-number">1</span>]                temp_color_size_dict[<span class="hljs-string">&quot;price&quot;</span>] = price                color_size_list.append(                    &#123;<span class="hljs-string">&#x27;id&#x27;</span>: i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>: title, <span class="hljs-string">&#x27;color&#x27;</span>: details_info_list[details_info_list.index(<span class="hljs-string">&quot;颜色&quot;</span>) + <span class="hljs-number">1</span>],                     <span class="hljs-string">&#x27;size&#x27;</span>: details_info_list[details_info_list.index(<span class="hljs-string">&quot;尺码&quot;</span>) + <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;price&#x27;</span>: price&#125;)                self.debug(<span class="hljs-string">&quot;商品名称:&quot;</span> + title + <span class="hljs-string">&quot;编号:&quot;</span>, i)                self.debug(<span class="hljs-string">&quot;细节:&quot;</span> + <span class="hljs-built_in">str</span>(temp_color_size_dict))                time.sleep(<span class="hljs-number">0.5</span>)            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                self.debug(<span class="hljs-string">&quot;出现异常:商品不存在或者已经下架!&quot;</span>)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终的数据:&quot;</span>, color_size_list)        <span class="hljs-keyword">return</span> color_size_list    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_file</span>(<span class="hljs-params">self, event</span>):</span>        filename = tkinter.filedialog.askopenfilename(filetypes=[(<span class="hljs-string">&quot;Excel表格&quot;</span>, <span class="hljs-string">&quot;xls&quot;</span>), (<span class="hljs-string">&quot;Excel表格&quot;</span>, <span class="hljs-string">&quot;xlsx&quot;</span>)])        <span class="hljs-keyword">if</span> filename:            self.filename_label[<span class="hljs-string">&quot;text&quot;</span>] = filename        <span class="hljs-keyword">else</span>:            self.filename_label[<span class="hljs-string">&quot;text&quot;</span>] = <span class="hljs-string">u&quot;你没有选择任何文件&quot;</span>            <span class="hljs-comment"># tkinter.messagebox.showinfo(&quot;文件选择&quot;, u&quot;你没有选择任何文件&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, event</span>):</span>        dlist = self.get_excel_data()        self.debug(<span class="hljs-built_in">str</span>(dlist))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exit</span>(<span class="hljs-params">self, event</span>):</span>        exit()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">center_window</span>(<span class="hljs-params">self</span>):</span>        width = <span class="hljs-number">500</span>        height = <span class="hljs-number">200</span>        screenwidth = self.frame.winfo_screenwidth()        screenheight = self.frame.winfo_screenheight()        size = <span class="hljs-string">&#x27;%dx%d+%d+%d&#x27;</span> % (width, height, (screenwidth - width) / <span class="hljs-number">2</span>, (screenheight - height) / <span class="hljs-number">2</span>)        self.frame.geometry(size)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.frame = Tk()        self.frame.title(<span class="hljs-string">&quot;数据快速分类工具&quot;</span>)        self.center_window()        self.scroll = Scrollbar()        self.scroll.pack(side=RIGHT, fill=Y)        self.console = Text(self.frame, width=<span class="hljs-number">200</span>, height=<span class="hljs-number">200</span>, bg=<span class="hljs-string">&quot;black&quot;</span>, fg=<span class="hljs-string">&quot;green&quot;</span>,                            font=(<span class="hljs-string">&#x27;Helvetica&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>), yscrollcommand=self.scroll.<span class="hljs-built_in">set</span>)        self.scroll.config(command=self.console.yview)        self.console = Label(self.frame, width=<span class="hljs-string">&quot;200&quot;</span>, height=<span class="hljs-string">&quot;100&quot;</span>, text=<span class="hljs-string">&quot;&quot;</span>, bg=<span class="hljs-string">&quot;black&quot;</span>, fg=<span class="hljs-string">&quot;green&quot;</span>, justify=LEFT)        self.filename_label = Label(self.frame)        self.start_button = Button(self.frame, text=<span class="hljs-string">u&quot;开始转换&quot;</span>)        self.open_file_button = Button(self.frame, text=<span class="hljs-string">u&quot;打开文件&quot;</span>)        self.exit_button = Button(self.frame, text=<span class="hljs-string">u&quot;退出程序&quot;</span>)        self.filename_label.pack()        self.open_file_button.pack()        self.start_button.pack()        self.exit_button.pack()        self.console.pack()        self.open_file_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.open_file)        self.exit_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.exit)        self.start_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.start)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">self</span>):</span>        self.frame.mainloop()</code></pre><ol start="2"><li><h3 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h3></li></ol><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">from</span> form <span class="hljs-keyword">import</span> MainWindow, lis<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    window = MainWindow()    window.write_excel(lis)    window.show()</code></pre><ol start="3"><li><h3 id="phantomjs-py"><a href="#phantomjs-py" class="headerlink" title="phantomjs.py"></a>phantomjs.py</h3></li></ol><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> tkinter<span class="hljs-keyword">import</span> tkinter.filedialog<span class="hljs-keyword">import</span> tkinter.filedialog<span class="hljs-keyword">import</span> tkinter.messagebox<span class="hljs-keyword">import</span> tkinter.messagebox<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> urllib3<span class="hljs-keyword">import</span> xlrd<span class="hljs-keyword">import</span> xlwt<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> config.config <span class="hljs-keyword">import</span> *requests.packages.urllib3.disable_warnings()browser = webdriver.PhantomJS(executable_path=DRIVER_PATH)excel = xlrd.open_workbook(EXCEL)sheet1 = excel.sheet_by_name(<span class="hljs-string">u&#x27;Sheet1&#x27;</span>)http_client = urllib3.PoolManager()<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;总共有%d个数据&quot;</span> % sheet1.nrows)<span class="hljs-comment"># 图片列表</span>picture_list = []<span class="hljs-comment"># 商品详情列表</span>details_info_list = []<span class="hljs-comment"># 颜色 尺码 价格 子字典</span>color_size_list = []lis = [&#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;2017春季新款漆皮系带厚底防水台松糕休闲女鞋潮&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;26.00&#x27;</span>&#125;,       &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;新款英伦风女鞋2017秋冬季单鞋休闲百搭粗跟中跟韩版皮鞋厂家直销&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>,        <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;27.00&#x27;</span>&#125;,       &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;2017秋季新款厚底女鞋坡跟休闲女单鞋深口系带圆头舒适松糕鞋女&#x27;</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;红色,黑色,香槟&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-string">&#x27;35,36,37,38,39&#x27;</span>,        <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-string">&#x27;28.00&#x27;</span>&#125;]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_excel_data</span>():</span>    browser.get(<span class="hljs-string">&quot;https://detail.1688.com/&quot;</span>)    <span class="hljs-comment"># 表格的URL在第六列</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, sheet1.nrows - <span class="hljs-number">1</span>):        row = sheet1.row_values(i)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在获取连接:&quot;</span>, row[<span class="hljs-number">6</span>])        <span class="hljs-comment"># 开始解析第六列的数据</span>        <span class="hljs-keyword">try</span>:            browser.get(row[<span class="hljs-number">6</span>])            <span class="hljs-comment"># 获取商品名称</span>            title = browser.find_element_by_class_name(<span class="hljs-string">&quot;d-title&quot;</span>).text            <span class="hljs-comment"># 获取价格</span>            price = browser.find_element_by_class_name(<span class="hljs-string">&quot;value&quot;</span>).text            <span class="hljs-comment"># 解析出图片列表</span>            picture_div_ul_li = browser.find_elements_by_class_name(<span class="hljs-string">&quot;tab-trigger&quot;</span>)            <span class="hljs-comment"># 详情在第4个DIV里面</span>            details = browser.find_elements_by_class_name(<span class="hljs-string">&quot;obj-content&quot;</span>)[<span class="hljs-number">4</span>]            <span class="hljs-comment"># 点击一下&#x27;加载更多&#x27;</span>            browser.find_elements_by_class_name(<span class="hljs-string">&quot;obj-expand&quot;</span>)[<span class="hljs-number">1</span>].click()            <span class="hljs-comment"># 构建详情列表</span>            temp_color_size_dict = &#123;&#125;            <span class="hljs-keyword">for</span> td <span class="hljs-keyword">in</span> details.find_elements_by_tag_name(<span class="hljs-string">&quot;td&quot;</span>):                <span class="hljs-keyword">if</span> td.text <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(td.text) != <span class="hljs-number">0</span>:                    details_info_list.append(td.text)            <span class="hljs-comment"># 把详情列表里面的颜色 尺码提取出来</span>            temp_color_size_dict[<span class="hljs-string">&quot;id&quot;</span>] = i + <span class="hljs-number">1</span>            temp_color_size_dict[<span class="hljs-string">&quot;name&quot;</span>] = title            temp_color_size_dict[<span class="hljs-string">&quot;color&quot;</span>] = details_info_list[details_info_list.index(<span class="hljs-string">&quot;颜色&quot;</span>) + <span class="hljs-number">1</span>]            temp_color_size_dict[<span class="hljs-string">&quot;size&quot;</span>] = details_info_list[details_info_list.index(<span class="hljs-string">&quot;尺码&quot;</span>) + <span class="hljs-number">1</span>]            temp_color_size_dict[<span class="hljs-string">&quot;price&quot;</span>] = price            color_size_list.append(                &#123;<span class="hljs-string">&#x27;id&#x27;</span>: i + <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>: title, <span class="hljs-string">&#x27;color&#x27;</span>: details_info_list[details_info_list.index(<span class="hljs-string">&quot;颜色&quot;</span>) + <span class="hljs-number">1</span>],                 <span class="hljs-string">&#x27;size&#x27;</span>: details_info_list[details_info_list.index(<span class="hljs-string">&quot;尺码&quot;</span>) + <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;price&#x27;</span>: price&#125;)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;商品名称:&quot;</span>, title, <span class="hljs-string">&quot;编号:&quot;</span>, i)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;细节:&quot;</span>, temp_color_size_dict)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;图片:&quot;</span>, picture_list)            time.sleep(<span class="hljs-number">0.5</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现异常:商品不存在或者已经下架!&quot;</span>)            <span class="hljs-built_in">print</span>(e)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最终的数据:&quot;</span>, color_size_list)    <span class="hljs-keyword">return</span> color_size_list<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_excel</span>(<span class="hljs-params">self, color_size_list</span>):</span>    <span class="hljs-comment"># 写excel</span>    write_excel = xlwt.Workbook()  <span class="hljs-comment"># 创建工作簿</span>    write_sheet1 = write_excel.add_sheet(<span class="hljs-string">u&#x27;sheet1&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 创建sheet</span>    header = [<span class="hljs-string">u&#x27;编号&#x27;</span>, <span class="hljs-string">u&#x27;名称&#x27;</span>, <span class="hljs-string">u&#x27;颜色&#x27;</span>, <span class="hljs-string">u&#x27;尺码&#x27;</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):        write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])        write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])        write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])        write_sheet1.write(<span class="hljs-number">0</span>, i, header[i])    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(color_size_list)):        info = color_size_list[i]        write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, info[<span class="hljs-string">&quot;id&quot;</span>])        write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, info[<span class="hljs-string">&quot;name&quot;</span>])        write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, info[<span class="hljs-string">&quot;color&quot;</span>])        write_sheet1.write(i + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, info[<span class="hljs-string">&quot;size&quot;</span>])    <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">    从第四列开始插入数据</span><span class="hljs-string">    1 2 3 4</span><span class="hljs-string">    q w e r</span><span class="hljs-string"></span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sheet1.nrows):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>, sheet1.ncols):            write_sheet1.write(i, j, sheet1.row_values(i)[j])    write_excel.save(        <span class="hljs-string">&quot;../excel/&quot;</span> + <span class="hljs-built_in">str</span>(time.asctime(time.localtime(time.time()))).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>).replace(<span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>) + <span class="hljs-string">&quot;_data.xlsx&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_file</span>(<span class="hljs-params">self, event</span>):</span>        filename = tkinter.filedialog.askopenfilename(filetypes=[(<span class="hljs-string">&quot;Excel表格&quot;</span>, <span class="hljs-string">&quot;xls&quot;</span>), (<span class="hljs-string">&quot;Excel表格&quot;</span>, <span class="hljs-string">&quot;xlsx&quot;</span>)])        <span class="hljs-keyword">if</span> filename:            self.filename_label[<span class="hljs-string">&quot;text&quot;</span>] = filename        <span class="hljs-keyword">else</span>:            self.filename_label[<span class="hljs-string">&quot;text&quot;</span>] = <span class="hljs-string">u&quot;你没有选择任何文件&quot;</span>            <span class="hljs-comment"># tkinter.messagebox.showinfo(&quot;文件选择&quot;, u&quot;你没有选择任何文件&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, event</span>):</span>        tkinter.messagebox.showinfo(<span class="hljs-string">&quot;文件选择&quot;</span>, <span class="hljs-string">u&quot;开始获取&quot;</span>)        self.console[<span class="hljs-string">&quot;text&quot;</span>] += <span class="hljs-string">&quot;1111111\n&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exit</span>(<span class="hljs-params">self, event</span>):</span>        exit()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">center_window</span>(<span class="hljs-params">self</span>):</span>        width = <span class="hljs-number">500</span>        height = <span class="hljs-number">200</span>        screenwidth = self.frame.winfo_screenwidth()        screenheight = self.frame.winfo_screenheight()        size = <span class="hljs-string">&#x27;%dx%d+%d+%d&#x27;</span> % (width, height, (screenwidth - width) / <span class="hljs-number">2</span>, (screenheight - height) / <span class="hljs-number">2</span>)        self.frame.geometry(size)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.frame = Tk()        self.frame.title(<span class="hljs-string">&quot;数据快速分类工具&quot;</span>)        self.center_window()        self.scroll = Scrollbar()        self.scroll.pack(side=RIGHT, fill=Y)        self.console = Text(self.frame, width=<span class="hljs-number">200</span>, height=<span class="hljs-number">200</span>, bg=<span class="hljs-string">&quot;black&quot;</span>, fg=<span class="hljs-string">&quot;green&quot;</span>,                            font=(<span class="hljs-string">&#x27;Helvetica&#x27;</span>, <span class="hljs-string">&#x27;14&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>), yscrollcommand=self.scroll.<span class="hljs-built_in">set</span>)        self.scroll.config(command=self.console.yview)        self.filename_label = Label(self.frame)        self.start_button = Button(self.frame, text=<span class="hljs-string">u&quot;开始转换&quot;</span>)        self.open_file_button = Button(self.frame, text=<span class="hljs-string">u&quot;打开文件&quot;</span>)        self.exit_button = Button(self.frame, text=<span class="hljs-string">u&quot;退出程序&quot;</span>)        self.filename_label.pack()        self.open_file_button.pack()        self.start_button.pack()        self.exit_button.pack()        self.console.pack(side=LEFT, fill=Y)        self.open_file_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.open_file)        self.exit_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.exit)        self.start_button.bind(<span class="hljs-string">&quot;&lt;ButtonRelease-1&gt;&quot;</span>, self.start)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">self</span>):</span>        self.frame.mainloop()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    window = MainWindow()    window.show()</code></pre><p>希望自己不忘初心，希望我那个傻傻的女朋友能永远快乐！</p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dl4j的BaseLayer前向与反向传播算法计算过程简介</title>
    <link href="/2019/11/06/clpqt1ius003x4cue4s524vn6.html"/>
    <url>/2019/11/06/clpqt1ius003x4cue4s524vn6.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[gerry] # 概要：本文以org.deeplearning4j.nn.layers.BaseLayer为例，DenseLayer继承BaseLayer，并使用其前向与反向传播方法。</p><span id="more"></span><p>﻿# dl4j的BaseLayer前向与反向传播算法计算过程简介</p><p>本文以org.deeplearning4j.nn.layers.BaseLayer为例，DenseLayer继承BaseLayer，并使用其前向与反向传播方法。DenseLayer的网络结构如下图所示。</p><hr><p><img src="../../../uploads/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMjIxMjEwNTE0MDQ3.jfif" alt="这里写图片描述"></p><p>​    </p><h2 id="1-前向传播"><a href="#1-前向传播" class="headerlink" title="1.前向传播"></a>1.前向传播</h2><p>BaseLayer的前向传播计算过程方法为preOutput(boolean training)，其中与公式 Z=WX + b对应的代码为：</p><pre><code class="hljs reasonml">INDArray ret = input.mmul(W).addi<span class="hljs-constructor">RowVector(<span class="hljs-params">b</span>)</span>;</code></pre><p>假设某一层的输入值为nIn，输出值为nOut，每次使用的样例个数为batchSize。</p><p>input的shape为(batchSize,nIn)<br>W的shape为(nIn,nOut)<br>b的shape为(1,nOut)<br>Z和WX的shape都为(batchSize,nOut)</p><p>addiRowVector方法是计算得到WX的结果后每一行加上b，其实可以理解为Z=WX+B*b，其中B为偏置向量b的系数，shape为(batchSize,1)，其所有值都为1。为何在此处提到系数矩阵B，方便解释在反向传播中对偏置的偏导数是如何计算。</p><p>激活函数a=activation(Z)，a的shape是(batchSize,nOut)，这里先定义一个activationDerivative(Z)是激活函数的导数。</p><h2 id="2-反向传播"><a href="#2-反向传播" class="headerlink" title="2.反向传播"></a>2.反向传播</h2><p>主要的方法是BaseLayer.backpropGradient(INDArray epsilon)。</p><p><img src="../../../uploads/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMjE5MTgyNTM5OTU5.jfif" alt="这里写图片描述"></p><p>如上图，注释中已经解释epsilon是代价函数(损失函数)C对激活函数a的偏导，并且是对当前隐藏层的激活函数的偏导。</p><p>然后计算delta=(dC/dZ)=(dC/da)*(da/dZ)=epsilon⊙activationDerivative(Z)，⊙为hadamard积分，代码为：</p><pre><code class="hljs jboss-cli">INDArray delta = layerConf<span class="hljs-params">()</span><span class="hljs-string">.getActivationFn</span><span class="hljs-params">()</span><span class="hljs-string">.backprop</span><span class="hljs-params">(z, epsilon)</span><span class="hljs-string">.getFirst</span><span class="hljs-params">()</span>;</code></pre><p>计算weightGrad=dC/dW=(dC/dZ)(dZ/dW)=delta *  input^T，代码：</p><pre><code class="hljs apache"><span class="hljs-attribute">Nd4j</span>.gemm(input, delta, weightGrad, true, false, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>.<span class="hljs-number">0</span>);</code></pre><p>计算biasGrad=dC/db=(dC/dZ)(dZ/db)=delta * B^T，这个B矩阵在上面已经提到过，shape为(batchSize,1)，所有的值都为1，所以相当于：</p><pre><code class="hljs maxima"><span class="hljs-built_in">delta</span>.<span class="hljs-built_in">sum</span>(biasGrad, <span class="hljs-number">0</span>);</code></pre><p>最后……，首先设前一层的激活函数矩阵为A，掐脚趾一算不正是当前层的input矩阵么，所以要传递给前一层的epsilonNext=dC/dA=(dC/dZ)(dZ/dA)=(dC/dZ)(dZ/d(input))=delta * W^T，代码为:</p><pre><code class="hljs maxima">INDArray epsilonNext = params.<span class="hljs-built_in">get</span>(DefaultParamInitializer.WEIGHT_KEY).mmul(<span class="hljs-built_in">delta</span>.<span class="hljs-built_in">transpose</span>()).<span class="hljs-built_in">transpose</span>();</code></pre><p>以上为本人个人见解，如有错误，请网友们批评指正。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>java</tag>
      
      <tag>Dl4J</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring webflux使用websocket实现单播和广播</title>
    <link href="/2019/11/06/clpqt1iuu00414cueagcw34q1.html"/>
    <url>/2019/11/06/clpqt1iuu00414cueagcw34q1.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[gerry] # 概要：先前搜了一些关于reactive websocket的示例都是单个session收到消息后又发送给自己，例如：session.send(session.receive())，这种形式和单次http的作用无差别，</p><span id="more"></span><p>﻿@[TOC](Spring webflux使用websocket实现单播和广播)</p><ul><li>写这个配置类的原因：</li></ul><p>先前搜了一些关于reactive websocket的示例都是单个session收到消息后又发送给自己，例如：session.send(session.receive())，这种形式和单次http的作用无差别，并没有体现双向通讯。Spring boot又还未支持像1.*版本对stomp协议的支持，直接使用SimpMessagingTemplate就能点对点单播和广播。然后在GitHub上找到一个靠谱的例子，而且真的是只有一个，资料太少，参考后先实现了进行单播和广播，再加上对响应式编程渐渐理解，最终形成这个配置代码。</p><hr><p>使用 <strong>Spring boot 2.1.2.release</strong>，该版本的Spring boot还未对reactive websocket进行自动装配，需要开发人员手动配置，代码地址供参考：<br><a href="https://github.com/Gerry-Pan/Live/blob/master/src/main/java/cn/com/pan/live/config/WebSocketConfiguration.java">https://github.com/Gerry-Pan/Live/blob/master/src/main/java/cn/com/pan/live/config/WebSocketConfiguration.java</a></p><ul><li>注册HandlerMapping和WebSocketHandlerAdapter</li></ul><p>Spring boot启动时会扫码BeanFactory中的org.springframework.web.reactive.HandlerMapping类型的Bean，给websocket增加映射操作类：</p><pre><code>@Beanpublic HandlerMapping handlerMapping(WebSocketHandler webSocketHandler) &#123;       Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;String, WebSocketHandler&gt;();       map.put(webSocketHandlerPath, webSocketHandler);       SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();       mapping.setUrlMap(map);       mapping.setOrder(10);       return mapping;&#125;@Beanpublic WebSocketHandlerAdapter webSocketHandlerAdapter() &#123;    return new WebSocketHandlerAdapter();&#125;</code></pre><ul><li>注册Websocket握手时的处理类WebSocketHandler</li></ul><p>该方法中定义了接收和发送消息：</p><pre><code>@Beanpublic WebSocketHandler webSocketHandler() &#123;       UnicastProcessor&lt;String&gt; messageProcessor = this.messageProcessor();       Flux&lt;String&gt; messages = messageProcessor.replay(0).autoConnect();       Flux&lt;String&gt; outputMessages = Flux.from(messages);       return (session) -&gt; &#123;           session.receive().map(WebSocketMessage::getPayloadAsText).subscribe(messageProcessor::onNext,                   messageProcessor::onError, messageProcessor::onComplete);           return session.getHandshakeInfo().getPrincipal().flatMap((p) -&gt; &#123;               session.getAttributes().put(&quot;username&quot;, p.getName());               return session.send(outputMessages.filter((payload) -&gt; this.filterUser(session, payload))                       .map((payload) -&gt; this.generateMessage(session, payload)));           &#125;).switchIfEmpty(Mono.defer(() -&gt; &#123;               return Mono.error(new BadCredentialsException(&quot;Bad Credentials.&quot;));           &#125;)).then();       &#125;;   &#125;</code></pre><p>UnicastProcessor订阅了org.springframework.web.reactive.socket.WebSocketSession.receive()的数据流，session接收消息后将消息传给UnicastProcessor，而session.send订阅UnicastProcessor，当UnicastProcessor中有数据进入，会触发session.send。而且同理用在<a href="https://github.com/Gerry-Pan/Live/blob/master/src/main/java/cn/com/pan/live/config/KafkaConfiguration.java"><strong>reactor kafka</strong></a>上。除了UnicastProcessor，还有几个Processor，比如EmitterProcessor，TopicProcessor，ReplyProcessor，DirectProcessor等等等等，感兴趣的童鞋就去研究一下。</p><ul><li>根据消息过滤用户</li></ul><p>有多少用户开启websocket连接进来就存在多少session实例，session.send就会被触发多少次，但是消息只发给对应的用户，所以需要筛选，如何筛选是可以自定义，比如根据payload中的字段指定的用户名筛选。filterUser方法返回true则是表示该消息是发送给此session，会继续调用generateMessage方法，false则不是，generateMessage方法不被调用，例如：</p><pre><code>protected boolean filterUser(WebSocketSession session, String payload) &#123;    System.out.println(session.getAttributes());    System.out.println(&quot;filterUser-----&quot; + Thread.currentThread().getName());    return true;&#125;</code></pre><p><strong>当然这种方式不够科学，本人会再研究如何实现对应的session.send被触发，而不是所有的被触发再进行过滤。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>java</tag>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeepLearning4j的StackVertex实现参数共享</title>
    <link href="/2019/11/06/clpqt1iur003w4cuecrzeeghu.html"/>
    <url>/2019/11/06/clpqt1iur003w4cuecrzeeghu.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[gerry] # 概要：设input1和input2是shape为(M,I)的张量，权重W是shape为(I,O)的张量,<br>设对应的两个输出值为output1和output2，其shape是(M,O)，设损失函数对输出值的导数为epsilon1和epsilon2，损失函数对线性部分的导数为delta1和delta2，shape也都是(M,O)：</p><span id="more"></span><p>﻿设input1和input2是shape为(M,I)的张量，权重W是shape为(I,O)的张量,<br>设对应的两个输出值为output1和output2，其shape是(M,O)，设损失函数对输出值的导数为epsilon1和epsilon2，损失函数对线性部分的导数为delta1和delta2，shape也都是(M,O)：<br><img src="../../../uploads/20190604223626632.png" alt="在这里插入图片描述"><br><strong>Nd4j.gemm(input, delta, weightGrad, true, false, 1.0, 0.0);</strong></p><p>以全连接为例，已知gradient=input^T  * delta<br>权重梯度gradient的shape和权重W相同，shape=(I,O)<br>得到（注意看逗号）：<br><img src="../../../uploads/20190604224411123.png" alt="在这里插入图片描述"><br><img src="../../../uploads/20190604224429480.png" alt="在这里插入图片描述"><br>对input1和input2合并，即沿着dimension=0合并，新的input和delta如下：<br><img src="../../../uploads/20190604223912602.png" alt="在这里插入图片描述"><br>此处发现<strong>G=g1+g2</strong><br>同理可推，当有n个input时，<strong>G=g1+g2+…+gn</strong></p><p><strong>1.gn的意义：</strong><br>L=L1+L2+…+Ln<br><img src="../../../uploads/20190604224812450.jpg" alt="在这里插入图片描述"><br><strong>2.G的意义：</strong><br>将n个input合并为一个Input，视为一个整体，直接计算权重W的梯度G，而G的值正是等于每个单独计算的梯度的总和。</p><p><strong>综上所述，只要对n个输入沿着dimension=0合并成新的input进入其他Layer，既能做到前向传播时权重W被共用，又能做到反向传播时梯度符合“和函数的导数”。</strong><br><img src="../../../uploads/20190604224033299.jpg" alt="在这里插入图片描述"><br>偏差bias的梯度同理。</p><p>Deeplearning4j中的实现类：<br>org.deeplearning4j.nn.conf.graph.StackVertex<br>org.deeplearning4j.nn.graph.vertex.impl.StackVertex<br>StackVertex是对n个输入沿着dimension=0合并。合并之后新的input就能进入ff层、RNN层或CNN层进行参数共享和反向梯度计算。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>java</tag>
      
      <tag>Neo4J</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于编程范式的思考</title>
    <link href="/2019/11/06/clpqt1ivb005z4cue2v8g6vse.html"/>
    <url>/2019/11/06/clpqt1ivb005z4cue2v8g6vse.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：关于编程范式的思考</p><span id="more"></span><h1 id="关于编程范式的思考"><a href="#关于编程范式的思考" class="headerlink" title="关于编程范式的思考"></a>关于编程范式的思考</h1><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><hr><h1 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h1><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;    doSomeThing()    ....&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">new</span> Object().doSomeThing()</code></pre><h2 id="本质上是：对现实世界中的静态建模"><a href="#本质上是：对现实世界中的静态建模" class="headerlink" title="本质上是：对现实世界中的静态建模"></a>本质上是：<em>对现实世界中的静态建模</em></h2><hr><h1 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h1><p>面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。</p><hr><h1 id="典型案例-1"><a href="#典型案例-1" class="headerlink" title="典型案例"></a>典型案例</h1><pre><code class="hljs C">socket(...);bind(...);listen(...);accept(...);send(...);</code></pre><h2 id="本质上是：在尽可能的模拟计算机运行"><a href="#本质上是：在尽可能的模拟计算机运行" class="headerlink" title="本质上是：在尽可能的模拟计算机运行"></a>本质上是：<em>在尽可能的模拟计算机运行</em></h2><hr><h1 id="面向函数"><a href="#面向函数" class="headerlink" title="面向函数"></a>面向函数</h1><p>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p><hr><h1 id="典型案例-2"><a href="#典型案例-2" class="headerlink" title="典型案例"></a>典型案例</h1><ol><li>函数是一等公民<pre><code class="hljs erlang">// define<span class="hljs-function"><span class="hljs-title">f1</span><span class="hljs-params">(F)</span> -&gt;</span> F().// call<span class="hljs-function"><span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">fun</span>() -&gt; ok <span class="hljs-keyword">end</span>)</span>.</span></code></pre></li></ol><hr><ol start="2"><li>函数调用柯里化<pre><code class="hljs erlang">// define<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(M, N)</span> -&gt;</span> M + N.// call<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>.</span></code></pre></li></ol><pre><code class="hljs erlang">// define<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(N)</span> -&gt;</span> <span class="hljs-keyword">fun</span>(M) -&gt; N + M <span class="hljs-keyword">end</span>.// call<span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>.</span></code></pre><hr><ol start="3"><li>并发模型</li></ol><pre><code class="hljs erlang">// run<span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span> -&gt;</span>    <span class="hljs-keyword">receive</span>      Msg -&gt; handle(Msg),      run()    <span class="hljs-keyword">end</span>.// Produce Process<span class="hljs-function"><span class="hljs-title">spwan</span><span class="hljs-params">(<span class="hljs-keyword">fun</span>() -&gt; run() <span class="hljs-keyword">end</span>)</span>.</span></code></pre><h2 id="本质上是：对现实世界的动态建模"><a href="#本质上是：对现实世界的动态建模" class="headerlink" title="本质上是：对现实世界的动态建模"></a>本质上是：<em>对现实世界的动态建模</em></h2>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言家族的一些历史遗留和困惑</title>
    <link href="/2019/11/06/clpqt1ivc00614cue18z430p8.html"/>
    <url>/2019/11/06/clpqt1ivc00614cue18z430p8.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：C语言家族的一些历史遗留和困惑</p><span id="more"></span><h1 id="C语言家族的一些历史遗留和困惑"><a href="#C语言家族的一些历史遗留和困惑" class="headerlink" title="C语言家族的一些历史遗留和困惑"></a>C语言家族的一些历史遗留和困惑</h1><p><img src="https://picsum.photos/720?image=29" alt="bg left:25%"></p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h1 id="字符串表示"><a href="#字符串表示" class="headerlink" title="字符串表示"></a>字符串表示</h1><pre><code class="hljs C"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s1 = <span class="hljs-string">&quot;hello world&quot;</span>;<span class="hljs-keyword">char</span> s2[] = <span class="hljs-string">&quot;hello world&quot;</span>;</code></pre><h2 id="困惑点"><a href="#困惑点" class="headerlink" title="困惑点"></a>困惑点</h2><ul><li>两种语义化类型表示同一目标，产生歧义；</li><li>提出“字符串指针”，打破了“指针是一个内存编号”的规范；</li></ul><hr><h1 id="字符串改良建议"><a href="#字符串改良建议" class="headerlink" title="字符串改良建议"></a>字符串改良建议</h1><ol><li>const char * 类型建议直接产生新类型叫：原子，或者tag；</li><li>取消”字符串“的概念；直接叫字符序列；或者字符列表</li><li>统一字符序列的指针是一个int值的概念，取消”静态字符串常量指针“的概念</li></ol><hr><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><pre><code class="hljs C"><span class="hljs-comment">// 定义一个静态字面值常量称之为原子</span>atom a = <span class="hljs-string">&quot;ok&quot;</span>;<span class="hljs-comment">// 字符序列指针可以取原子的地址</span><span class="hljs-keyword">char</span> *cptr = &amp;a;</code></pre><p>从上面的优化方案可以看出，“字符串”用”原子“类型直接替代以后，消除了困惑和歧义</p><hr><h1 id="数组的困惑"><a href="#数组的困惑" class="headerlink" title="数组的困惑"></a>数组的困惑</h1><pre><code class="hljs shell">array的谷歌翻译:    动词        排列        array, arrange, range, put in order        部署        deploy, dispose, arrange, array    名词        排列        arrangement, array, permutation        矩阵        matrix, array        序列        sequence, array, suite        大批        bulk, large quantity, array, legion, considerable</code></pre><p>上述翻译，就没有一个含义和“数”相关，这是中文翻译的败笔；个人认为数组的翻译堪比”套接字“,”句柄”,”鲁棒”,完全是译者水平不足的体现。</p><hr><h1 id="数组改良建议"><a href="#数组改良建议" class="headerlink" title="数组改良建议"></a>数组改良建议</h1><p>中文名称改为：序列，或者列表比较合适，比较适合直观理解。</p><h2 id="新的概念"><a href="#新的概念" class="headerlink" title="新的概念"></a>新的概念</h2><blockquote><p>序列：一系列相同元组的集合。<br>示例代码：</p></blockquote><pre><code class="hljs C"><span class="hljs-keyword">int</span> a[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;T a[n] = &#123;...&#125;;</code></pre><hr><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><p>typedef:冗长而且没有语义化，建议将该关键字改良成<code>type</code>.</p><pre><code class="hljs C">type <span class="hljs-keyword">int</span> <span class="hljs-keyword">int_t</span>;<span class="hljs-function">type <span class="hljs-keyword">char</span> <span class="hljs-title">char_t</span> <span class="hljs-params">(*fp)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><hr><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>C的函数指针和指针混杂起来，不利于语义化和理解</p><pre><code class="hljs C"><span class="hljs-keyword">void</span> (*fun)(<span class="hljs-keyword">void</span> *);</code></pre><p>(*fun)本质上是个指针，可以用一个关键字类型替代</p><hr><h2 id="改进建议"><a href="#改进建议" class="headerlink" title="改进建议"></a>改进建议</h2><p>新增<em>fun</em>类型直接定义函数</p><pre><code class="hljs C"><span class="hljs-comment">// define</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(fun f)</span></span>&#123;    f();&#125;<span class="hljs-comment">// fun with name</span><span class="hljs-keyword">void</span> fun f = (<span class="hljs-keyword">void</span> *)&#123;&#125;call(f);<span class="hljs-comment">// anynomous fun</span>call(<span class="hljs-keyword">void</span> fun(<span class="hljs-keyword">void</span> *)&#123;&#125;)&#123;f()&#125;</code></pre><hr><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>虽然C可以通过宏定义来实现各种类型，但是我一直认为原生支持是最有利于理解和学习的.</p><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*fun)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span></span>;</code></pre><pre><code class="hljs C"><span class="hljs-keyword">void</span> fun f = (<span class="hljs-keyword">void</span> *)&#123;&#125;</code></pre><h1 id="开箱即用不好吗？"><a href="#开箱即用不好吗？" class="headerlink" title="开箱即用不好吗？"></a>开箱即用不好吗？</h1><hr><h1 id="Java的困惑"><a href="#Java的困惑" class="headerlink" title="Java的困惑"></a>Java的困惑</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><pre><code class="hljs aspectj">数据类型        默认值<span class="hljs-keyword">byte</span>            <span class="hljs-number">0</span><span class="hljs-keyword">short</span>           <span class="hljs-number">0</span><span class="hljs-keyword">int</span>             <span class="hljs-number">0</span><span class="hljs-keyword">long</span>            <span class="hljs-number">0</span>L<span class="hljs-keyword">float</span>           <span class="hljs-number">0.0</span>f<span class="hljs-keyword">double</span>          <span class="hljs-number">0.0</span>d<span class="hljs-keyword">char</span>            <span class="hljs-string">&#x27;u0000&#x27;</span><span class="hljs-keyword">boolean</span>         <span class="hljs-keyword">false</span></code></pre><p>基本类型是历史遗留，是当年JamsGalslin这些人设计的不足之处，从谷歌相关资料也可证实该说法。其实基本类型不应该出现在任何OOP编程语言中，基本类型出现在OOP语言中打破了规则，而且引入的新概念会含糊不清，</p><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类和接口的功能几乎是重合的，完全可以用抽象类来当做接口使用，所以Interface或者abstract class意义何在？该处也是遗留问题，也许最完美的设计应该是没有abstract class。这点从后生的编程语言可以看出，比如JS，Python等，就没有混杂的这两种类型。</p><blockquote><p>纯正的OOP思想就是继承，代码复用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物联网系统开发杂谈</title>
    <link href="/2019/11/06/clpqt1iw900a24cue9srtbj7k.html"/>
    <url>/2019/11/06/clpqt1iw900a24cue9srtbj7k.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下物联网业务系统和中间件的使用以及技术选型</p><span id="more"></span><h2 id="1-常见物联网技术简介"><a href="#1-常见物联网技术简介" class="headerlink" title="1.常见物联网技术简介"></a>1.常见物联网技术简介</h2><p> 基于云的物联网平台和架构能将现实世界与虚拟世界连接起来。借助这些平台和架构，企业能够管理物联网设备的连接性和安全性，同时收集设备数据，将设备连接至后端系统，确保物联网的互操作性，并构建和运行物联网应用。 </p><p>常见的物联网技术，其实还是基于物联网体系来做的，比如我们常见的共享产品，还有一些控制类的产品，其实本质还是互联网，还是基于TCP体系来实现的。</p><p>而现在提倡的物联网则是自成体系，一般为新的通信协议为主，自带组网和数据传输的功能，脱离开TCP/IP体系构建。</p><p>我们在本篇文章中主要介绍基于TCP/IP体系下的物联网系统构建。</p><h2 id="2-开源物联网平台介绍"><a href="#2-开源物联网平台介绍" class="headerlink" title="2.开源物联网平台介绍"></a>2.开源物联网平台介绍</h2><ul><li><p><a href="https://thingsboard.io/">https://thingsboard.io/</a>  ：目前GitHub物联网后台系统排行第一  很多都是基于这个改的</p></li><li><p><a href="https://www.kaaproject.org/">https://www.kaaproject.org/</a> ：  KAA 适合做家庭设备 适合快速交付 做外包可以选</p></li><li><p><a href="https://github.com/sitewhere/sitewhere">https://github.com/sitewhere/sitewhere</a>  ：国外的一个适合做SAAS平台的  很庞大 玩起来费劲</p></li></ul><h2 id="3-开发技术选择"><a href="#3-开发技术选择" class="headerlink" title="3.开发技术选择"></a>3.开发技术选择</h2><h3 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1.编程语言"></a>1.编程语言</h3><p>一味的争论编程语言是没有任何意义的，恰当的编程语言用在恰当的场合才能发挥出巨大的优势。下面简单的分享下个人经验：</p><p>对于业务系统开发业，我一般比较关注这几个问题：</p><ol><li><p>是否可快速开发？</p></li><li><p>是否技术体系成熟，便于快速迭代和二次开发？</p></li><li><p>文档和教程是否完善？</p></li></ol><p>对于上面的原则，其实和大多数项目的开发原则都是一样的，不外乎就是用成熟稳定的技术，对于业务系统封的实现，我推荐用以下编程语言：</p><ul><li><p>PHP：适合快速构建业务系统，对于中小型物联网平台还是很适合；</p></li><li><p>Java：适合构建体系庞大的业务系统，企业级应用可选择用Java开发；</p></li><li><p>Python：Python也适合快速开发业务系统，尤其是其优秀的WEB框架和众多的库，可以满足中小型团队的业务响应。</p></li></ul><p>而对于设备协议交互和数据传输层，上面的体系就不合适了，因为物联网有几个很大的特征：高并发、大批量、高网络IO。因此我们需要一些具备这些特征的技术或者框架来实现。目前我建议用的技术体系和框架如下：</p><ul><li><p>Java：Java有高并发框架，常见的就是Netty，Mina，tio等，个人推荐Netty，因为Netty是一个基于Actor模型的框架，采用事件响应机制，远远的比OIO技术实现的应用优秀，常见的用Netty实现的框架比如Vert.X,Springboot的响应式WEB等等 。</p></li><li><p>Golang：Go对并发的天然支持，很适合做物联网服务端，golang的轻量级协程可以快速响应请求，对于并发场景非常合适；</p></li><li><p>Erlang：Erlang本身就是做电信通信的，也适合做高并发的服务端</p></li></ul><h2 id="2-业务框架技术"><a href="#2-业务框架技术" class="headerlink" title="2.业务框架技术"></a>2.业务框架技术</h2><p>对于Java体系而言，首推Spring全家桶，但是如果是小型项目可以试试国产的Jfinal。而Python则用Django框架，PHP的选择比较多，ThinkPHP、Zend、YII等等。</p><h2 id="3-物联网（基于TCP栈的）常见协议"><a href="#3-物联网（基于TCP栈的）常见协议" class="headerlink" title="3.物联网（基于TCP栈的）常见协议"></a>3.物联网（基于TCP栈的）常见协议</h2><ul><li><p>MQTT： 物联网 (IoT) 设备必须连接互联网。通过连接到互联网，设备就能相互协作，以及与后端服务协同工作。互联网的基础网络协议是 TCP/IP。MQTT（消息队列遥测传输） 是基于 TCP/IP 协议栈而构建的，已成为 IoT 通信的标准。 </p></li><li><p>AMQP： 高级消息队列协议（AMQP）是面向消息的中间件的平台中立的线级协议。 </p></li><li><p>COAP： CoAP是受限制的应用协议(Constrained Application Protocol)， 它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。 </p></li><li><p>HTTP：超文本传输协议。</p></li><li><p>TCP：TCP初始协议。</p></li><li><p>UDP：UDP初始协议。</p></li><li><p>ModBus：Modbus是一种串行通信协议，是Modicon公司（现在的施耐德电气 Schneider Electric）于1979年为使用可编程逻辑控制器（PLC）通信而发表。Modbus已经成为工业领域通信协议的业界标准，并且现在是工业电子设备之间常用的连接方式。</p></li></ul><h2 id="4-物联网中间件选择"><a href="#4-物联网中间件选择" class="headerlink" title="4.物联网中间件选择"></a>4.物联网中间件选择</h2><ul><li><p>HiveMq：Java开发 适合Java技术栈</p></li><li><p>mosquito：C语言开发，性能极致 ，但是驾驭难度高 不适合非C技术栈玩</p></li><li><p>RabitMq：Erlang/OTP 开发驾驭难度大，几乎和C一样难以二次开发增加自有业务</p></li><li><p>RocketMq：Java开发 和Hivemq差不多 是Apache的产品</p></li><li><p>EMQ：国产软件 Erlang/OTP 开发驾驭难度大， 出自华为 纯粹的面向物联网的一个代理 因此脱离物联网场景的话 支持的就比较弱  但是是目前国内资料最多的</p></li><li><p>VenreMq：Erlang/OTP 开发驾驭难度大，国外软件 相当于是EMQ的增强版，支持各种客户端 插件等等 ，但是资料太少。</p></li><li><p>TCP：纯TCP协议一般用来设计自定义协议，对开发人员要求较高。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云函数回调</title>
    <link href="/2019/11/06/clpqt1iwh00az4cuehqoq1szv.html"/>
    <url>/2019/11/06/clpqt1iwh00az4cuehqoq1szv.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲一下云函数回调</p><span id="more"></span><h2 id="云函数回调"><a href="#云函数回调" class="headerlink" title="云函数回调"></a>云函数回调</h2><p>这是用户写的一个云函数，功能就是输出一个ok字符串，保存在MongoDB中，ID是<code>fghhgh8ibg78ui76tgh8yu9iouhig</code></p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment">* request: 代表请求</span><span class="hljs-comment">* cloud: 代表云端</span><span class="hljs-comment">**/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callBack</span>(<span class="hljs-params">request, cloud</span>)</span>&#123;  <span class="hljs-keyword">return</span> cloud.test();&#125;</code></pre><h2 id="映射表"><a href="#映射表" class="headerlink" title="映射表"></a>映射表</h2><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>主键</td></tr><tr><td>uuid</td><td>UUID</td></tr><tr><td>script</td><td>LUA脚本内容</td></tr><tr><td>user_id</td><td>创建云函数的用户</td></tr><tr><td>project_id</td><td>云函数所属项目</td></tr></tbody></table><h2 id="云函数调用接口"><a href="#云函数调用接口" class="headerlink" title="云函数调用接口"></a>云函数调用接口</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<span class="hljs-comment">// 核心类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cloud</span></span>&#123;  <span class="hljs-comment">// 一个测试Demo，返回ok字符串</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;  &#125;&#125;;<span class="hljs-comment">// 返回</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params">code, request, result</span>) </span>&#123;  response.writeHead(code, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>&#125;);      response.write(result);      response.end();&#125;;<span class="hljs-comment">//全局静态</span><span class="hljs-keyword">const</span> cloud = <span class="hljs-keyword">new</span> Cloud();<span class="hljs-comment">// 入口</span>http.createServer( <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>&#123;      <span class="hljs-keyword">let</span> funcId = request.get(<span class="hljs-string">&quot;funcId&quot;</span>);      <span class="hljs-keyword">let</span> func = mongodb.query(&#123;<span class="hljs-attr">funcId</span>:funcId&#125;).limit(<span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span>(func == <span class="hljs-literal">null</span>)&#123;        r(<span class="hljs-number">404</span>, request, <span class="hljs-string">&quot;not found&quot;</span>);      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">// CloudService.call:调用func这个字符串,里面可能有个call函数，传给他两个参数</span>        <span class="hljs-keyword">let</span> result = CloudService.call(func, <span class="hljs-string">&quot;call&quot;</span>, request, cloud);        r(<span class="hljs-number">200</span>, request, result);      &#125;   &#125;);&#125;).listen(<span class="hljs-number">8080</span>);</code></pre><h2 id="用户调用自己的云函数"><a href="#用户调用自己的云函数" class="headerlink" title="用户调用自己的云函数"></a>用户调用自己的云函数</h2><pre><code class="hljs shell">http://127.0.0.1/8080?funcId=fghhgh8ibg78ui76tgh8yu9iouhig</code></pre><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><pre><code class="hljs ebnf"><span class="hljs-attribute">ok</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trap协议-简单TCP通信协议设计</title>
    <link href="/2019/10/31/clpqt1iu3001q4cuecqq9crba.html"/>
    <url>/2019/10/31/clpqt1iu3001q4cuecqq9crba.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲如何从协议涉及到代码，再到实现一个简单的基于TCP的物联网服务器的过程。</p><span id="more"></span><h1 id="Trap-Protocol协议设计文档"><a href="#Trap-Protocol协议设计文档" class="headerlink" title="Trap Protocol协议设计文档"></a>Trap Protocol协议设计文档</h1><h2 id="1-背景阐述"><a href="#1-背景阐述" class="headerlink" title="1.背景阐述"></a>1.背景阐述</h2><p>近期在家里看着墙发呆的时候，闹钟引起了我的注意。这个闹钟是大学的时候用过的，一直到现在都还在正常显示，突然想起来上一次换时间貌似是2017年12月–一个冬天，现在都快两年了，拿过来摆弄了一番，发现里面装了3节南孚电池。令我惊讶的是，闹钟还能很大声的响铃。<br>我不由得来了兴趣，仔细分析了一下这个闹钟的基本构造。闹钟用了液晶数码管作为显示屏，而液晶数码管的功耗就非常低了，这节省了很大的电量。同时有3节7号电池供电，电压是1.5*3=4.5V，差不多工作电流是0.001MA(百度了一下基本的参数做了对比)，在如此低功耗条件下工作了快2年，确实值得研究。<br>于是我想了一下，能不能发明一个专门针对低功耗的芯片的通信协议，来实现以非常低的功率长时间工作。最好是 纽扣电池，或者是马铃薯、番茄电池都能维持通信。我的闹钟上面可以显示温湿度，如果加以改造，就可以把这些数据上传到云服务器，岂不是可以时刻监控温湿度而实现动态调节？同时我还想远程换个铃声，这又涉及到了远程及时通信了，在这个比较有趣的情景下，我决定发明一个简单的基于TCP的，但是靠谱的，针对低端尤其是低功耗的设备进行少量数据传输的协议。<br>为何叫Trap？可能我觉得我的能力不够，做出来的东西就是个坑(Trap)吧，为了避免过分解读和吐槽，简单定义为：一个简单的玩具协议。</p><h2 id="2-参照标准"><a href="#2-参照标准" class="headerlink" title="2.参照标准"></a>2.参照标准</h2><p>在设计之前，我参考了好几种常见的协议，站在巨人的肩上工作能无限接近天花板不是吗。<br>近期参考了EMQ的一些设计思路(尤其是EMQ的产品介绍PPT)，还有之前的一个TCP服务器Demo也给了我一定程度的启发，EMQ给我的思路是：通信需要并发处理，TCP服务器Demo给我的思路是：越简单越好，这句话也是Python之禅的名言。<br>我协议设计的主要思路来源于Erlang的TCP并发处理模式和低功耗的芯片通信。</p><h2 id="3-同类协议"><a href="#3-同类协议" class="headerlink" title="3.同类协议"></a>3.同类协议</h2><p>在这个场景下，前辈们做了不少研究，业界比较知名的就是MQTT和CoAP两个协议。我在这里简单的讲一下。</p><h3 id="1-CoAP协议"><a href="#1-CoAP协议" class="headerlink" title="1.CoAP协议"></a>1.CoAP协议</h3><p>CoAP（Constrained Application Protocol）是一种在物联网世界的类HTTP协议，它的详细规范定义在 RFC 7252。COAP名字翻译来就是“受限应用协议”，顾名思义，使用在资源受限的物联网设备上。物联网设备的资源很受限，运行HTTP是不可以接受的。<br>COAP是一个非常简单的协议，非常轻量级，甚至可以看作是HTTP的精简版(当然和HTTP区别很大)。</p><h3 id="2-MQTT-协议"><a href="#2-MQTT-协议" class="headerlink" title="2.MQTT 协议"></a>2.MQTT 协议</h3><p>MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是一种基于发布/订阅范式的“轻量级”消息协议，由 IBM 发布。MQTT 可以被解释为一种低开销，低带宽占用的即时通讯协议，可以用极少的代码和带宽的为连接远程设备提供实时可靠的消息服务，它适用于硬件性能低下的远程设备以及网络状况糟糕的环境下，因此 MQTT 协议在 IoT（Internet of things，物联网），小型设备应用，移动应用等方面有较广泛的应用。<br>MQTT 可以看作是TCP之上的一个高级封装协议，功能强大，很适合作为物联网设备采集数据使用的协议。<br>关于其他的就不赘述了，上面介绍这两种协议最终目的就是让大家看到一个共同之处：物联网世界的通信大部分是：低功率、条件受限，资源不足。我们就按照这个设计思路出发设计新的协议，能同时支持TCP和类CoAP协议的协议，貌似是简单合体又比单独两个协议更好玩（不是取代，也不是挑战，而是另一种思路，给学习者带来一种心情的愉悦）的简单协议。</p><h2 id="4-详细设计"><a href="#4-详细设计" class="headerlink" title="4.详细设计"></a>4.详细设计</h2><h3 id="1-报文固定包头"><a href="#1-报文固定包头" class="headerlink" title="1. 报文固定包头"></a><strong>1.</strong> 报文固定包头</h3><p>数据固定报头使用4个字节(byte)来表示，如下表所示：</p><table><thead><tr><th>字节0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th></tr></thead><tbody><tr><td>字节1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>字节2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>字节3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="包头详解："><a href="#包头详解：" class="headerlink" title="包头详解："></a>包头详解：</h4><ul><li><p>字节0的高四位(higher 4bit)表示连接模式Mode，该Mode目前有2个值：1和2。其中1表示TCP长连接，2表示类似于COAP POST的短连接；·字节0低四位(lower 4bit)表示消息报文类型，目前留16个值，实际用不到这么多。具体如下表所示。·字节1、字节2表示消息的长度，最长支持2^16=65536(byte)个字符,也就是64KB。</p></li><li><p>字节3为扩展字节，预留给其他数据域使用。如果客户端需要认证，在这里填充Client ID的长度，最长支持2^8=256(byte)个字符，可以用来标识唯一识别号，此时ClientID的内容被放在数据域的第一段。</p></li></ul><h4 id="Mode-1-TCP模式-的情况下数据报文类型列表"><a href="#Mode-1-TCP模式-的情况下数据报文类型列表" class="headerlink" title="Mode=1(TCP模式)的情况下数据报文类型列表:"></a>Mode=1(TCP模式)的情况下数据报文类型列表:</h4><h5 id="成功返回："><a href="#成功返回：" class="headerlink" title="成功返回："></a>成功返回：</h5><table><thead><tr><th><strong><em>\</em>binary**</strong></th><th><strong><em>\</em>十进制**</strong></th><th><strong><em>\</em>客户端**</strong></th><th><strong><em>\</em>服务端**</strong></th><th><strong><em>\</em>含义**</strong></th></tr></thead><tbody><tr><td>0000</td><td>0</td><td>PING</td><td>PONG</td><td>心跳包\心跳回复</td></tr><tr><td>0001</td><td>1</td><td>AUTH</td><td>OK</td><td>认证成功\认证失败</td></tr><tr><td>0010</td><td>2</td><td>SEND</td><td>OK</td><td>发送成功\认证失败</td></tr><tr><td>0011</td><td>3</td><td>PUBLISH</td><td>OK</td><td>发布成功\发布失败</td></tr></tbody></table><h5 id="错误返回："><a href="#错误返回：" class="headerlink" title="错误返回："></a>错误返回：</h5><table><thead><tr><th><strong><em>\</em>binary**</strong></th><th><strong><em>\</em>十进制**</strong></th><th><strong><em>\</em>客户端**</strong></th><th><strong><em>\</em>服务端**</strong></th><th><strong><em>\</em>含义**</strong></th></tr></thead><tbody><tr><td>0100</td><td>4</td><td>AUTH</td><td>AUTH_FAILURE</td><td>认证失败</td></tr><tr><td>0101</td><td>5</td><td>SEND</td><td>SEND_FAILURE</td><td>发送失败</td></tr><tr><td>0110</td><td>6</td><td>PUBLISH</td><td>PUB_FAILURE</td><td>发布失败</td></tr></tbody></table><h4 id="Mode-2-Trap模式-的情况下数据报文类型列表"><a href="#Mode-2-Trap模式-的情况下数据报文类型列表" class="headerlink" title="Mode=2(Trap模式)的情况下数据报文类型列表:"></a>Mode=2(Trap模式)的情况下数据报文类型列表:</h4><h5 id="成功返回：-1"><a href="#成功返回：-1" class="headerlink" title="成功返回："></a>成功返回：</h5><table><thead><tr><th><strong><em>\</em>binary**</strong></th><th><strong><em>\</em>十进制**</strong></th><th><strong><em>\</em>客户端**</strong></th><th><strong><em>\</em>服务端**</strong></th><th><strong><em>\</em>含义**</strong></th></tr></thead><tbody><tr><td>0000</td><td>1</td><td>SEND</td><td>OK</td><td>发送成功</td></tr><tr><td>0001</td><td>2</td><td>PUBLISH</td><td>OK</td><td>发布成功</td></tr></tbody></table><h5 id="错误返回：-1"><a href="#错误返回：-1" class="headerlink" title="错误返回："></a>错误返回：</h5><table><thead><tr><th><strong><em>\</em>binary**</strong></th><th><strong><em>\</em>十进制**</strong></th><th><strong><em>\</em>客户端**</strong></th><th><strong><em>\</em>服务端**</strong></th><th><strong><em>\</em>含义**</strong></th></tr></thead><tbody><tr><td>0010</td><td>3</td><td>SEND</td><td>SEND_FAILURE</td><td>发送失败</td></tr><tr><td>0110</td><td>4</td><td>PUBLISH</td><td>PUB_FAILURE</td><td>发布失败</td></tr></tbody></table><h3 id="2-两种模式"><a href="#2-两种模式" class="headerlink" title="2.两种模式"></a>2.两种模式</h3><ul><li><p>TCP模式</p><p>当包头的字节0的高4位为0001(十进制为1)的时候，表示此时协议是TCP模式。在此模式下，客户端和服务端保持长连接。客户端可以向服务端SEND数据，也可以向另一个客户端PUBLISH数据，此模式是一个双工模式，服务端，客户端之间可以双向通信。</p></li></ul><p>TCP模式下客户端的连接过程</p><ol><li><p>请求连接</p><p>客户端向服务端发送一个请求连接的CONNECT报文，此时仅仅是为了保证Socket连接成功，所以没有任何身份信息。</p></li><li><p>回复确认</p><p>如果网络没有问题，服务端正常，客户端可信，此时回复一个OK报文，表示服务端准备就绪。</p><p>如果配置了ACL或者是因为别的原因，服务端识别到非法客户端，此时直接回复REFUSE_CONNECT报文，告诉客户端不允许连接。</p></li><li><p>发送Client Id进行认证</p><p>服务端回复确认OK包以后，客户端发送AUTH包，同时带上自己的ClientID请求连接，假如说ClientID此时为:CLIENT001，此时是9Byte，则字节3的值为CLIENT_ID_LENGTH=9(1001),同时数据区的第一段CLIENT_ID_LENGTH长度的数据即为真正的CLIENT_ID。如下图所示：</p><p><img src="/uploads/image-20191031222159175.png" alt="image-20191031222159175"></p></li></ol><ol start="4"><li><p>回复认证结果</p><p>如果认证成功，服务端返回OK包，如果认证失败，服务端返回AUTH_FAILURE包。</p></li><li><p>SEND：发送数据</p><p>客户端把数据提交到服务端，服务端可进行存储或者丢弃处理，不做转发。假如客户端CLIENT001送”helloworld”到服务端，其中字节3低四位表示客户端的CLIENTID长度；字节1、2连起来表示helloworld的长度即为10，二进制表示为:0000000000001010：</p><p><img src="/uploads/image-20191031222735382.png" alt="image-20191031222735382"></p><p>发送成功返回OK包，发送失败返回SEND_FAILURE包。</p></li><li><p>PUBLISH：发布数据</p><p>表示客户端发送数据到另一个客户端，其实就是客户端之间的相互通信过程。当发送PUBLISH包的时候，需要注意下面的问题：</p><ul><li>FROM：数据从何而来，指的是数据源；</li><li>TO：数据从何而去，指的是数据的目的地，指的是另一个客户端的ID。</li></ul><p>发布成功返回OK包，发布失败返回PUB_FAILURE包。</p></li></ol><ul><li><p>Trap模式</p><p>当包头的字节0的高4位为0010(十进制为2)的时候，表示此时协议是Trap模式。在此模式下，只支持SEND形式发送数据，客户端只能提交数据到服务器上，不能进行转发，而是否持久化或者丢弃是服务端来决定的。Trap在发送数据的时候，必须带上ClientId。</p><p>Trap模式和TCP模式的区别在于：TCP模式SEND结束以后保持连接，而Trap模式则断开连接，SEND完成后，如果成功则返回OK包，如果失败则返回SEND_FAILURE包，最后都是断开客户端的连接。</p><p>其中Trap模式下SEND数据和TCP没有区别：</p><p>CLIENT001发送(SEND)“helloworld”到服务端，其中字节3低四位表示客户端的CLIENTID长度；字节1、2连起来表示helloworld的长度即为10，二进制表示为:0000000000001010：</p><p><img src="/uploads/image-20191031223415183.png" alt="image-20191031223415183"></p></li></ul><h2 id="5-报文"><a href="#5-报文" class="headerlink" title="5.报文"></a>5.报文</h2><ol><li>CONNECT</li><li>CONNECT_OK</li><li>CONNECT_FAILURE</li><li>AUTH</li><li>AUTH_OK</li><li>AUTH_FAILURE</li><li>SEND</li><li>SEND_OK</li><li>SEND_FAILURE</li><li>PUBLISH</li><li>PUB_OK</li><li>PUB_FAILURE</li><li>CMD</li><li>CMD_OK</li><li>CMD_FAILURE</li></ol><h2 id="6-状态码"><a href="#6-状态码" class="headerlink" title="6.状态码"></a>6.状态码</h2><table><thead><tr><th>操作</th><th>成功</th><th>备注</th><th>失败</th><th>备注</th></tr></thead><tbody><tr><td>请求连接</td><td>0</td><td>0000</td><td>1</td><td>0001</td></tr><tr><td>发送数据</td><td>0</td><td>0000</td><td>2</td><td>0010</td></tr><tr><td>发布数据</td><td>0</td><td>0000</td><td>3</td><td>0011</td></tr><tr><td>执行命令</td><td>0</td><td>0000</td><td>4</td><td>0100</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Erlang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>Erlang</tag>
      
      <tag>TCP</tag>
      
      <tag>物联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EMQX插件开发基础</title>
    <link href="/2019/10/25/clpqt1ity00164cue5pt20lvg.html"/>
    <url>/2019/10/25/clpqt1ity00164cue5pt20lvg.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲EMQX插件开发入门基础</p><span id="more"></span><p><img src="/uploads/image-20191025092017692.png" alt="image-20191025092017692"></p><h2 id="1-EMQX简介"><a href="#1-EMQX简介" class="headerlink" title="1. EMQX简介"></a>1. EMQX简介</h2><p>EMQ X Broker 是基于高并发的 Erlang/OTP 语言平台开发，支持百万级连接和分布式集群架构，发布订阅模式的开源 MQTT 消息服务器。</p><p>EMQ X Broker 在全球物联网市场广泛应用。无论是产品原型设计、物联网创业公司、还是大规模的商业部署，EMQ X Broker 都支持开源免费使用。</p><p>因为EMQX是开源的，所以我们可以自由下载源码进行二次开发，同时EMQ支持插件扩展，极大的方便了我们自己定制化开发EMQX。</p><h2 id="2-插件介绍"><a href="#2-插件介绍" class="headerlink" title="2. 插件介绍"></a>2. 插件介绍</h2><p>EMQX内置了很多常见的插件，比如Mysql认证，MongoDb认证，Redis认证等等：</p><table><thead><tr><th align="left">插件</th><th align="center">配置文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://github.com/emqx/emqx-dashboard">emqx_dashboard</a></td><td align="center">etc/plugins/emqx_dashbord.conf</td><td align="left">Web 控制台插件(默认加载)</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-management">emqx_management</a></td><td align="center">etc/plugins/emqx_management.conf</td><td align="left">HTTP API 与 CLI 管理插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-clientid">emqx_auth_clientid</a></td><td align="center">etc/plugins/emqx_auth_clientid.conf</td><td align="left">ClientId 认证插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-username">emqx_auth_username</a></td><td align="center">etc/plugins/emqx_auth_username.conf</td><td align="left">用户名、密码认证插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-jwt">emqx_auth_jwt</a></td><td align="center">etc/plugins/emqx_auth_jwt.conf</td><td align="left">JWT 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-ldap">emqx_auth_ldap</a></td><td align="center">etc/plugins/emqx_auth_ldap.conf</td><td align="left">LDAP 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-http">emqx_auth_http</a></td><td align="center">etc/plugins/emqx_auth_http.conf</td><td align="left">HTTP 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-mongo">emqx_auth_mongo</a></td><td align="center">etc/plugins/emqx_auth_mongo.conf</td><td align="left">MongoDB 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-mysql">emqx_auth_mysql</a></td><td align="center">etc/plugins/emqx_auth_mysql.conf</td><td align="left">MySQL 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-pgsql">emqx_auth_pgsql</a></td><td align="center">etc/plugins/emqx_auth_pgsql.conf</td><td align="left">PostgreSQL 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-auth-redis">emqx_auth_redis</a></td><td align="center">etc/plugins/emqx_auth_redis.conf</td><td align="left">Redis 认证/访问控制</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-psk-file">emqx_psk_file</a></td><td align="center">etc/plugins/emqx_psk_file.conf</td><td align="left">PSK 支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-web-hook">emqx_web_hook</a></td><td align="center">etc/plugins/emqx_web_hook.conf</td><td align="left">Web Hook 插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-lua-hook">emqx_lua_hook</a></td><td align="center">etc/plugins/emqx_lua_hook.conf</td><td align="left">Lua Hook 插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-retainer">emqx_retainer</a></td><td align="center">etc/plugins/emqx_retainer.conf</td><td align="left">Retain 消息存储模块</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-rule-engine">emqx_rule_engine</a></td><td align="center">etc/plugins/emqx_rule_engine.conf</td><td align="left">规则引擎</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-bridge-mqtt">emqx_bridge_mqtt</a></td><td align="center">etc/plugins/emqx_bridge_mqtt.conf</td><td align="left">MQTT 消息桥接插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-delayed-publish">emqx_delayed_publish</a></td><td align="center">etc/plugins/emqx_delayed_publish.conf</td><td align="left">客户端延时发布消息支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-coap">emqx_coap</a></td><td align="center">etc/plugins/emqx_coap.conf</td><td align="left">CoAP 协议支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-lwm2m">emqx_lwm2m</a></td><td align="center">etc/plugins/emqx_lwm2m.conf</td><td align="left">LwM2M 协议支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-sn">emqx_sn</a></td><td align="center">etc/plugins/emqx_sn.conf</td><td align="left">MQTT-SN 协议支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-stomp">emqx_stomp</a></td><td align="center">etc/plugins/emqx_stomp.conf</td><td align="left">Stomp 协议支持</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-recon">emqx_recon</a></td><td align="center">etc/plugins/emqx_recon.conf</td><td align="left">Recon 性能调试</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-reloader">emqx_reloader</a></td><td align="center">etc/plugins/emqx_reloader.conf</td><td align="left">Reloader 代码热加载插件</td></tr><tr><td align="left"><a href="https://github.com/emqx/emqx-plugin-template">emqx_plugin_template</a></td><td align="center">etc/plugins/emqx_plugin_template.conf</td><td align="left">插件开发模版</td></tr></tbody></table><p>上面是官方插件，这些插件基本上能满足我们常见的使用场景，比如客户端认证我们用Mysql，数据存储我们用MongoDB，关于插件的使用和安装请看这里：<a href="https://docs.emqx.io/broker/v3/cn/plugins.html。">https://docs.emqx.io/broker/v3/cn/plugins.html。</a></p><h2 id="3-插件开发"><a href="#3-插件开发" class="headerlink" title="3. 插件开发"></a>3. 插件开发</h2><p>但是有时候可能我们的业务比较特殊，官方的插件不能满足需求，此时需要自定义插件，接下来我们讲一下自定义插件开发流程。</p><p>工欲善其事必先利其器，我们先准备一下环境。</p><h4 id="1-安装Rebar3"><a href="#1-安装Rebar3" class="headerlink" title="1.安装Rebar3"></a>1.安装Rebar3</h4><p>关于Rebar的安装，之前的博文里面就有提到，请自行阅读，或者查看官网文档：<a href="http://www.rebar3.org/">http://www.rebar3.org/</a></p><h4 id="2-安装Rebar3插件"><a href="#2-安装Rebar3插件" class="headerlink" title="2.安装Rebar3插件"></a>2.安装Rebar3插件</h4><p>开发者需要自定义插件时，可以查看该插件的代码和结构，以更快地开发一个标准的 <em>EMQ X</em> 插件。插件实际是一个普通的 <code>Erlang Application</code>，详情看这里：<a href="https://docs.emqx.io/broker/v3/cn/plugins.html#emq-x-r3-2，">https://docs.emqx.io/broker/v3/cn/plugins.html#emq-x-r3-2，</a> EMQX官方为我们提供了一个模板，可以通过rebar3的命令行才实现快速构建一个插件。</p><p>接下来我们安装插件，注意，在Linux或者Macos下可以用此教程，Windows下稍有不同：</p><pre><code class="hljs awk">mkdir -p ~<span class="hljs-regexp">/.config/</span>rebar3/templatesgit clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/emqx/</span>rebar3_emqx_plugin ~<span class="hljs-regexp">/.config/</span>rebar3/templates</code></pre><h4 id="3-新建插件"><a href="#3-新建插件" class="headerlink" title="3. 新建插件"></a>3. 新建插件</h4><pre><code class="hljs haxe">rebar3 <span class="hljs-keyword">new</span> <span class="hljs-type">emqx</span>-plugin &lt;plugin-name&gt;</code></pre><p>​    <img src="/uploads/image-20191025094233619.png" alt="image-20191025094233619"></p><h4 id="4-注册插件"><a href="#4-注册插件" class="headerlink" title="4. 注册插件"></a>4. 注册插件</h4><ol><li>clone emqx-rel 项目：</li></ol><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/emqx/</span>emqx-rel.git</code></pre><ol start="2"><li>rebar.config 添加依赖：</li></ol><pre><code class="hljs clojure">&#123;deps,   [    &#123;plugin_name【刚才我们新建的是Mysql】, &#123;git, <span class="hljs-string">&quot;你的插件的git地址&quot;</span>, &#123;tag, <span class="hljs-string">&quot;一般为git发布的版本号&quot;</span>&#125;&#125;&#125;,   ....   ]&#125;</code></pre><blockquote><p>这里有个地方注意一下：如果你用的GitHub，请首先发布一个release版本，否则rebar3会提示找不到tag。</p></blockquote><ol start="3"><li>rebar.config 中 relx 段落添加：</li></ol><pre><code class="hljs clojure">&#123;relx,    [...    , ...    , &#123;release, &#123;emqx, git_describe&#125;,       [         &#123;plugin_name【刚才我们新建的是Mysql】, load&#125;,       ]      &#125;    ]&#125;</code></pre><p>最后，附上我做的一个DemoPlugin的地址，大家可以自己查看：<a href="https://github.com/wwhai/first_plugin.git">https://github.com/wwhai/first_plugin.git</a></p><h4 id="5-编译emqx"><a href="#5-编译emqx" class="headerlink" title="5. 编译emqx"></a>5. 编译emqx</h4><pre><code class="hljs shell">cd emqx-rel &amp;&amp; makecd _build/emqx/rel/emqx ./bin/emqx console</code></pre><p>上面讲的是最简单的插件配置和生成，在后续过程中，会继续更新插件开发教程，敬请关注！</p>]]></content>
    
    
    <categories>
      
      <category>EMQX高级开发教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Erlang</tag>
      
      <tag>EMQX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ErlangCowboy基础教程</title>
    <link href="/2019/10/22/clpqt1iug002z4cue9lykbcie.html"/>
    <url>/2019/10/22/clpqt1iug002z4cue9lykbcie.html</url>
    
    <content type="html"><![CDATA[<p>本文作者：[wangwenhai] # 概要：本文主要讲解Erlang的Web框架Cowboy的基础使用</p><span id="more"></span><h2 id="1-Cowboy简介"><a href="#1-Cowboy简介" class="headerlink" title="1.Cowboy简介"></a>1.Cowboy简介</h2><p>Cowboy是Erlang的一个Web 服务器框架，比较精简，适合嵌入式WEB服务器系统开发，目前Cowboy在Erlang世界用的比较多，但是中文资料确实不多。为了方便学习，本人将Cowboy官网的文档来做一个简短的解读，方便新手学习，因为本人能力有限，如有错误请联系指出。</p><blockquote><p>Cowboy关注于构建HTTP服务器，而非基于HTTP的业务系统。所以Cowboy讲的东西大部分比较底层，甚至晦涩，需要我们读者有扎实的HTTP基础。</p></blockquote><h2 id="2-Cowboy安装"><a href="#2-Cowboy安装" class="headerlink" title="2.Cowboy安装"></a>2.Cowboy安装</h2><h3 id="2-1-Makefile形式"><a href="#2-1-Makefile形式" class="headerlink" title="2.1 Makefile形式"></a>2.1 Makefile形式</h3><ol><li>首先，新一个目录,用来存放我们的应用:</li></ol><pre><code class="hljs erlang">mkdir hello_erlangcd hello_erlangwget https://erlang.mk/erlang.mkmake -f erlang.mk bootstrap bootstrap-relmake run...(hello_erlang@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>)<span class="hljs-number">1</span>&gt;</code></pre><p>输入<code>i()</code>命令可查看正在运行的进程数据。以上步骤没有做任何事，仅仅是启动了一个节点。</p><ol start="2"><li><p>接下来配置Cowboy,打开Makefile:</p><pre><code class="hljs shell">PROJECT = hello_erlangDEPS = cowboydep_cowboy_commit = 2.7.0DEP_PLUGINS = cowboyinclude erlang.mk</code></pre></li><li><p>执行make run,Cowboy就会被编译进你的项目里面。</p></li></ol><h3 id="2-2-Rebar构建。"><a href="#2-2-Rebar构建。" class="headerlink" title="2.2 Rebar构建。"></a>2.2 Rebar构建。</h3><p>Rebar是Erlang的构建工具，类似于Maven和NPM，目前最新版是Rebar3，本教程就按照Rebar3的形式进行演示。</p><ol><li><p>新建项目 </p><pre><code class="hljs shell">mkdir democd demorebar3 new release demo</code></pre><p>此时Rebar3会帮我们自动化创建项目结构</p><pre><code class="hljs awk">===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo_app.erl===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo_sup.erl===&gt; Writing demo<span class="hljs-regexp">/apps/</span>demo<span class="hljs-regexp">/src/</span>demo.app.src===&gt; Writing demo/rebar.config===&gt; Writing demo<span class="hljs-regexp">/config/</span>sys.config===&gt; Writing demo<span class="hljs-regexp">/config/</span>vm.args===&gt; Writing demo/.gitignore===&gt; Writing demo/LICENSE===&gt; Writing demo/README.md</code></pre></li><li><p>加入Cowboy依赖<br>我们打开rebar.config,加入Cowboy的依赖<code>&#123;cowboy, &quot;2.6.3&quot;, &#123;git, &quot;git://github.com/ninenines/cowboy.git&quot;, &#123;tag, &quot;2.6.3&quot;&#125;&#125;&#125;</code>,版本请自行选择。</p></li></ol><pre><code class="hljs erlang">&#123;erl_opts, [debug_info]&#125;.&#123;deps, [  &#123;cowboy, <span class="hljs-string">&quot;2.6.3&quot;</span>, &#123;git, <span class="hljs-string">&quot;git://github.com/ninenines/cowboy.git&quot;</span>, &#123;tag, <span class="hljs-string">&quot;2.6.3&quot;</span>&#125;&#125;&#125;,]&#125;.&#123;relx, [&#123;release, &#123;demo, <span class="hljs-string">&quot;0.1.0&quot;</span>&#125;,  [trap,    stdlib,    sasl]&#125;,  &#123;sys_config, <span class="hljs-string">&quot;./config/sys.config&quot;</span>&#125;,  &#123;vm_args, <span class="hljs-string">&quot;./config/vm.args&quot;</span>&#125;,  &#123;dev_mode, true&#125;,  &#123;include_erts, false&#125;,  &#123;extended_start_script, true&#125;]&#125;.&#123;profiles, [&#123;prod, [&#123;relx, [&#123;dev_mode, false&#125;,  &#123;include_erts, true&#125;]&#125;]&#125;]&#125;.</code></pre><ol start="3"><li>编译<pre><code class="hljs gauss">rebar3 <span class="hljs-keyword">compile</span></code></pre></li></ol><h2 id="3-运行测试"><a href="#3-运行测试" class="headerlink" title="3.运行测试"></a>3.运行测试</h2><p>上述流程完成以后，我们接下来测试一下Cowboy是否可以运行。找到项目下的app.erl,然后添加以下代码:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>    Dispatch = cowboy_router:compile([        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;    ]),    &#123;ok, _&#125; = cowboy:start_clear(my_http_listener,        [&#123;port, <span class="hljs-number">8080</span>&#125;],        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;    ),    demo_app_sup:start_link().</code></pre><p>这样我们就启动了一个监听器，接下来我们再新建一个handler处理器，来处理web请求：</p><p>执行命令:<code>make new t=cowboy.http n=hello_handler</code>，或者手动新建一个hello_handler.erl文件，加入代码：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>    Req = cowboy_req:reply(<span class="hljs-number">200</span>,        #&#123;&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;&#125;,        &lt;&lt;<span class="hljs-string">&quot;Hello Erlang!&quot;</span>&gt;&gt;,        Req0),    &#123;ok, Req, State&#125;.</code></pre><p>此时我们重新运行：<code>rebar3 shell</code>命令，即可进行调试，没有错误信息以后，浏览器打开<code>http://localhost:8080</code>,即可测试。</p><h2 id="4-Listeners：端口监听器"><a href="#4-Listeners：端口监听器" class="headerlink" title="4.Listeners：端口监听器"></a>4.Listeners：端口监听器</h2><p>本质上来说，端口监听器其实还是一个Socket处理器，负责客户端的连接处理，类似于Tomcat的Connector。<br>下面我们分别启动一个最简单的HTTP服务器和HTTPS服务器。</p><h3 id="4-1-HTTP服务器"><a href="#4-1-HTTP服务器" class="headerlink" title="4.1 HTTP服务器"></a>4.1 HTTP服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>    Dispatch = cowboy_router:compile([        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;    ]),    &#123;ok, _&#125; = cowboy:start_clear(my_http_listener,        [&#123;port, <span class="hljs-number">8080</span>&#125;],        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;    ).    <span class="hljs-comment">%% 其它代码</span></code></pre><p>上面给出的代码启动了一个最简单的HTTP服务器，监听8080端口，项目路径是根目录<code>/</code>。</p><h3 id="4-2-HTTPS服务器"><a href="#4-2-HTTPS服务器" class="headerlink" title="4.2 HTTPS服务器"></a>4.2 HTTPS服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">(_Type, _Args)</span> -&gt;</span>    Dispatch = cowboy_router:compile([        &#123;&#x27;_&#x27;, [&#123;<span class="hljs-string">&quot;/&quot;</span>, hello_handler, []&#125;]&#125;    ]),    &#123;ok, _&#125; = cowboy:start_tls(my_https_listener,        [            &#123;port, <span class="hljs-number">8443</span>&#125;,            &#123;certfile, <span class="hljs-string">&quot;/path/to/certfile&quot;</span>&#125;,            &#123;keyfile, <span class="hljs-string">&quot;/path/to/keyfile&quot;</span>&#125;        ],        #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;&#125;    ),        <span class="hljs-comment">%% 其它代码</span></code></pre><p>HTTPS服务器和HTTP不同的是，需要指定HTTPS的真证书路径：</p><pre><code class="hljs 1c">&#123;certfile, <span class="hljs-string">&quot;/path/to/certfile&quot;</span>&#125;,&#123;keyfile, <span class="hljs-string">&quot;/path/to/keyfile&quot;</span>&#125;</code></pre><blockquote><p>HTTP/1.1和HTTP/2协议共享相同的语义(可以查看HTTP RFC相关定义);只有他们的框架不同。HTTP1.1是文本协议，HTTP1.2是二进制协议。<br>Cowboy没有将HTTP/1.1和HTTP/2的配置分开。所有东西都在同一个Map上,配置选项是共享的。</p></blockquote><h3 id="4-3-代码简要分析"><a href="#4-3-代码简要分析" class="headerlink" title="4.3 代码简要分析"></a>4.3 代码简要分析</h3><p> <code>cowboy_router:compile</code>用来构建路由，cowboy:start_XXX用来启动具体的服务器。</p><h3 id="4-4-停止服务器"><a href="#4-4-停止服务器" class="headerlink" title="4.4 停止服务器"></a>4.4 停止服务器</h3><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">stop</span><span class="hljs-params">(_State)</span> -&gt;</span>    ok = cowboy:stop_listener(my_http_listener).</code></pre><h2 id="5-Routing：路由"><a href="#5-Routing：路由" class="headerlink" title="5.Routing：路由"></a>5.Routing：路由</h2><p>如果你学过JavaEE，或许还记得Java的servlet的路由定义形式：首先定义一个类继承HttpServlet，然后重写Get或者Post方法，最后注册到容器里面。其实这就是web框架通用的一种做法，将一个执行模块提取出来，注册到一个路由下面，然后交给容器去调度。下面我们看一下Cowboy的路由，你会发现其实和JavaEE，Python的Django等框架类似，比较容易理解。</p><h3 id="5-1-配置规则"><a href="#5-1-配置规则" class="headerlink" title="5.1 配置规则"></a>5.1 配置规则</h3><p>路由的一般结构定义如下：</p><pre><code class="hljs erlang">Routes = [Host1, Host2, ... HostN].</code></pre><p>分别给Host配置不同的规则:</p><pre><code class="hljs erlang">Host1 = &#123;HostMatch, PathsList&#125;.Host2 = &#123;HostMatch, Constraints, PathsList&#125;.</code></pre><p>配置路由表：</p><pre><code class="hljs erlang">PathsList = [Path1, Path2, ... PathN].</code></pre><p>路由模式匹配：</p><pre><code class="hljs erlang">Path1 = &#123;PathMatch, Handler, InitialState&#125;.Path2 = &#123;PathMatch, Constraints, Handler, InitialState&#125;.</code></pre><p>匹配规则</p><pre><code class="hljs erlang">但级路径匹配：PathMatch1 = <span class="hljs-string">&quot;/&quot;</span>.多级路径匹配：PathMatch2 = <span class="hljs-string">&quot;/path/to/resource&quot;</span>.Host匹配：HostMatch1 = <span class="hljs-string">&quot;cowboy.example.org&quot;</span>.</code></pre><p>路径参数</p><pre><code class="hljs erlang">PathMatch = <span class="hljs-string">&quot;/hats/:name/prices&quot;</span>.HostMatch = <span class="hljs-string">&quot;:subdomain.example.org&quot;</span>.</code></pre><p>其中:name是路径参数，:subdomain是域名参数。举个例子:</p><p>匹配域名<code>domain1</code>,name参数<code>name1</code>:</p><p>URL:<code>http://domain1.example.org/hats/name1/prices</code></p><p>匹配域名<code>domain2</code>,name参数<code>name2</code>:</p><p>URL:<code>http://domain2.example.org/hats/name2/prices</code></p><p>路径参数可以通过<code>cowboy_req:binding/&#123;2,3&#125;</code>来获取。其中有个特殊的匹配符号就是原子’_’,表示任意匹配。</p><p>可选路径参数</p><p><code>PathMatch = &quot;/book/[:chapter]/[:page]&quot;.</code>其中chapter，page都是可选字段。</p><h3 id="5-2-URL统配符："><a href="#5-2-URL统配符：" class="headerlink" title="5.2 URL统配符：[...]"></a>5.2 URL统配符：<code>[...]</code></h3><pre><code class="hljs erlang">PathMatch = <span class="hljs-string">&quot;/hats/[...]&quot;</span>.HostMatch = <span class="hljs-string">&quot;[...]ninenines.eu&quot;</span>.</code></pre><p><code>[...]</code>通配符可以用来获取匹配剩下的所有URL，例如URL：<code>/a/b/c/e/f........</code>，当配置了<code>/a/[...]</code>以后，匹配到的就是<code>b/c/e/f.......</code>后面的字符串。</p><h3 id="5-3-特殊符号："><a href="#5-3-特殊符号：" class="headerlink" title="5.3 特殊符号："></a>5.3 特殊符号：</h3><pre><code class="hljs ini"><span class="hljs-attr">PathMatch1</span> = <span class="hljs-string">&#x27;_&#x27;</span>.<span class="hljs-attr">HostMatch2</span> = <span class="hljs-string">&#x27;_&#x27;</span>.<span class="hljs-attr">PathMatch3</span> = <span class="hljs-string">&#x27;*&#x27;</span>.<span class="hljs-attr">HostMatch4</span> = <span class="hljs-string">&#x27;*&#x27;</span>.</code></pre><p><code>&#39;_&#39;</code>匹配所有的URL，<code>&#39;*&#39;</code>是个主机通配符，通常与OPTIONS方法一起使用，用在跨域请求场景下。</p><h2 id="6-Constraints：约束条件"><a href="#6-Constraints：约束条件" class="headerlink" title="6.Constraints：约束条件"></a>6.Constraints：约束条件</h2><p>Cowboy这么定义约束条件：匹配完成后，可以根据一组约束对结果绑定进行测试。只有在定义绑定时才测试约束。它们按照你定义的顺序运行。只有他们都成功，匹配才会成功。如果匹配失败，Cowboy将尝试列表中的下一条路由。约束使用的格式与cowboy_req中的匹配函数相同:它们作为可能有一个或多个约束的字段列表提供。虽然路由接受相同的格式，但它会跳过没有约束的字段，如果有默认值，也会忽略。</p><p>乍一看这个定义让人头大，如果你学过JavaWEB，肯定对值过滤比较熟悉，没错Cowboy的Constraints就是用来过滤合法值的。比如用户登陆的时候，判断email的合法性或者手机号码的合法性等等。SpringMVC里面叫验证器：Validator。</p><h3 id="6-1-约束条件规范"><a href="#6-1-约束条件规范" class="headerlink" title="6.1 约束条件规范"></a>6.1 约束条件规范</h3><p>约束条件以字段列表的形式提供。对于列表中的每个字段，可以应用特定的约束条件，如果字段缺失，还可以应用默认值。<br>字段可以是atom、带约束条件的的tuple <code>&#123;field, constraints&#125;</code>或带约束条件的tuple和默认值<code>&#123;field, constraints, default&#125;</code>的形式，其中field是必填的。<br>请注意，当与路由一起使用时，只有第二种形式是有意义的，因为它不使用默认值，并且field总是有值。每个字段的约束条件以原子或函数的有序列表的形式提供。内置约束条件是原子，而自定义约束条件是函数。</p><p>以下约束条件将首先验证并将字段my_value转换为整数，然后检查该整数是否为正:</p><pre><code class="hljs erlang">PositiveFun = <span class="hljs-keyword">fun</span>    (_, V) <span class="hljs-keyword">when</span> V &gt; <span class="hljs-number">0</span> -&gt;        &#123;ok, V&#125;;    (_, _) -&gt;        &#123;error, not_positive&#125;<span class="hljs-keyword">end</span>,&#123;my_value, [int, PositiveFun]&#125;.</code></pre><p>内置约束条件：</p><table><thead><tr><th>条件约束</th><th>描述</th></tr></thead><tbody><tr><td>int</td><td>将二进制值转换为整数</td></tr><tr><td>nonempty</td><td>确保二进制值不为空</td></tr></tbody></table><h3 id="6-2-自定义约束条件"><a href="#6-2-自定义约束条件" class="headerlink" title="6.2 自定义约束条件"></a>6.2 自定义约束条件</h3><p> 自定义约束是一个函数。这个函数有两个参数。第一个参数表示要执行的操作，第二个参数是值。值是什么以及必须返回什么取决于操作。  Cowboy目前定义三个操作。用于验证和转换用户输入的操作是 <code>forward</code> 操作。 </p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(forward, Value)</span> -&gt;</span>    <span class="hljs-keyword">try</span>        &#123;ok, binary_to_integer(Value)&#125;    <span class="hljs-keyword">catch</span> _:_ -&gt;        &#123;error, not_an_integer&#125;    <span class="hljs-keyword">end</span>;</code></pre><blockquote><p>即使没有约束条件，Value也依序被返回。</p></blockquote><p>  reverse 的操作则相反:它获取一个转换后的值并将其返回回用户输入的值 。其实就是类型转换。</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(reverse, Value)</span> -&gt;</span><span class="hljs-keyword">try</span>&#123;ok, integer_to_binary(Value)&#125;<span class="hljs-keyword">catch</span> _:_ -&gt;&#123;error, not_an_integer&#125;<span class="hljs-keyword">end</span>;</code></pre><p> 最后，<code>format_error</code>操作接受任何其他操作返回的错误，并返回格式化的可读的错误消息。 主要用来返回条件约束处理错误的信息。</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">int</span><span class="hljs-params">(format_error, &#123;not_an_integer, Value&#125;)</span> -&gt;</span>io_lib:format(<span class="hljs-string">&quot;The value ~p is not an integer.&quot;</span>, [Value]).</code></pre><blockquote><p> Cowboy不会捕获来自约束函数的异常。它们应该被编写成不抛出任何异常。 </p></blockquote><h2 id="7-Handlers：请求处理器"><a href="#7-Handlers：请求处理器" class="headerlink" title="7.Handlers：请求处理器"></a>7.Handlers：请求处理器</h2><p>到这部分就容易理解了，其实对应的就是SpringMVC的Controller。学习这一节之前，我们再来回顾一下JavaEE一些旧知识点。</p><p>首先我们写一个简单的JavaServlet。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">javax</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">http</span>.<span class="hljs-title">HttpServlet</span></span>&#123;       <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;       System.out.println(<span class="hljs-string">&quot;helloWorld&quot;</span>);        <span class="hljs-keyword">super</span>.doGet(req, resp);      &#125;&#125;</code></pre><p>上述代码中我们实现了<code>javax.servlet.http.HttpServlet</code>类，重写了<code>doGet</code>方法。这其实就是一个典型的HTTP处理过程。</p><p>接下来我们换到Cowboy，实现一个同样功能的处理器</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(index_handler)</span>.<span class="hljs-keyword">-author</span><span class="hljs-params">(<span class="hljs-string">&quot;wangwenhai&quot;</span>)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(cowboy_handler)</span>.<span class="hljs-comment">%% API-export([init/2, terminate/3]).</span><span class="hljs-keyword">-record</span><span class="hljs-params">(state, &#123;&#125;)</span>.<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>    Req = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;        &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;    &#125;, &lt;&lt;<span class="hljs-string">&quot;Hello World!&quot;</span>&gt;&gt;, Req0),    &#123;ok, Req, State&#125;.<span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _Req, _State)</span> -&gt;</span>  ok.</code></pre><p>认真观察一下两处代码的共同之处：</p><ol><li><p>Java和Cowboy都实现了某个模块，或者类</p></li><li><p>二者都实现了某个特定的函数</p></li></ol><p>对于Cowboy而言，则是实现了特定的行为模式（行为模式是Erlatng的语法特性，请自行学习相关知识）:<code>-behaviour(cowboy_handler).</code>,然后重写了<code>init</code>和<code>terminate</code>。返回值为：<code>&#123;ok, Reply, State&#125;</code>,Reply通过<code>cowboy_req:reply</code>构建。</p><p> 所有处理程序类型都提供可选的<code>terminate/3</code>回调。 需要注意的是，此函数只要调用，表示当前处理器已经被销毁，我们不可以在这里写自己的业务逻辑。</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">terminate</span><span class="hljs-params">(_Reason, _Req, _State)</span> -&gt;</span>    ok.</code></pre><h2 id="8-Loop-handlers：循环处理器"><a href="#8-Loop-handlers：循环处理器" class="headerlink" title="8.Loop handlers：循环处理器"></a>8.Loop handlers：循环处理器</h2><p>到目前未知，个人感觉这一节是最陌生的。貌似我在做JavaWeb的时候，压根没听过循环处理器这种说法。我们直接翻译官方的说明看看：</p><blockquote><p>循环处理程序是一种特殊类型的HTTP处理程序，用于无法立即发送响应。处理程序进入一个接收循环，等待正确的消息，然后才能发送响应。 </p><p> 循环处理程序用于这样的请求:响应可能不是立即可用的，但是您希望在响应到达时保持连接打开一段时间。这种实践最著名的例子是长轮询。循环处理程序也可以用于响应部分可用的请求，并且您需要在连接打开时传输响应主体。这种实践最著名的例子是服务器发送的事件，但是它也适用于任何需要很长时间发送的响应。虽然可以使用普通的HTTP处理程序来完成相同的工作，但是建议使用循环处理程序，因为它们经过了良好的测试，并且允许使用内置特性，比如休眠和超时。 </p></blockquote><p>哪怕是读到这里都感觉头大：我还是不理解这个循环处理器是什么用途？认证想了一下，貌似这种场景我们经常遇到，但是平时的项目开发中却很少见，我也比较新奇。大家设想一下这个场景：我们肯定有使用过一些在线处理图片或者压缩文件的网站，我们压缩比较大的文件的时候，速度会比较慢，比如压缩文件会让我们等待1分钟。这种场景表示的就是耗时操作，而Cowboy把这个叫：循环处理器。</p><p>理解了这个场景以后，其实就很容易使用它。循环处理器就是特殊的Handler而已，只不过<code>init/2</code>函数必须返回一个 <code>cowboy_loop</code> 原子，如下所示：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>    &#123;cowboy_loop, Req, State&#125;.</code></pre><p>同样我们如果要终止请求，可以使用<code>hibernate</code>:</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>    &#123;cowboy_loop, Req, State, hibernate&#125;.</code></pre><p> 初始化后，Cowboy将等待进程消息到达进程邮箱。当消息到达时，Cowboy调用info/3函数 。 下面的代码段在从另一个进程接收到应答消息时发送应答，或者在其他情况下等待另一个消息。 </p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(&#123;reply, Body&#125;, Req, State)</span> -&gt;</span>    cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;&#125;, Body, Req),    &#123;stop, Req, State&#125;;<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(_Msg, Req, State)</span> -&gt;</span>    &#123;ok, Req, State, hibernate&#125;.</code></pre><p> 请注意，这里的应答元组可以是任何消息，它只是一个示例。  此回调可以执行任何必要的操作，包括发送应答的全部或部分，并随后返回一个tuple，该tuple表示是否需要发送更多消息。  回调也可以选择什么都不做，直接跳过接收到的消息。  如果发送了应答，那么应该返回stop元组。这将指定Cowboy结束请求。  否则应该返回一个ok元组 。</p><p> 另一个非常适合循环处理程序的常见情况是以Erlang消息的形式接收流式数据。这可以通过在init/2回调中初始化一个 块(chunk)应答，然后在每次接收到消息时使用<code>cowboy_req:chunk/2</code>来实现。 </p><p> 从下面的代码片段可以看到，每次接收到事件消息时都会发送一个块(chunk)，而通过发送<code>eof</code>消息来停止循环。 </p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req, State)</span> -&gt;</span>    Req2 = cowboy_req:stream_reply(<span class="hljs-number">200</span>, Req),    &#123;cowboy_loop, Req2, State&#125;.<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(eof, Req, State)</span> -&gt;</span>    &#123;stop, Req, State&#125;;<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(&#123;event, Data&#125;, Req, State)</span> -&gt;</span>    cowboy_req:stream_body(Data, nofin, Req),    &#123;ok, Req, State&#125;;<span class="hljs-function"><span class="hljs-title">info</span><span class="hljs-params">(_Msg, Req, State)</span> -&gt;</span>    &#123;ok, Req, State&#125;.</code></pre><p> 为了节省内存，可以在接收到的消息之间休眠进程。这是通过作为循环元组回调的一部分返回原子<code>hibernate来</code>实现的。只要在最后添加一个原子，Cowboy就会相应休眠。 </p><p>下面是<code>cowboy_req:stream_reply</code>的定义。 报头名称必须以小写二进制字符串的形式给出。虽然标题名不区分大小写，但Cowboy要求将它们以小写形式给出才能正常工作。 详细请看:<a href="https://ninenines.eu/docs/en/cowboy/2.7/manual/cowboy_req.stream_reply/">https://ninenines.eu/docs/en/cowboy/2.7/manual/cowboy_req.stream_reply/</a></p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">stream_reply</span><span class="hljs-params">(Status, Req :: cowboy_req:req())</span></span><span class="hljs-function">    -&gt;</span> stream_reply(StatusCode, #&#123;&#125;, Req)stream_reply(Status, Headers, Req :: cowboy_req:req())    -&gt; ReqStatus  :: cowboy:http_status()Headers :: cowboy:http_headers()</code></pre><p>这一节讲的比较晦涩，其实我本人也是对块的概念不熟悉，其他项目的框架不会涉及到这些，因此这里只做了简单的讲解和部分概念直接翻译，后期加深框架了解以后方可更新本章。同时欢迎对本章内容熟悉的朋友提出修改建议。</p><h2 id="9-Static-files：静态资源"><a href="#9-Static-files：静态资源" class="headerlink" title="9.Static files：静态资源"></a>9.Static files：静态资源</h2><p>静态资源想必大家都比较熟悉了，常见的静态资源比如模板引擎，配置文件，JS脚本，CSS文件等等。本章主要就是讲解Cowboy如何处理静态文件。</p><p>Cowboy附带了一个随时可用的处理程序来提供静态文件。它的提供是为了方便在开发过程中为文件提供服务。对于生产中的系统，请考虑使用市场上提供的众多内容分发网络(CDN)中的一种，因为它们是提供文件的最佳解决方案。</p><p>静态处理程序可以为给定目录中的一个文件或所有文件提供服务。可以配置etag生成和mime类型。</p><p>可以使用静态处理程序从应用程序的私有目录提供一个特定的文件，当客户端请求<code>/</code>路径时返回一个<code>index.html</code>文件是一个不错的选择，相当于是一个默认页面。静态文件的路径定式应用程序私有的的相对目录。下面的案例将在访问路径<code>/</code>时从应用程序<code>my_app</code>的私有目录读取文件<code>static/index.html</code>。</p><h3 id="9-1-相对路径的形式"><a href="#9-1-相对路径的形式" class="headerlink" title="9.1 相对路径的形式:"></a>9.1 相对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;priv_file, my_app, <span class="hljs-string">&quot;static/index.html&quot;</span>&#125;&#125;</code></pre><blockquote><p>访问 / 路径的时候，返回my_qpp/static/index.html，其中my_app是我们的项目。</p></blockquote><h3 id="9-2-绝对路径的形式"><a href="#9-2-绝对路径的形式" class="headerlink" title="9.2 绝对路径的形式:"></a>9.2 绝对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;file, <span class="hljs-string">&quot;/var/www/index.html&quot;</span>&#125;&#125;</code></pre><blockquote><p>访问 / 路径的时候，返回/var/www/index.html，可以任意指定路径。</p></blockquote><p>注意：<code>priv_file</code>原子和<code>file</code>是不一样的。</p><p>以上是最简单的静态文件处理方式，因为就一个index.html文件。接下来我们继续看一下如何以一个目录作为静态资源容器。</p><h3 id="9-3-相对路径的形式"><a href="#9-3-相对路径的形式" class="headerlink" title="9.3 相对路径的形式:"></a>9.3 相对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>&#125;&#125;</code></pre><blockquote><p>访问 / 下某个文件的时候，Cowboy从<code>my_app/static/assets</code>目录中开始查找文件，如果存在就返回，其中my_app是我们的项目。</p></blockquote><h3 id="9-4-绝对路径的形式"><a href="#9-4-绝对路径的形式" class="headerlink" title="9.4 绝对路径的形式:"></a>9.4 绝对路径的形式:</h3><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;dir, <span class="hljs-string">&quot;/var/www/assets&quot;</span>&#125;&#125;</code></pre><blockquote><p>访问 / 下某个文件的时候，Cowboy从<code>/var/www/assets</code>目录中开始查找文件，如果存在就返回，其中<code>/var/www/assets</code> 是我们的磁盘的绝对路径。</p></blockquote><p>除此之外，我们还可以自定义MimeType。</p><blockquote><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准，说白了也就是文件的媒体类型。浏览器可以根据它来区分文件，然后决定什么内容用什么形式来显示。</p></blockquote><p>我们可以通过浏览器查看MimeType，按下浏览器界面下的F12：</p><p><img src="/uploads/image-20191024142943282.png" alt="image-20191024142943282"></p><p>常见的MimeType：</p><p><img src="/uploads/image-20191024141436305.png" alt="image-20191024141436305"></p><p> 默认情况下，Cowboy将通过查看扩展名尝试识别静态文件的mimetype 。 我们可以重写关联静态文件的mimetype的函数。当Cowboy缺少需要处理的mimetype时，或者当希望减少列表以加快查找速度时，它非常有用。您还可以提供一个硬编码的mimetype，它将被无条件地使用。 </p><p> Cowboy有两个内置函数。默认函数只处理构建Web应用程序时使用的常见文件类型。另一个函数是一个包含数百个mimetypes的扩展列表，可以满足我们几乎所有需求。当然，我们可以创建自己的函数。 </p><p> 要使用默认函数，我们不需要配置任何东西，因为它是默认的。如果你确实需要自定义Mimetype的话，下面的方法就可以了 。</p><blockquote><p>本段直接翻译官网文档。</p></blockquote><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,    [&#123;mimetypes, cow_mimetypes, web&#125;]&#125;&#125;</code></pre><p> 如您所见，有一个可选字段可能包含一个较少使用的选项列表，如mimetypes或etag。所有选项类型都有这个可选字段。  要使用几乎可以检测所有mimetype的函数，可以执行以下配置 ：</p><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,    [&#123;mimetypes, cow_mimetypes, all&#125;]&#125;&#125;</code></pre><p> 通过上述代码我们发现：配置需要一个模块和一个函数名，因此可以使用自己的任何函数 。</p><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,    [&#123;mimetypes, Module, Function&#125;]&#125;&#125;</code></pre><p>Function就是我们需要处理MimeType的自定义函数。</p><p> 执行mimetype检测的函数接收一个参数，该参数是磁盘上文件的路径。建议以元组形式返回mimetype，但也允许使用二进制字符串(但需要额外的处理)。如果函数找不到mimetype，则返回{&lt; “application”&gt;&gt;， &lt;&lt;”octet-stream”&gt;&gt;，[]}。  当静态处理程序找不到扩展名时，它将以application/octet-stream的形式发送文件。接收到该文件的浏览器将尝试将其直接下载到磁盘。  最后，可以对所有文件硬编码mimetype。这是特别有用的组合文件和priv_file选项，因为它避免了不必要的计算。</p><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/&quot;</span>, cowboy_static, &#123;priv_file, my_app, <span class="hljs-string">&quot;static/index.html&quot;</span>,    [&#123;mimetypes, &#123;&lt;&lt;<span class="hljs-string">&quot;text&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;html&quot;</span>&gt;&gt;, []&#125;&#125;]&#125;&#125;</code></pre><blockquote><p>本段直接翻译官网文档。</p></blockquote><p>接下来看如何生成etag。</p><blockquote><p> HTTP协议规格说明定义ETag为“被请求变量的实体值”。另一种说法是，ETag是一个可以与Web资源关联的记号（token）。典型的Web资源可以一个Web页，但也可能是JSON或XML文档。服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：ETag:”50b1c1d4f775c61:df3”客户端的查询更新格式是这样的：If-None-Match : W / “50b1c1d4f775c61:df3”如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。测试Etag主要在断点下载时比较有用。 </p></blockquote><p> 默认情况下，静态处理程序将根据大小和修改时间生成etagHTTP请求头值。但是，这个解决方案不能适用于所有的系统。例如，它在节点集群上的性能相当差，因为文件元数据在不同服务器之间会有所不同，在每个服务器上提供不同的etag。 然而，你可以改变etag的计算方法: </p><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,    [&#123;etag, Module, Function&#125;]&#125;&#125;</code></pre><p> 这个函数将接收三个参数:磁盘上文件的路径、文件大小和最后修改时间。在分布式设置中，通常使用文件路径来检索所有服务器上相同的etag值。 </p><p> 你也可以完全禁用etag处理 :</p><pre><code class="hljs erlang">&#123;<span class="hljs-string">&quot;/assets/[...]&quot;</span>, cowboy_static, &#123;priv_dir, my_app, <span class="hljs-string">&quot;static/assets&quot;</span>,    [&#123;etag, false&#125;]&#125;&#125;</code></pre><p>本章内容讲的比较底层，涉及到了HTTP协议的一些东西。可能我们在开发项目的过程中，这些东西都用不到，文件也不会放到本地服务器上，一般都是CDN来处理，但是这章仍然可以作为大家拓展知识的一个章节。</p><h2 id="10-Request-details：客户端请求"><a href="#10-Request-details：客户端请求" class="headerlink" title="10.Request details：客户端请求"></a>10.Request details：客户端请求</h2><p>这一节也是很好理解，学过Java的都知道HttpServletRequest，学PHP的都知道<code>$_POST</code>和<code>$_GET</code>。Cowboy把这部分内容封装成了Request。</p><p>Req对象是一个变量，用于获取关于请求、读取其主体或发送响应的信息。它实际上不是面向对象意义上的对象，其实是Erlang的一种数据结构，它是一个简单的映射，可以在从cowboy_req模块调用函数时直接访问或使用。</p><p>Req对象是几个不同章节的主题。在本章中，我们将学习Req对象，并了解如何检索关于请求的信息。</p><p>Req映射包含许多字段，这些字段已被文档化，可以直接访问。它们是直接映射到HTTP的字段:请求方法;使用的HTTP版本;有效的URI组件方案、主机、端口、路径和qs;请求头;连接的对等地址和端口;及TLS证书证书(如适用)。<br>请注意，version字段可用于确定连接是否使用HTTP/2。</p><p>上面是翻译过来的官网文档，其实对应的就类似于Java里面的<code>HttpServletRequest</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpServletRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServletRequest</span> </span>&#123;   <span class="hljs-comment">//省略代码</span>&#125;</code></pre><p>我们可以看到有很多获取客户端数据的方法，对应到Cocboy的Req对象，其实也是大同小异， 要访问字段，只需匹配函数头。下面的示例在方法为GET时发送一个简单的“Hello world!”响应，否则发送一个405错误。 </p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0=#&#123;method := &lt;&lt;<span class="hljs-string">&quot;GET&quot;</span>&gt;&gt;&#125;, State)</span> -&gt;</span>    Req = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;        &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;    &#125;, &lt;&lt;<span class="hljs-string">&quot;Hello world!&quot;</span>&gt;&gt;, Req0),    &#123;ok, Req, State&#125;;<span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(Req0, State)</span> -&gt;</span>    Req = cowboy_req:reply(<span class="hljs-number">405</span>, #&#123;        &lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;GET&quot;</span>&gt;&gt;    &#125;, Req0),    &#123;ok, Req, State&#125;.</code></pre><p>任何其他字段都是内部的，不应该被访问。它们可能会在未来的版本(包括维护版本)中发生变化，而不另行通知。<br>虽然允许修改Req对象，但除非绝对必要，否则不建议修改。如果添加了新字段，请确保对字段名称命名空间，这样就不会与未来的Cowboy更新或第三方项目发生冲突。对比Java，可以理解为私有的数据不能被随便修改，是只读属性。</p><h3 id="10-1-cowboy-req接口简介"><a href="#10-1-cowboy-req接口简介" class="headerlink" title="10.1 cowboy_req接口简介"></a>10.1 cowboy_req接口简介</h3><p>cowboy_req模块中的函数提供对请求信息的访问，以及处理HTTP请求时常见的各种操作。以动词开头的所有函数都表示动作。其他函数只是返回相应的值(有时确实需要构建该值，但是操作的成本相当于检索一个值)。 一些cowboy_req函数返回一个更新的Req对象。它们是read、reply、set和delete函数。虽然忽略返回的Req不会导致某些错误的行为，但是强烈建议始终保留并使用最后一个返回的Req对象。cowboy_req的手册详细介绍了这些函数以及对Req对象所做的修改。对cowboy_req的一些调用有副作用。这是read和reply函数的情况。Cowboy读取请求体，或者在调用函数时立即响应。如果出了问题，所有的函数都会崩溃。通常不需要捕获这些错误，Cowboy将根据崩溃发生的位置发送适当的4xx或5xx响应。</p><blockquote><p>本段直接翻译文档</p></blockquote><h3 id="10-2-获取请求方法"><a href="#10-2-获取请求方法" class="headerlink" title="10.2 获取请求方法"></a>10.2 获取请求方法</h3><p>通过记录获取：</p><pre><code class="hljs erlang">#&#123;method := Method&#125; = Req.</code></pre><p>或者直接获取：</p><pre><code class="hljs erlang">Method = cowboy_req:method(Req).</code></pre><p> 该方法是区分大小写的二进制字符串。标准方法包括GET、HEAD、OPTIONS、PATCH、POST、PUT或DELETE。 </p><h3 id="10-3-HTTP版本"><a href="#10-3-HTTP版本" class="headerlink" title="10.3 HTTP版本"></a>10.3 HTTP版本</h3><p>HTTP版本是信息性（ informational ：这个单词我不知道怎么翻译好，个人理解是：版本是个规范，有没有实现就是客户端的问题了）的。它并不表示客户机很好地或完全地实现了协议。通常不需要根据HTTP版本改变行为:Cowboy已经为您做了。不过，它在某些情况下可能有用。例如，您可能希望重定向HTTP/1.1客户端以使用Websocket，而HTTP/2客户端继续使用HTTP/2。<br>HTTP版本可以直接获取:</p><pre><code class="hljs erlang">#&#123;version := Version&#125; = Req.</code></pre><p>或者通过函数获取：</p><pre><code class="hljs erlang">Version = cowboy_req:version(Req).</code></pre><p> Cowboy定义了“HTTP/1.0”、“HTTP/1.1”和“HTTP/2”版本。自定义协议可以将自己的值定义为原子。 </p><h3 id="10-4-有效的请求URI"><a href="#10-4-有效的请求URI" class="headerlink" title="10.4  有效的请求URI"></a>10.4  有效的请求URI</h3><p> 有效请求URI的请求方法、主机、端口、路径和查询字符串组件都可以直接获取：</p><pre><code class="hljs erlang">#&#123;    scheme := Scheme,    host := Host,    port := Port,    path := Path,    qs := Qs&#125; = Req.</code></pre><p>或者使用函数获取：</p><pre><code class="hljs erlang">Scheme = cowboy_req:scheme(Req),Host = cowboy_req:host(Req),Port = cowboy_req:port(Req),Path = cowboy_req:path(Req).Qs = cowboy_req:qs(Req).</code></pre><p>HTTP请求方法和主机是大小写不敏感的二进制字符串。端口是表示端口号的整数。路径和查询字符串是区分大小写的二进制字符串。Cowboy只定义了&lt;&lt;”http”&gt;&gt;和&lt;&lt;”https”&gt;&gt;方案。它们被选中，因此对于安全HTTP/1.1或HTTP/2连接上的请求，该方案将仅为&lt;&lt;”https”&gt;&gt;。</p><p>有效的请求URI本身可以使用cowboy_req: URI /1,2函数进行重构。默认情况下，返回一个绝对URI:</p><pre><code class="hljs erlang"><span class="hljs-comment">%% scheme://host[:port]/path[?qs]</span>URI = cowboy_req:uri(Req).</code></pre><p> 可以使用选项禁用或替换部分或全部组件。可以通过这种方式生成各种URI或URI格式，包括原始表单: </p><pre><code class="hljs erlang"><span class="hljs-comment">%% /path[?qs]</span>URI = cowboy_req:uri(Req, #&#123;host =&gt; undefined&#125;).</code></pre><p>协议相关的：</p><pre><code class="hljs erlang"><span class="hljs-comment">%% //host[:port]/path[?qs]</span>URI = cowboy_req:uri(Req, #&#123;scheme =&gt; undefined&#125;).</code></pre><p>查询字符串</p><pre><code class="hljs erlang">URI = cowboy_req:uri(Req, #&#123;qs =&gt; undefined&#125;).</code></pre><p>Host:</p><pre><code class="hljs erlang">URI = cowboy_req:uri(Req, #&#123;host =&gt; &lt;&lt;<span class="hljs-string">&quot;example.org&quot;</span>&gt;&gt;&#125;).</code></pre><h3 id="10-5-绑定"><a href="#10-5-绑定" class="headerlink" title="10.5 绑定"></a>10.5 绑定</h3><p>绑定是在定义应用程序路由时选择提取的主机和路径组件。它们只在路由之后可用。<br>Cowboy提供一些函数去获取绑定的值。</p><p>获取单个值：</p><pre><code class="hljs erlang">Value = cowboy_req:binding(userid, Req).</code></pre><p>默认值的情况：</p><pre><code class="hljs erlang">Value = cowboy_req:binding(userid, Req, <span class="hljs-number">42</span>).</code></pre><p>获取所有绑定的值：</p><pre><code class="hljs erlang">Bindings = cowboy_req:bindings(Req).</code></pre><p>它们作为映射返回，键是原子。Cowboy路由器还允许您使用<code>...</code>定符：</p><p>获取Host：</p><pre><code class="hljs erlang">HostInfo = cowboy_req:host_info(Req).</code></pre><p>获取路径：</p><pre><code class="hljs erlang">PathInfo = cowboy_req:path_info(Req).</code></pre><p> Cowboy将返回未定义如果<code>...</code>这条路线没有使用。 </p><h3 id="10-6-查询参数"><a href="#10-6-查询参数" class="headerlink" title="10.6 查询参数"></a>10.6 查询参数</h3><p> Cowboy提供了两个函数来访问查询参数。您可以使用第一个参数来获得整个参数列表。 </p><pre><code class="hljs erlang">QsVals = cowboy_req:parse_qs(Req),&#123;_, Lang&#125; = lists:keyfind(&lt;&lt;<span class="hljs-string">&quot;lang&quot;</span>&gt;&gt;, <span class="hljs-number">1</span>, QsVals).</code></pre><p> Cowboy只解析查询字符串，不进行任何转换。因此，这个函数可能返回重复的值，或者没有关联值的参数名。返回列表的顺序未定义。 当查询字符串key=1&amp;key=2时，返回的列表将包含name key的两个参数。  当尝试使用php风格的后缀[]时也是如此。当查询字符串key[]=1&amp;key[]=2时，返回的列表将包含name key[]的两个参数。  当查询字符串是简单的键时，Cowboy将返回列表[{&lt;&lt;”key”&gt;&gt;， true}]，使用true表示参数键已定义，但没有值。  Cowboy提供的第二个函数允许您仅匹配感兴趣的参数，同时使用约束进行任何需要的后处理。这个函数返回一个映射。 </p><pre><code class="hljs erlang">#&#123;id := ID, lang := Lang&#125; = cowboy_req:match_qs([id, lang], Req).</code></pre><p> 约束可以自动应用。当id参数不是整数或lang参数为空时，以下代码段将崩溃。同时，id的值将被转换为整数项: </p><pre><code class="hljs erlang">QsMap = cowboy_req:match_qs([&#123;id, int&#125;, &#123;lang, nonempty&#125;], Req).</code></pre><p> 也可以提供默认值。如果没有找到lang密钥，则使用默认值。如果找到的键值为空，则不会使用它。 </p><pre><code class="hljs erlang">#&#123;lang := Lang&#125; = cowboy_req:match_qs([&#123;lang, [], &lt;&lt;<span class="hljs-string">&quot;en-US&quot;</span>&gt;&gt;&#125;], Req).</code></pre><p> 如果没有提供默认值，并且缺少该值，则查询字符串将被视为无效，进程将崩溃。当查询字符串key=1&amp;key=2时，key的值将是列表[1,2]。参数名不需要包含php风格的后缀。可以使用约束来确保只传递一个值。 </p><h3 id="10-7-HTTP请求头"><a href="#10-7-HTTP请求头" class="headerlink" title="10.7 HTTP请求头"></a>10.7 HTTP请求头</h3><p> 头值可以作为二进制字符串，也可以解析为更有意义的表示。 </p><p>获取原始值：</p><pre><code class="hljs erlang">HeaderVal = cowboy_req:header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req).</code></pre><p>Cowboy期望所有头名都以小写二进制字符串的形式提供。无论底层协议是什么，请求和响应都是如此。<br>当请求缺少header时，将返回undefined。可以提供一个不同的默认值:</p><pre><code class="hljs erlang">HeaderVal = cowboy_req:header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req, &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;).</code></pre><p> 所有的标题可以直接一次获取：</p><pre><code class="hljs erlang">#&#123;headers := AllHeaders&#125; = Req.</code></pre><p>通过函数获取：</p><pre><code class="hljs erlang">AllHeaders = cowboy_req:headers(Req).</code></pre><p> Cowboy提供了解析各个header的等效函数。没有一次解析所有标题的函数。 </p><pre><code class="hljs erlang">ParsedVal = cowboy_req:parse_header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req).</code></pre><p>如果不知道如何解析给定的HTTP请求头，或者该值无效，则会引发异常。已知HTTP请求头和默认值的列表可以在手册中找到。当头文件丢失时，将返回undefined。您可以更改默认值。注意，它应该是直接解析的值:</p><pre><code class="hljs erlang">ParsedVal = cowboy_req:parse_header(&lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt;, Req,    &#123;&lt;&lt;<span class="hljs-string">&quot;text&quot;</span>&gt;&gt;, &lt;&lt;<span class="hljs-string">&quot;plain&quot;</span>&gt;&gt;, []&#125;).</code></pre><h3 id="10-8-Peer"><a href="#10-8-Peer" class="headerlink" title="10.8 Peer"></a>10.8 Peer</h3><blockquote><p>这个单词我不知道怎么翻译，大家可以这么理解：服务器偷偷喵一眼客户端的基本信息。不过在网络里面有个peer的概念，表示的是点对点连接的两个端点，或许这里也是这个意思：获取连接客户端的基本信息</p></blockquote><p> 可以直接使用函数获取连接的对等地址和端口号：</p><pre><code class="hljs erlang">#&#123;peer := &#123;IP, Port&#125;&#125; = Req.</code></pre><p>或者使用函数：</p><pre><code class="hljs erlang">&#123;IP, Port&#125; = cowboy_req:peer(Req).</code></pre><p> 请注意，对应到服务器的连接的远程端，服务器可能是客户机本身，也可能不是客户机本身。它也可以是代理或网关。 </p><h2 id="11-Reading-the-request-body：请求体获取"><a href="#11-Reading-the-request-body：请求体获取" class="headerlink" title="11.Reading the request body：请求体获取"></a>11.Reading the request body：请求体获取</h2><p>可以使用Req对象读取body。Cowboy在请求之前不会试图读取body。您需要调用body读取函数来检索它。</p><p>Cowboy不会缓存body，因此只能读取一次。但是，你不需要读取body。如果存在未读的正文，Cowboy将根据协议取消或跳过其下载。Cowboy提供读取原始body、读取和解析urlenencoded或多部分body的函数。</p><h3 id="11-1-判断请求体是否存在"><a href="#11-1-判断请求体是否存在" class="headerlink" title="11.1  判断请求体是否存在"></a>11.1  判断请求体是否存在</h3><p>如果有一个请求体，它返回true;否则错误。实际上，很少使用这个函数。当方法是POST、PUT或PATCH时，应用程序通常需要请求体，应用程序应该尝试直接读取它。</p><pre><code class="hljs erlang">cowboy_req:has_body(Req).</code></pre><h3 id="11-2-请求体的长度"><a href="#11-2-请求体的长度" class="headerlink" title="11.2 请求体的长度"></a>11.2 请求体的长度</h3><pre><code class="hljs erlang">Length = cowboy_req:body_length(Req).</code></pre><p>注意，长度可能不会提前知道。在这种情况下，undefined将被返回。这种情况可能发生在HTTP/1.1的分块传输编码中，或者在没有提供内容长度时发生在HTTP/2中。当读取完Req对象的主体后，Cowboy将更新该对象的主体长度。在完整读取主体后尝试调用此函数时，将始终返回一个长度。</p><h3 id="11-3-读取Body"><a href="#11-3-读取Body" class="headerlink" title="11.3 读取Body"></a>11.3 读取Body</h3><pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0).</code></pre><p>当body被完全读取时，Cowboy返回一个ok元组。默认情况下，Cowboy将尝试读取最多8MB的数据，最多持续15秒。一旦Cowboy读取了至少8MB的数据，或者在15秒周期结束时，调用将返回。</p><p> 这些值可以定制。例如，读取最多1MB，最多5秒: </p><pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0,    #&#123;length =&gt; <span class="hljs-number">1000000</span>, period =&gt; <span class="hljs-number">5000</span>&#125;).</code></pre><p> 你也可以禁用长度限制: </p><pre><code class="hljs erlang">&#123;ok, Data, Req&#125; = cowboy_req:read_body(Req0, #&#123;length =&gt; infinity&#125;).</code></pre><p>这将使函数等待15秒并返回在此期间到达的所有内容。对于面向公众的应用程序，不建议这样做。这两个选项可以有效地用于控制请求体的传输速率。</p><h3 id="11-4-流式处理Body"><a href="#11-4-流式处理Body" class="headerlink" title="11.4  流式处理Body"></a>11.4  流式处理Body</h3><p> 当Body太大时，第一个调用将返回更多的tuple而不是ok。可以再次调用该函数来读取更多的主体内容，一次读取一个块。 </p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">read_body_to_console</span><span class="hljs-params">(Req0)</span> -&gt;</span>    <span class="hljs-keyword">case</span> cowboy_req:read_body(Req0) <span class="hljs-keyword">of</span>        &#123;ok, Data, Req&#125; -&gt;            io:format(<span class="hljs-string">&quot;~s&quot;</span>, [Data]),            Req;        &#123;more, Data, Req&#125; -&gt;            io:format(<span class="hljs-string">&quot;~s&quot;</span>, [Data]),            read_body_to_console(Req)    <span class="hljs-keyword">end</span>.</code></pre><p><code>length</code>和<code>period</code>选项被使用了，它们必须在每次调用的时候都被传递进去。</p><h3 id="11-5-读取urlencoded-body"><a href="#11-5-读取urlencoded-body" class="headerlink" title="11.5 读取urlencoded body"></a>11.5 读取urlencoded body</h3><p> Cowboy提供了一个便捷的函数，用于读取和解析以 application /x-www-form-urlencoded 发送的正文。 </p><pre><code class="hljs erlang">&#123;ok, KeyValues, Req&#125; = cowboy_req:read_urlencoded_body(Req0).</code></pre><p>这个函数返回一个键/值列表，与函数cowboy_req:parse_qs/1完全相同。这个函数的默认值是不同的。Cowboy将读取最多64KB和最多5秒。它可以调整：</p><pre><code class="hljs erlang">&#123;ok, KeyValues, Req&#125; = cowboy_req:read_urlencoded_body(Req0,    #&#123;length =&gt; <span class="hljs-number">4096</span>, period =&gt; <span class="hljs-number">3000</span>&#125;).</code></pre><h2 id="12-Sending-a-response：请求返回"><a href="#12-Sending-a-response：请求返回" class="headerlink" title="12.Sending a response：请求返回"></a>12.Sending a response：请求返回</h2><p>请求返回也是很容易理解，每个WEB框架都有这个概念，我们还是继续拿Java的来讲，其实对应的就是HttpServletReponse：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericServlet</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-comment">//servletResponse.xxx</span>    &#125;&#125;</code></pre><p>其他理论性的说明就不翻译了，我们直接看使用方法即可。</p><h3 id="1-一般返回值"><a href="#1-一般返回值" class="headerlink" title="1. 一般返回值"></a>1. 一般返回值</h3><p>设置HTTP状态码：</p><pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, Request).</code></pre><p>设置HTTP返回头：</p><pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">303</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;location&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;https://ninenines.eu&quot;</span>&gt;&gt;&#125;, Request).</code></pre><p>设置返回内容：</p><pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/plain&quot;</span>&gt;&gt;&#125;, <span class="hljs-string">&quot;Hello world!&quot;</span>, Request).</code></pre><blockquote><p> 响应体和标头值必须是二进制或iolist 。</p></blockquote><p>构建多类型返回：</p><pre><code class="hljs erlang">Title = <span class="hljs-string">&quot;Hello world!&quot;</span>,Body = &lt;&lt;<span class="hljs-string">&quot;Hats off!&quot;</span>&gt;&gt;,Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;&#125;, [<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;</span>, Title, <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;&quot;</span>,    <span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;&quot;</span>, Body, <span class="hljs-string">&quot;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>], Request).</code></pre><p> 这种构建响应的方法比拼接字符串更有效。在后台，列表中的每个元素都只是一个指针，可以直接写入Socket。</p><h3 id="2-字节流返回"><a href="#2-字节流返回" class="headerlink" title="2.字节流返回"></a>2.字节流返回</h3><p>Cowboy提供了两个用于初始化响应的函数，以及一个用于流化（数据转字节流）附加函数。Cowboy将向响应添加任何必需的头信息。当你只需要设置状态代码时，使用cowboy_req:stream_reply/2。</p><pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, Requset),cowboy_req:stream_body(<span class="hljs-string">&quot;Hello...&quot;</span>, nofin, Req),cowboy_req:stream_body(<span class="hljs-string">&quot;chunked...&quot;</span>, nofin, Req),cowboy_req:stream_body(<span class="hljs-string">&quot;world!!&quot;</span>, fin, Req).</code></pre><p>cowboy_req的第二个参数:stream_body/3表示该数据是否终止该body。使用fin作为最后的标志，否则使用nofin。<br>此代码段没有设置内容类型标头。不建议这样做。具有正文的所有响应都应该具有内容类型。头可以预先设置，或使用cowboy_req:stream_reply/3:</p><pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;&#125;, Request),cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;Hello world!&lt;/head&gt;&quot;</span>, nofin, Request),cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Hats off!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, fin, Request).</code></pre><p>HTTP提供了一些不同的方法来流化响应主体。Cowboy将根据HTTP版本和请求和响应头选择最合适的一个。<br>虽然无论如何都不是必需的，但如果事先知道，建议在响应中设置content-length头。这将确保选择最佳响应方法，并帮助客户理解何时完全接收到响应。Cowboy还提供了发送响应片的功能。</p><pre><code class="hljs erlang">Response = cowboy_req:stream_reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;,    &lt;&lt;<span class="hljs-string">&quot;trailer&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;expires, content-md5&quot;</span>&gt;&gt;&#125;, Request),cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;Hello world!&lt;/head&gt;&quot;</span>, nofin, Req),cowboy_req:stream_body(<span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Hats off!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>, nofin, Req),cowboy_req:stream_trailers(#&#123;    &lt;&lt;<span class="hljs-string">&quot;expires&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;Sun, 10 Dec 2017 19:13:47 GMT&quot;</span>&gt;&gt;,    &lt;&lt;<span class="hljs-string">&quot;content-md5&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;c6081d20ff41a42ce17048ed1c0345e2&quot;</span>&gt;&gt;&#125;, Response).</code></pre><blockquote><p>其实就是用底层的方实构建HTTP的请求返回值。</p></blockquote><h3 id="3-预设响应标头"><a href="#3-预设响应标头" class="headerlink" title="3.  预设响应标头"></a>3.  预设响应标头</h3><p> Cowboy提供设置响应头而不立即发送它们的函数。它们存储在Req对象中，并在调用应答函数时作为响应的一部分发送。 </p><p> 设置响应标头: </p><pre><code class="hljs erlang">Req = cowboy_req:set_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, <span class="hljs-string">&quot;GET&quot;</span>, Req0).</code></pre><p> 检查响应头是否已经设置: </p><pre><code class="hljs erlang">cowboy_req:has_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, Req).</code></pre><p> 删除之前设置的响应标头: </p><pre><code class="hljs erlang">Req = cowboy_req:delete_resp_header(&lt;&lt;<span class="hljs-string">&quot;allow&quot;</span>&gt;&gt;, Req0).</code></pre><h3 id="4-覆盖标头"><a href="#4-覆盖标头" class="headerlink" title="4. 覆盖标头"></a>4. 覆盖标头</h3><p> 因为Cowboy提供了不同的方法设置响应头和身体,可能发生冲突,因此当一个标头被设置两次以后会发生什么事情是很重要的。</p><p>标头有五种不同的来源: </p><ul><li>协议规范的标头（比如HTTP版本）</li><li>其他标头（比如日期）</li><li>预设标头</li><li>返回函数给的标头</li><li>Cookie标头</li></ul><p>Cowboy不允许重写特定于协议的头文件。Set-cookie头信息总是在发送响应之前附加在头信息列表的末尾。</p><p>提供给应答函数的标头将始终覆盖预设标头和所需标头。如果在其中的两个或三个中发现一个标头，则选择应答函数中的标头，并删除其他标头。类似地，预置头将总是覆盖所需的头。</p><p>为了说明这一点，请看下面的代码片段。Cowboy默认发送值为“Cowboy”的服务器头。我们可以覆盖它:</p><pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;server&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;yaws&quot;</span>&gt;&gt;&#125;, Request).</code></pre><h3 id="5-预设返回内容"><a href="#5-预设返回内容" class="headerlink" title="5.预设返回内容"></a>5.预设返回内容</h3><p>Cowboy提供了一些函数来设置响应体，而不需要立即发送它。它存储在Req对象中，并在调用应答函数时发送。<br>       设置响应主体:</p><pre><code class="hljs erlang">Response = cowboy_req:set_resp_body(<span class="hljs-string">&quot;Hello world!&quot;</span>, Request).</code></pre><p> 查看是否已经设置了响应: </p><pre><code class="hljs erlang">cowboy_req:has_resp_body(Request).</code></pre><p>如果主体设置为非空，则返回true，否则返回false。只有当使用的应答函数是cowboy_req:reply/2或cowboy_req:reply/3时，才会发送预设的响应体。</p><h3 id="6-发送文件"><a href="#6-发送文件" class="headerlink" title="6.发送文件"></a>6.发送文件</h3><p> Cowboy提供了发送文件的快捷方式。当使用cowboy_req:reply/4时，或者在预先设置响应头时，你可以给Cowboy一个sendfile元组: </p><pre><code class="hljs erlang">&#123;sendfile, Offset, Length, Filename&#125;</code></pre><p> 根据偏移量或长度的值，可以发送整个文件，也可以只发送一部分。  即使发送整个文件也需要这个长度。Cowboy在 content-length 头中设置。 </p><pre><code class="hljs erlang">Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; <span class="hljs-string">&quot;image/png&quot;</span>&#125;, &#123;sendfile, <span class="hljs-number">0</span>, <span class="hljs-number">12345</span>, <span class="hljs-string">&quot;path/to/logo.png&quot;</span>&#125;, Request).</code></pre><h3 id="7-信息化返回值"><a href="#7-信息化返回值" class="headerlink" title="7.信息化返回值"></a>7.信息化返回值</h3><p>Cowboy可以发送信息响应。信息响应是状态码在100到199之间的响应。任何数字都可以在正确的响应之前发送。发送一个信息响应并不会改变正确响应的行为，客户端应该忽略任何他们不理解的信息响应。</p><p>下面的代码段发送了103个信息响应，其中包含一些预期在最终响应中出现的头信息。</p><pre><code class="hljs erlang">Response = cowboy_req:inform(<span class="hljs-number">103</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;link&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;&lt;/style.css&gt;; rel=preload; as=style, &lt;/script.js&gt;; rel=preload; as=script&quot;</span>&gt;&gt;&#125;, Request).</code></pre><blockquote><p>这些概念可能都难以理解，主要我们平时的日常开发都是以应用为主，而没有多接触过规范，上面讲的这个Informational responses，可以在HTTP的RFC文档中找到。</p></blockquote><h3 id="8-Push"><a href="#8-Push" class="headerlink" title="8.Push"></a>8.Push</h3><p>HTTP/2协议引入了推送与响应中发送的资源相关的资源的能力。Cowboy为此提供了两个数:cowboy_req:push/3,4。Push只适用于HTTP/2。如果协议不支持它，Cowboy将自动忽略push请求。</p><p>push函数必须在任何应答函数之前调用。否则会导致崩溃。要推送资源，您需要提供与执行请求的客户机相同的信息。这包括HTTP方法、URI和任何必要的请求头。</p><p> Cowboy默认情况下只需要您提供资源和请求头的路径。URI的其余部分取自当前请求(不包括查询字符串，设置为空)，该方法默认为GET。 </p><p> 下面的代码段推送一个在响应中链接的CSS文件 ：</p><pre><code class="hljs erlang">cowboy_req:push(<span class="hljs-string">&quot;/static/style.css&quot;</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;accept&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/css&quot;</span>&gt;&gt;&#125;, Request),Response = cowboy_req:reply(<span class="hljs-number">200</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;content-type&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/html&quot;</span>&gt;&gt;&#125;, [<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;My web page&lt;/title&gt;&quot;</span>,    <span class="hljs-string">&quot;&lt;link rel=&#x27;stylesheet&#x27; type=&#x27;text/css&#x27; href=&#x27;/static/style.css&#x27;&gt;&quot;</span>,    <span class="hljs-string">&quot;&lt;body&gt;&lt;p&gt;Welcome to Erlang!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>], Request).</code></pre><p> 要覆盖方法、方案、主机、端口或查询字符串，只需传入第四个参数。下面的代码段使用了不同的主机名: </p><pre><code class="hljs erlang">cowboy_req:push(<span class="hljs-string">&quot;/static/style.css&quot;</span>, #&#123;    &lt;&lt;<span class="hljs-string">&quot;accept&quot;</span>&gt;&gt; =&gt; &lt;&lt;<span class="hljs-string">&quot;text/css&quot;</span>&gt;&gt;&#125;, #&#123;host =&gt; &lt;&lt;<span class="hljs-string">&quot;cdn.example.org&quot;</span>&gt;&gt;&#125;, Req),</code></pre><p>推送的资源不一定是文件。只要推送请求是可缓存的、安全的，并且不包含正文，就可以推送资源。在底层，Cowboy处理推入的请求与处理普通请求相同:创建一个不同的进程，该进程最终将向客户机发送响应。</p><blockquote><p>Push是http2的一种规范，更多内容请看这里：<a href="https://segmentfault.com/a/1190000009782985">https://segmentfault.com/a/1190000009782985</a></p></blockquote><h2 id="13-Using-cookies：使用HTTPCookie"><a href="#13-Using-cookies：使用HTTPCookie" class="headerlink" title="13.Using cookies：使用HTTPCookie"></a>13.Using cookies：使用HTTPCookie</h2><h2 id="14-Multipart：文件处理"><a href="#14-Multipart：文件处理" class="headerlink" title="14.Multipart：文件处理"></a>14.Multipart：文件处理</h2><h2 id="15-REST-principles：Rest设计规范"><a href="#15-REST-principles：Rest设计规范" class="headerlink" title="15.REST principles：Rest设计规范"></a>15.REST principles：Rest设计规范</h2><h2 id="16-Handling-REST-requests：处理Rest请求"><a href="#16-Handling-REST-requests：处理Rest请求" class="headerlink" title="16.Handling REST requests：处理Rest请求"></a>16.Handling REST requests：处理Rest请求</h2><h2 id="17-REST-flowcharts：流式Rest请求处理"><a href="#17-REST-flowcharts：流式Rest请求处理" class="headerlink" title="17.REST flowcharts：流式Rest请求处理"></a>17.REST flowcharts：流式Rest请求处理</h2><h2 id="18-Designing-a-resource-handler：设计一个资源处理器"><a href="#18-Designing-a-resource-handler：设计一个资源处理器" class="headerlink" title="18.Designing a resource handler：设计一个资源处理器"></a>18.Designing a resource handler：设计一个资源处理器</h2><h2 id="19-The-Websocket-protocol：Websocket"><a href="#19-The-Websocket-protocol：Websocket" class="headerlink" title="19.The Websocket protocol：Websocket"></a>19.The Websocket protocol：Websocket</h2><h2 id="20-Websocket-handlers：Websocket处理器"><a href="#20-Websocket-handlers：Websocket处理器" class="headerlink" title="20.Websocket handlers：Websocket处理器"></a>20.Websocket handlers：Websocket处理器</h2><h2 id="21-Streams：流式处理"><a href="#21-Streams：流式处理" class="headerlink" title="21.Streams：流式处理"></a>21.Streams：流式处理</h2><h2 id="22-Middlewares：请求中间件"><a href="#22-Middlewares：请求中间件" class="headerlink" title="22.Middlewares：请求中间件"></a>22.Middlewares：请求中间件</h2><p>大家对于中间件可能有不同的理解，主要是目前很多框架对于中间件的叫法不一样。比如Python世界里，中间件就是用来拦截用户请求的，但是JavaWEB世界，中间件则泛指消息队列。而拦截请求的组件通常又叫拦截器。</p><p>对于Cowboy的中间件，大家可以按照自己的技术栈的名词进行理解即可。</p><p>为了加深大家对中间件的理解，拿Java拦截器作为案例来对比学习。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            &#125;&#125;</code></pre><p>Java同样是实现了一个类，重写<code>preHandle</code>, <code>postHandle</code>，<code>afterCompletion</code>方法。其中如果<code>preHandle</code>返回false，则终端请求，返回true则继续。</p><p>  对于Cowboy来讲，则是实现另一个行为模式: <code>cowboy_middleware</code>  。它也有类似的一套规则。</p><pre><code class="hljs erlang"><span class="hljs-keyword">-module</span><span class="hljs-params">(index_middleware)</span>.<span class="hljs-keyword">-author</span><span class="hljs-params">(<span class="hljs-string">&quot;wangwenhai&quot;</span>)</span>.<span class="hljs-keyword">-behaviour</span><span class="hljs-params">(cowboy_middleware)</span>.<span class="hljs-comment">%% API</span><span class="hljs-keyword">-export</span><span class="hljs-params">([execute/<span class="hljs-number">2</span>])</span>.<span class="hljs-function"><span class="hljs-title">execute</span><span class="hljs-params">(Request, Env)</span> -&gt;</span>      &#123;ok, Request, Env&#125;.</code></pre><p>配置中间件</p><pre><code class="hljs erlang">&#123;ok, _&#125; = cowboy:start_clear(http_listener,  [&#123;port, Port&#125;],  #&#123;env =&gt; #&#123;dispatch =&gt; Dispatch&#125;,    middlewares =&gt; [cowboy_router, index_middleware, cowboy_handler]  &#125;),</code></pre><p>其中<code>execute</code>函数的返回值决定了是否继续本次请求：</p><ul><li><code>&#123;ok, Req, Env&#125;</code>继续本次请求</li><li><code>&#123;suspend, Module, Function, Args&#125;</code>当前请求重定向到另一个MFA</li><li><code>&#123;stop, Req&#125;</code> 直接终止请求</li></ul><blockquote><p><code>&#123;suspend, Module, Function, Args&#125;</code>会丢失所有之前的参数和堆栈信息。</p></blockquote><p> 中间件环境被定义在env参数。它是一个元组列表，第一个元素是atom，第二个元素是任何Erlang项。 </p><p> 环境中保留两个值: </p><ul><li><code>listener</code> ：包含前面的监听器的名称</li><li><code>result：</code>包含进程信息</li></ul><p>其中listener始终都包含值，result可以被任何一个中间件设置。 如果设置为ok以外的任何值，Cowboy将不处理此连接上的任何后续请求。 </p><blockquote><p>Env一般可以用来设置一些环境变量。 可以通过调用cowboy:set_env/3便利函数来更新环境，在环境中添加或替换一个值。 </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>erlang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
      <tag>cowboy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rebar3的基础使用教程</title>
    <link href="/2019/10/15/clpqt1iuf002w4cuegq8g8x1c.html"/>
    <url>/2019/10/15/clpqt1iuf002w4cuegq8g8x1c.html</url>
    
    <content type="html"><![CDATA[<p>作者：wangwenhai # 概要： 本文主要讲Erlang的构建工具Rebar3的基础使用，同时演示一个完整的项目构建过程.</p><span id="more"></span><h2 id="Rebar3简介"><a href="#Rebar3简介" class="headerlink" title="Rebar3简介"></a>Rebar3简介</h2><p><img src="/uploads/image-20191015215711556.png" alt="image-20191015215711556"></p><p>​        Rebar3是Erlang的自动化构建工具，类似于NPM或者Maven，都是用来统一管理包的软件。Rebar3前身是Rebar，后来Rebar不再更新，官方推出了Rebar3。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>windows</p><p>windows下可通过源码构建，操作如下（需要git克隆源码，或者下载压缩包）：</p><p>​    </p><pre><div class="caption"><span>l</span></div><code class="hljs shell">git clone https://github.com/erlang/rebar3.gitcd rebar3./bootstrap</code></pre><p>接下来会生成build目录，切换进去，把rebar3.exe添加进你的环境变量即可。完成以后打开powershell或者CMD，输入：rebar3，就会有提示。如果没有成功，请认真检查步骤是否错误。</p></li><li><p>MacOS</p><p>MacOS下也一样，直接通过源码构建，如果想安装到本地，在rebar3所在的目录执行</p><p>​     <code>rebar3 local install</code></p><p>​    会有如下输出：</p><pre><code class="hljs routeros">===&gt; Extracting rebar3 libs <span class="hljs-keyword">to</span> ~/.cache/rebar3/lib<span class="hljs-built_in">..</span>.===&gt; Writing rebar3 <span class="hljs-builtin-name">run</span><span class="hljs-built_in"> script </span>~/.cache/rebar3/bin/rebar3<span class="hljs-built_in">..</span>.===&gt; <span class="hljs-builtin-name">Add</span> <span class="hljs-keyword">to</span> <span class="hljs-variable">$PATH</span> <span class="hljs-keyword">for</span> use: <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/.cache/rebar3/bin</code></pre></li><li><p>Linux</p><p>Linux下和MacOS下一样，请参考MacOS安装方法。</p><p>​    </p></li></ul><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>rebar3可以新建很多类型的项目，我们可以help一下：</p><p>​    </p><pre><code class="hljs shell">app (built-in): Complete OTP Application structure.cmake (built-in): Standalone Makefile for building C/C++ in c_srcescript (built-in): Complete escriptized application structurelib (built-in): Complete OTP Library application (no processes) structureplugin (built-in): Rebar3 plugin project structurerelease (built-in): OTP Release structure for executable programsumbrella (built-in): OTP structure for executable programs (alias of &#x27;release&#x27; template)</code></pre><p>可以构建app 、cmake等等类型，而我们最常用的是app和release。下面我们新建一个app：</p><p>   <code>rebar3 new app helloworld</code>,会有如下输出：</p><p>​    </p><pre><code class="hljs shell">wangwenhaideMBP:HexoBlog wangwenhai$ rebar3 new app helloworld===&gt; Writing helloworld/src/helloworld_app.erl===&gt; Writing helloworld/src/helloworld_sup.erl===&gt; Writing helloworld/src/helloworld.app.src===&gt; Writing helloworld/rebar.config===&gt; Writing helloworld/.gitignore===&gt; Writing helloworld/LICENSE===&gt; Writing helloworld/README.md</code></pre><p>到此处说明APP以ing新建成功了</p><p>调试</p><p>调试我们用shell参数：<code>rebar3 shell</code></p><pre><code class="hljs shell">wangwenhaideMBP:helloworld wangwenhai$ rebar3 shell===&gt; Verifying dependencies...===&gt; Compiling helloworldErlang/OTP 22 [erts-10.5.1] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:1] [hipe] [dtrace]Eshell V10.5.1  (abort with ^G)<span class="hljs-meta">1&gt;</span><span class="bash"> ===&gt; The rebar3 shell is a development tool; to deploy applications <span class="hljs-keyword">in</span> production, consider using releases (http://www.rebar3.org/docs/releases)</span>===&gt; Booted helloworld</code></pre><p>有下面输出说明调试成功。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>单元测试命令是:<code>rebar3 unit</code>,具体就不做演示，请查看文档。</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布命令是:<code>reba3 release</code>.如果你想自定义输出目录，可以起个别名：<code>rebar3 as prod release</code></p><h1 id="更多高级特性请看官网：http-www-rebar3-org-docs-getting-started"><a href="#更多高级特性请看官网：http-www-rebar3-org-docs-getting-started" class="headerlink" title="更多高级特性请看官网：http://www.rebar3.org/docs/getting-started"></a>更多高级特性请看官网：<a href="http://www.rebar3.org/docs/getting-started">http://www.rebar3.org/docs/getting-started</a></h1><p>本文主要讲Erlang的构建工具Rebar3的基础使用，同时演示一个完整的项目构建过程.</p><!-- more --><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>d526ee8960474288e71f6f9f8549662fef0f3240</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>erlang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
      <tag>rebar3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ErlangTCP服务器实践</title>
    <link href="/2019/10/15/clpqt1iu5001u4cueaon99k1r.html"/>
    <url>/2019/10/15/clpqt1iu5001u4cueaon99k1r.html</url>
    
    <content type="html"><![CDATA[<p>本文着重讲解ErlangTCP服务器从简单到复杂的集中构建形式，深入理解Erlang的TCP机制。</p><span id="more"></span><h2 id="Erlang-TCP基础知识"><a href="#Erlang-TCP基础知识" class="headerlink" title="Erlang TCP基础知识"></a>Erlang TCP基础知识</h2><h6 id="Erlang对TCP支持非常完善，有很多同步和异步库使用。Erlang提供了一个精巧的模块：gen-tcp，来完成基础的Socket通信操作-详情见文档：http-erlang-org-doc-man-gen-tcp-html"><a href="#Erlang对TCP支持非常完善，有很多同步和异步库使用。Erlang提供了一个精巧的模块：gen-tcp，来完成基础的Socket通信操作-详情见文档：http-erlang-org-doc-man-gen-tcp-html" class="headerlink" title="Erlang对TCP支持非常完善，有很多同步和异步库使用。Erlang提供了一个精巧的模块：gen_tcp，来完成基础的Socket通信操作.详情见文档：http://erlang.org/doc/man/gen_tcp.html"></a>Erlang对TCP支持非常完善，有很多同步和异步库使用。Erlang提供了一个精巧的模块：gen_tcp，来完成基础的Socket通信操作.详情见文档：<a href="http://erlang.org/doc/man/gen_tcp.html">http://erlang.org/doc/man/gen_tcp.html</a></h6><h2 id="ErlangTCP的模式"><a href="#ErlangTCP的模式" class="headerlink" title="ErlangTCP的模式"></a>ErlangTCP的模式</h2><p><strong>主动模式{active, true}</strong>，非阻塞方式接收消息，但在系统无法应对超大流量请求时，客户端发送的数据过快，而且超过服务器可以处理的速度，那么，系统就可能会造成消息缓冲区被塞满，出现持续繁忙的流量的极端情况，系统因请求过多而溢出，造成Erlang虚拟机内存不足而崩溃。</p><p><strong>被动模式{active, false}</strong>，阻塞方式接收消息，底层的TCP缓冲区可用于抑制请求，并拒绝客户端的消息，在接收数据的地方都会调用gen_tcp:recv，造成阻塞（单进程模式下就只能消极等待某一个具体的客户端Socket ，很危险）。需要注意的是，操作系统可能还会做一些缓存允许客户端机器继续发送少量数据，然后才将其阻塞，但这个时候Erlang还没有调用recv函数。</p><p><strong>混合型模式（半阻塞，{active, once}）</strong>，主动套接字仅针对一条消息，在控制进程发送完一个消息数据后，必须显式地调用inet:setopts(Socket, [{active, once}]) 重新激活以便接受下一个消息（在此之前，系统处于阻塞状态）。可见，混合型模式综合了主动模式和被动模式的两者优势，可实现流量控制，防止服务器被过多消息淹没。</p><p>Joe老爷子在书中建议: 混合型模式是最合适的。</p><h2 id="一个最简单的TCP服务"><a href="#一个最简单的TCP服务" class="headerlink" title="一个最简单的TCP服务"></a>一个最简单的TCP服务</h2><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">server</span><span class="hljs-params">()</span> -&gt;</span>    &#123;ok, LSock&#125; = gen_tcp:listen(<span class="hljs-number">8080</span>, [binary, &#123;packet, <span class="hljs-number">0</span>&#125;, &#123;active, false&#125;]),    &#123;ok, Sock&#125; = gen_tcp:accept(LSock),    &#123;ok, Bin&#125; = do_recv(Sock, []),    ok = gen_tcp:close(Sock),    ok = gen_tcp:close(LSock),    Bin.<span class="hljs-function"><span class="hljs-title">do_recv</span><span class="hljs-params">(Sock, Bs)</span> -&gt;</span>    <span class="hljs-keyword">case</span> gen_tcp:recv(Sock, <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>        &#123;ok, B&#125; -&gt;            do_recv(Sock, [Bs, B]);        &#123;error, closed&#125; -&gt;            &#123;ok, list_to_binary(Bs)&#125;    <span class="hljs-keyword">end</span>.</code></pre><p>代码解读：</p><pre><code class="hljs erlang">&#123;ok, LSock&#125; = gen_tcp:listen(<span class="hljs-number">8080</span>, [binary, &#123;packet, <span class="hljs-number">0</span>&#125;,  &#123;active, false&#125;]),</code></pre><p>第2行<code>gen_tcp:listen</code>函数会在本地打开一个端口进行监听，这里我们打开8080；后面的列表是具体的选项：<code>[binary, &#123;packet, 0&#125;,  &#123;active, false&#125;]</code>,binary表示是二进制类型的数据，packet表示数据包头，这里0字节，后期会详细讲。{active, false}表示是一个被动套接字。</p><pre><code class="hljs erlang">&#123;ok, Sock&#125; = gen_tcp:accept(LSock),</code></pre><p>第三行代码表示开始监听这个socket，也就是我们本地的8080端口，类似于我们开了一个tomcat一样，可以对外提供服务。</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">do_recv</span><span class="hljs-params">(Sock, Bs)</span> -&gt;</span><span class="hljs-keyword">case</span> gen_tcp:recv(Sock, <span class="hljs-number">0</span>) <span class="hljs-keyword">of</span>    &#123;ok, B&#125; -&gt;        do_recv(Sock, [Bs, B]);    &#123;error, closed&#125; -&gt;        &#123;ok, list_to_binary(Bs)&#125;<span class="hljs-keyword">end</span>.</code></pre><p>第四行是一个自定义函数，我们通过<code>gen_tcp:recv(Sock, 0)</code> 来接受Socket的数据，如果成功，则返回{ok, B},元组，其中B是数据(binary),其中12行很重要，这里涉及到了Erlang的尾递归，如果在其他语言，比如Java、C里面，无限递归会消耗栈，导致内存泄漏，但是erlang的尾递归是经过优化的，就和正常循环一样去使用即可。</p><p>13行则是出错以后的处理，直接返回一个信息即可。</p><p>上面是最基础的一个TCP服务模式，我们运行以后就可以在本地起一个服务器，接下来我们看一个最简单的客户端。</p><h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><p>客户端相对来讲比较简单：</p><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">client</span><span class="hljs-params">()</span> -&gt;</span>    &#123;ok, Sock&#125; = gen_tcp:connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>,  [binary, &#123;packet, <span class="hljs-number">0</span>&#125;]),    ok = gen_tcp:send(Sock, <span class="hljs-string">&quot;Some Data&quot;</span>),    ok = gen_tcp:close(Sock).</code></pre><p>通过 <code>gen_tcp:connect</code>连接到我们刚打开的服务端，然后发送数据，到服务端那边会直接打印出来。如果在Windows下，可以通过werl来测试:</p><p>CMD运行：``werl`,然后输入ErlangTCP客户端代码：</p><p><img src="/uploads/1571135439867.png" alt="1571135439867"></p><p>就可以直接可视化进行调试了。</p>]]></content>
    
    
    <categories>
      
      <category>erlang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
      <tag>otp</tag>
      
      <tag>tcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辅助工具使用教程</title>
    <link href="/2019/10/12/clpqt1iuj003a4cue2rl073jk.html"/>
    <url>/2019/10/12/clpqt1iuj003a4cue2rl073jk.html</url>
    
    <content type="html"><![CDATA[<p>为了方便写Hexo博客，自己手动写了个简单的模板生成器</p><h2 id="1-源码"><a href="#1-源码" class="headerlink" title="1.源码"></a>1.源码</h2><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">自己的Hexo博客辅助工具</span><span class="hljs-string">主要功能：生成重复性的模板,命令行操作如下:</span><span class="hljs-string">hexo_helper  -n [N] -t [T] -c [C]</span><span class="hljs-string">n:文章的名字</span><span class="hljs-string">t:Tag标签</span><span class="hljs-string">c:分类</span><span class="hljs-string">一个完整的命令如下所示:</span><span class="hljs-string">hexo_helper -n &quot;Java数组&quot; -c &quot;Java&quot;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, dest=<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;文章标题&quot;</span>)parser.add_argument(<span class="hljs-string">&quot;-c&quot;</span>, dest=<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;文章分类,如有多个用空格分隔,例如:&#x27;java c c++&#x27;&quot;</span>)parser.add_argument(<span class="hljs-string">&quot;-t&quot;</span>, dest=<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;文章Tag,如有多个用空格分隔,例如:&#x27;java c c++&#x27;&quot;</span>)parser.add_argument(<span class="hljs-string">&quot;-v&quot;</span>,  action=<span class="hljs-string">&#x27;version&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;HexoHelperV0.0.1@wwhai&#x27;</span>)args = parser.parse_args()<span class="hljs-comment">#</span>name = args.ntag = args.tcategories = args.c<span class="hljs-comment">#</span>date_time = datetime.now()str_date = date_time.strftime(<span class="hljs-string">&#x27;%Y%m%d%H&#x27;</span>)date = date_time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)title =  name<span class="hljs-comment"># 解析标签</span>tag_list = tag.split(<span class="hljs-string">&quot; &quot;</span>)<span class="hljs-comment"># 生成模板</span>template = <span class="hljs-string">&#x27;&#x27;&#x27;---</span><span class="hljs-string">title: $&#123;TITLE&#125;</span><span class="hljs-string">date:  $&#123;D&#125;</span><span class="hljs-string">tags: </span><span class="hljs-string">$&#123;TAGS&#125;</span><span class="hljs-string">categories: </span><span class="hljs-string">$&#123;C&#125;</span><span class="hljs-string">author: wangwenhai</span><span class="hljs-string">---</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>tag_yml = <span class="hljs-string">&quot;&quot;</span>categorie_yml = <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment"># 构成tag</span><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> tag_list:    tag_yml += <span class="hljs-string">&quot;- &quot;</span>+tag+<span class="hljs-string">&quot;\n&quot;</span>template = template.replace(<span class="hljs-string">&quot;$&#123;TITLE&#125;&quot;</span>, title).replace(<span class="hljs-string">&quot;$&#123;D&#125;&quot;</span>, date).replace(    <span class="hljs-string">&quot;$&#123;TITLE&#125;&quot;</span>, title).replace(<span class="hljs-string">&quot;$&#123;TAGS&#125;&quot;</span>, tag_yml).replace(<span class="hljs-string">&quot;$&#123;C&#125;&quot;</span>, categories)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文章模板生成中......&quot;</span>)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./&#x27;</span>+title+<span class="hljs-string">&#x27;.md&#x27;</span>,mode=<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> markdown_file:    markdown_file.writelines(template)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文章生成成功!&quot;</span>)</code></pre><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h2><p>把这个文件放进博客目录,直接在命令行输入即可,下面是个Demo </p><p><code>python .\hexo_helper.py -n &quot;Hexo辅助工具使用教程&quot; -t &quot;Python&quot; -c &quot;Python小工具&quot;</code></p><p>生成的模板如下：</p><pre><code class="hljs shell">---title: 2019_10_12_18_16_18_Java分布式编程date:  2019-10-12 18:16:18tags: - java- c++categories: - javaauthor: wangwenhai---</code></pre><h2 id="3-新的改进计划"><a href="#3-新的改进计划" class="headerlink" title="3.新的改进计划"></a>3.新的改进计划</h2><p>准备改造成一个更加智能化的工具，目前先这么用，已经满足个人写作需求.</p>]]></content>
    
    
    <categories>
      
      <category>Python小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常学习随笔</title>
    <link href="/2019/10/12/clpqt1iun003r4cue40ym3ez2.html"/>
    <url>/2019/10/12/clpqt1iun003r4cue40ym3ez2.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是视图"><a href="#1-什么是视图" class="headerlink" title="1. 什么是视图"></a>1. 什么是视图</h2><p>  视图本质是一个虚拟表，从一个表或多个表中导出来的表，作用和真实表一样，包含一系列带有行和列的数据 视图中，用户可以使用SELECT语句查询数据，也可以使用INSERT，UPDATE，DELETE修改记录，视图可以使用户操作方便，并保障数据库系统安全。</p><h2 id="2-视图的优点"><a href="#2-视图的优点" class="headerlink" title="2. 视图的优点"></a>2. 视图的优点</h2><ul><li><p>简单，和创建普通表是一样的效果</p></li><li><p>安全，用户只能查询或修改他们所能见到得到的数据</p></li><li><p>独立性，可以屏蔽真实表结构变化带来的影响，只关心当前的数据</p></li></ul><h2 id="3-视图的缺点"><a href="#3-视图的缺点" class="headerlink" title="3. 视图的缺点"></a>3. 视图的缺点</h2><ul><li>性能相对较差，容易产生复杂语句</li><li>修改不方便，不利于开发</li></ul><h2 id="4-案例展示"><a href="#4-案例展示" class="headerlink" title="4. 案例展示"></a>4. 案例展示</h2><p>当前有2张表，用户和用户追加信息：</p><p><img src="/uploads/1570850340262.png" alt="1570850340262"></p><p><img src="/uploads/1570850371435.png" alt="1570850371435"></p><p>为了合并数据，我们构建了一个视图：</p><p><img src="/uploads/1570850474982.png" alt="1570850474982"></p><h2 id="5-接口拿到的数据"><a href="#5-接口拿到的数据" class="headerlink" title="5.接口拿到的数据"></a>5.接口拿到的数据</h2><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;data&quot;</span>: &#123;    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">3</span>,    <span class="hljs-attr">&quot;beginUser&quot;</span>: <span class="hljs-number">3</span>,    <span class="hljs-attr">&quot;beginTime&quot;</span>: <span class="hljs-string">&quot;2019-09-26T01:57:35.000+0000&quot;</span>,    <span class="hljs-attr">&quot;updateUser&quot;</span>: <span class="hljs-number">3</span>,    <span class="hljs-attr">&quot;updateTime&quot;</span>: <span class="hljs-string">&quot;2019-09-26T01:57:35.000+0000&quot;</span>,    <span class="hljs-attr">&quot;username&quot;</span>: <span class="hljs-string">&quot;Runlinker002&quot;</span>,    <span class="hljs-attr">&quot;userType&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-attr">&quot;resourceId&quot;</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">&quot;email&quot;</span>: <span class="hljs-string">&quot;123@t.com&quot;</span>,    <span class="hljs-attr">&quot;userDescription&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">&quot;state&quot;</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">&quot;identityCard&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">&quot;realName&quot;</span>: <span class="hljs-string">&quot;AAA&quot;</span>,    <span class="hljs-attr">&quot;personalType&quot;</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">&quot;auditStatus&quot;</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">&quot;gender&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-attr">&quot;phone&quot;</span>: <span class="hljs-string">&quot;11111111111&quot;</span>,    <span class="hljs-attr">&quot;personalDescription&quot;</span>: <span class="hljs-literal">null</span>&#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>数据库优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ekka源码阅读</title>
    <link href="/2019/10/01/clpqt1iua002d4cue4pmt652i.html"/>
    <url>/2019/10/01/clpqt1iua002d4cue4pmt652i.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Ekka是emqx自动集群和自动愈合的一个组件。</p></blockquote><h2 id="1-节点发现与自动集群"><a href="#1-节点发现与自动集群" class="headerlink" title="1.节点发现与自动集群"></a>1.节点发现与自动集群</h2><p><strong>ekka_cluster_strategy</strong> 模块定义了一些行为。它们分别是：</p><pre><code class="hljs erlang">-type<span class="hljs-params">(options() :: list(proplists:property()))</span>.<span class="hljs-comment">%% 发现</span>-callback<span class="hljs-params">(discover(options()) -&gt; &#123;ok, list(node())&#125; | &#123;error, term()&#125;)</span>.<span class="hljs-comment">%% 锁</span>-callback<span class="hljs-params">(lock(options()) -&gt; ok | ignore | &#123;error, term()&#125;)</span>.<span class="hljs-comment">%% 解锁</span>-callback<span class="hljs-params">(unlock(options()) -&gt; ok | ignore | &#123;error, term()&#125;)</span>.<span class="hljs-comment">%% 注册</span>-callback<span class="hljs-params">(register(options()) -&gt; ok | ignore | &#123;error, term()&#125;)</span>.<span class="hljs-comment">%% 移除注册</span>-callback<span class="hljs-params">(unregister(options()) -&gt; ok | ignore | &#123;error, term()&#125;)</span>.</code></pre><p><strong>ekka_cluster</strong>模块提供一些集群的API调用和集群管理的RPC调用。它们分别是</p><pre><code class="hljs erlang"><span class="hljs-comment">%% Cluster API</span><span class="hljs-keyword">-export</span><span class="hljs-params">([</span><span class="hljs-params">join/<span class="hljs-number">1</span>,<span class="hljs-comment">%% 加入</span></span><span class="hljs-params">leave/<span class="hljs-number">0</span>, <span class="hljs-comment">%% 离开</span></span><span class="hljs-params">force_leave/<span class="hljs-number">1</span>, <span class="hljs-comment">%% 强制离开</span></span><span class="hljs-params">status/<span class="hljs-number">0</span> <span class="hljs-comment">%% 状态</span></span><span class="hljs-params">])</span>.<span class="hljs-comment">%% RPC Call for Cluster Management</span><span class="hljs-keyword">-export</span><span class="hljs-params">([</span><span class="hljs-params">prepare/<span class="hljs-number">1</span>,</span><span class="hljs-params">heal/<span class="hljs-number">1</span>,</span><span class="hljs-params">reboot/<span class="hljs-number">0</span></span><span class="hljs-params">])</span>.<span class="hljs-comment">%% @doc Join the cluster</span><span class="hljs-comment">%% 加入集群</span><span class="hljs-keyword">-spec</span><span class="hljs-params">(join(node()) -&gt; ok | ignore | &#123;error, any()&#125;)</span>.<span class="hljs-comment">%% 如果节点是当前节点，则忽略</span><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(Node)</span> <span class="hljs-title">when</span> N<span class="hljs-title">ode</span> =:= <span class="hljs-title">node</span><span class="hljs-params">()</span> -&gt;</span>    ignore;<span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(Node)</span> <span class="hljs-title">when</span> <span class="hljs-title">is_atom</span><span class="hljs-params">(Node)</span> -&gt;</span>    <span class="hljs-keyword">case</span> &#123;ekka_mnesia:is_node_in_cluster(Node), ekka_node:is_running(Node, ekka)&#125; <span class="hljs-keyword">of</span>        &#123;false, true&#125; -&gt;         <span class="hljs-comment">%% 如果节点没有在集群里而且节点正在运行， 则加入这个集群</span>            prepare(join), ok = ekka_mnesia:join_cluster(Node), reboot();        &#123;false, false&#125; -&gt;        <span class="hljs-comment">%% 如果节点没有在集群里而且节点也没有运行  返回 错误</span>            &#123;error, &#123;node_down, Node&#125;&#125;;        &#123;true, _&#125; -&gt;        <span class="hljs-comment">%% 如果节点已经在集群里运行</span>            &#123;error, &#123;already_in_cluster, Node&#125;&#125;    <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% @doc Leave from the cluster.</span><span class="hljs-comment">%% 离开集群</span><span class="hljs-keyword">-spec</span><span class="hljs-params">(leave() -&gt; ok | &#123;error, any()&#125;)</span>.<span class="hljs-function"><span class="hljs-title">leave</span><span class="hljs-params">()</span> -&gt;</span>    <span class="hljs-keyword">case</span> ekka_mnesia:running_nodes() -- [node()] <span class="hljs-keyword">of</span>        [_|_] -&gt;            <span class="hljs-comment">%% 如果该节点在运行的节点列表里  离开该集群</span>            prepare(leave), ok = ekka_mnesia:leave_cluster(), reboot();        [] -&gt;            &#123;error, node_not_in_cluster&#125;    <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% @doc Force a node leave from cluster.</span><span class="hljs-comment">%% 强制一个节点离开集群</span><span class="hljs-keyword">-spec</span><span class="hljs-params">(force_leave(node()) -&gt; ok | ignore | &#123;error, term()&#125;)</span>.<span class="hljs-comment">%% 如果是当前节点，忽略</span><span class="hljs-function"><span class="hljs-title">force_leave</span><span class="hljs-params">(Node)</span> <span class="hljs-title">when</span> N<span class="hljs-title">ode</span> =:= <span class="hljs-title">node</span><span class="hljs-params">()</span> -&gt;</span>    ignore;<span class="hljs-function"><span class="hljs-title">force_leave</span><span class="hljs-params">(Node)</span> -&gt;</span>    <span class="hljs-comment">%% 如果Node节点在集群里，接着rpcdia</span>    <span class="hljs-keyword">case</span> ekka_mnesia:is_node_in_cluster(Node)         <span class="hljs-keyword">andalso</span> rpc:call(Node, ?MODULE, prepare, [leave]) <span class="hljs-keyword">of</span>        ok -&gt;            <span class="hljs-keyword">case</span> ekka_mnesia:remove_from_cluster(Node) <span class="hljs-keyword">of</span>                ok    -&gt; rpc:call(Node, ?MODULE, reboot, []);                Error -&gt; Error            <span class="hljs-keyword">end</span>;        <span class="hljs-literal">false</span> -&gt;            &#123;error, node_not_in_cluster&#125;;        &#123;badrpc, nodedown&#125; -&gt;            ekka_membership:announce(&#123;force_leave, Node&#125;),            ekka_mnesia:remove_from_cluster(Node);        &#123;badrpc, Reason&#125; -&gt;            &#123;error, Reason&#125;    <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% @doc Cluster status.</span><span class="hljs-comment">%% 集群状态</span><span class="hljs-function"><span class="hljs-title">status</span><span class="hljs-params">()</span> -&gt;</span> ekka_mnesia:cluster_status().</code></pre><h2 id="2-ekka-autocluster-自动集群模块"><a href="#2-ekka-autocluster-自动集群模块" class="headerlink" title="2.ekka_autocluster 自动集群模块"></a>2.ekka_autocluster 自动集群模块</h2><pre><code class="hljs erlang"><span class="hljs-keyword">-spec</span><span class="hljs-params">(run(atom()) -&gt; any())</span>.<span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">(App)</span> -&gt;</span>    <span class="hljs-comment">%% 获得锁</span>    <span class="hljs-keyword">case</span> acquire_lock(App) <span class="hljs-keyword">of</span>        ok -&gt;            spawn(<span class="hljs-keyword">fun</span>() -&gt;                     <span class="hljs-comment">%% 把当前进程的组长设置为init</span>                      group_leader(whereis(init), self()),                      <span class="hljs-comment">%% 等待应用准备就绪</span>                      wait_application_ready(App, <span class="hljs-number">10</span>),                      <span class="hljs-keyword">try</span>                          <span class="hljs-comment">%% 发现且加入</span>                          discover_and_join()                      <span class="hljs-keyword">catch</span>                          _:Error:Stacktrace -&gt;                              ?LOG(error, <span class="hljs-string">&quot;Discover error: ~p~n~p&quot;</span>, [Error, Stacktrace])                      <span class="hljs-keyword">after</span>                          <span class="hljs-comment">%% 释放锁</span>                          release_lock(App)                      <span class="hljs-keyword">end</span>,                      <span class="hljs-comment">%% 可能需要再次运行</span>                      maybe_run_again(App)                  <span class="hljs-keyword">end</span>);        failed -&gt; ignore    <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% 等待节点运行应用</span><span class="hljs-function"><span class="hljs-title">wait_application_ready</span><span class="hljs-params">(_App, <span class="hljs-number">0</span>)</span> -&gt;</span>    timeout;<span class="hljs-function"><span class="hljs-title">wait_application_ready</span><span class="hljs-params">(App, Retries)</span> -&gt;</span>    <span class="hljs-keyword">case</span> ekka_node:is_running(App) <span class="hljs-keyword">of</span>        <span class="hljs-literal">true</span>  -&gt; ok;        <span class="hljs-literal">false</span> -&gt; timer:sleep(<span class="hljs-number">1000</span>),                 wait_application_ready(App, Retries - <span class="hljs-number">1</span>)    <span class="hljs-keyword">end</span>.<span class="hljs-comment">%% 可能需要在尝试一次</span><span class="hljs-function"><span class="hljs-title">maybe_run_again</span><span class="hljs-params">(App)</span> -&gt;</span>    <span class="hljs-comment">%% Check if the node joined cluster?</span>    <span class="hljs-comment">%% 检查节点是否在集群里</span>    <span class="hljs-keyword">case</span> ekka_mnesia:is_node_in_cluster() <span class="hljs-keyword">of</span>        <span class="hljs-literal">true</span>  -&gt; ok;        <span class="hljs-literal">false</span> -&gt;                 <span class="hljs-comment">%% 如果节点没有加入集群， 5秒后再次重试</span>                 timer:sleep(<span class="hljs-number">5000</span>),                 run(App)    <span class="hljs-keyword">end</span>.<span class="hljs-keyword">-spec</span><span class="hljs-params">(discover_and_join() -&gt; any())</span>.<span class="hljs-function"><span class="hljs-title">discover_and_join</span><span class="hljs-params">()</span> -&gt;</span>    with_strategy(      <span class="hljs-keyword">fun</span>(Mod, Options) -&gt;        <span class="hljs-keyword">case</span> Mod:lock(Options) <span class="hljs-keyword">of</span>            ok -&gt;                discover_and_join(Mod, Options),                log_error(<span class="hljs-string">&quot;Unlock&quot;</span>, Mod:unlock(Options));            ignore -&gt;                timer:sleep(rand:uniform(<span class="hljs-number">3000</span>)),                discover_and_join(Mod, Options);            &#123;error, Reason&#125; -&gt;                ?LOG(error, <span class="hljs-string">&quot;AutoCluster stopped for lock error: ~p&quot;</span>, [Reason])        <span class="hljs-keyword">end</span>      <span class="hljs-keyword">end</span>).<span class="hljs-keyword">-spec</span><span class="hljs-params">(acquire_lock(atom()) -&gt; ok | failed)</span>.<span class="hljs-comment">%% 获取锁</span><span class="hljs-function"><span class="hljs-title">acquire_lock</span><span class="hljs-params">(App)</span> -&gt;</span>    <span class="hljs-comment">%% 如果应用程序APP的配置参数 autocluster_lock没有被设置值，则设置为true，表示获得锁成功，否则获取锁失败</span>    <span class="hljs-keyword">case</span> application:get_env(App, autocluster_lock) <span class="hljs-keyword">of</span>        undefined -&gt;            application:set_env(App, autocluster_lock, true);        &#123;ok, _&#125; -&gt; failed    <span class="hljs-keyword">end</span>.<span class="hljs-keyword">-spec</span><span class="hljs-params">(release_lock(atom()) -&gt; ok)</span>.<span class="hljs-comment">%% 释放锁</span><span class="hljs-function"><span class="hljs-title">release_lock</span><span class="hljs-params">(App)</span> -&gt;</span>    <span class="hljs-comment">%% 清除应用程序APP的配置参数 autocluster_lock</span>    application:unset_env(App, autocluster_lock).</code></pre>]]></content>
    
    
    <categories>
      
      <category>Erlang学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时错误</title>
    <link href="/2019/10/01/clpqt1iuc002j4cue8u12geo8.html"/>
    <url>/2019/10/01/clpqt1iuc002j4cue8u12geo8.html</url>
    
    <content type="html"><![CDATA[<ol><li><h2 id="函数子句错误"><a href="#函数子句错误" class="headerlink" title="函数子句错误"></a>函数子句错误</h2><p>发生函数子句(<strong>function clause</strong>)错误的最可能原因是：函数的所有卫语句或所有的匹配模式都失败了。</p></li><li><h2 id="case-子句错误"><a href="#case-子句错误" class="headerlink" title="case 子句错误"></a>case 子句错误</h2><p>当忘记了一个特定的情况、传入的数据类型错误或者需要一个匹配一切的子句时，会发生case子句(<strong>case clause</strong>)错误。</p></li><li><h2 id="if子句错误"><a href="#if子句错误" class="headerlink" title="if子句错误"></a>if子句错误</h2><p>if子句(<strong>if clause</strong>)错误的原因和case子句类似。当Erlang找不到一个可以求值为true的分支时，会引发这个错误。</p></li><li><h2 id="不正确匹配错误"><a href="#不正确匹配错误" class="headerlink" title="不正确匹配错误"></a>不正确匹配错误</h2><p>当模式匹配失败时，就会出现不正确匹配(<strong>bad match</strong>)错误。这通常意味着你时图进行不可能的模式匹配，对一个变量进行二次绑定或者在<strong>=</strong>操作符两边放置了不相等的东西。</p></li><li><h2 id="不正确参数错误"><a href="#不正确参数错误" class="headerlink" title="不正确参数错误"></a>不正确参数错误</h2><p>不正确参数(<strong>bad argument</strong>)错误和函数子句错误类似，因为它们都和使用不正确的参数调用函数有关。</p></li><li><h2 id="未定义函数错误"><a href="#未定义函数错误" class="headerlink" title="未定义函数错误"></a>未定义函数错误</h2><p>当调用了一个不存在的函数时候，会发生未定义函数(<strong>undefined function</strong>)错误。</p></li><li><h2 id="不正确算术计算错误"><a href="#不正确算术计算错误" class="headerlink" title="不正确算术计算错误"></a>不正确算术计算错误</h2><p>当试图进行不正确的算术计算时，会发生不正确算术计算(<strong>bad arithmetic</strong>)错误，如除0或者在原子和数值之间进行算术计算。</p></li><li><h2 id="不正确函数错误"><a href="#不正确函数错误" class="headerlink" title="不正确函数错误"></a>不正确函数错误</h2><p>导致不正确函数(<strong>bad function</strong>)错误最常见的原因是把变量当成函数使用，但是变量的值并不是函数。</p></li><li><h2 id="不正确元素错误。"><a href="#不正确元素错误。" class="headerlink" title="不正确元素错误。"></a>不正确元素错误。</h2><p>不正确元素(<strong>bad rarity</strong>)错误时不正确函数错误的特殊情况。当使用高阶函数时，给它们传递的参数个数多于或者少于实际参数个数时会出现这个错误。</p></li><li><h2 id="系统限制错误"><a href="#系统限制错误" class="headerlink" title="系统限制错误"></a>系统限制错误</h2><p>出现系统限制错误的原因有很多，下面是其中的一些：</p><ul><li>进程太多</li><li>原子太长</li><li>函数参数个数太多</li><li>原子太多</li><li>连接的节点数太多</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Erlang学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ETS</title>
    <link href="/2019/10/01/clpqt1iuc002l4cue3wsr1g5y.html"/>
    <url>/2019/10/01/clpqt1iuc002l4cue3wsr1g5y.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>ETS 表可以用来高效存储海量的erlang数据，ETS提供大型的键-值查询表，</p></blockquote><h2 id="1-四种不同的类型"><a href="#1-四种不同的类型" class="headerlink" title="1.四种不同的类型"></a>1.四种不同的类型</h2><ul><li><p>集合（set)</p><p>相同的key-value元组只能出现一次。</p></li><li><p>包（bag)</p><p>每种key-value元组组合只能出现一次，但是同一个key可以出现多次。</p></li><li><p>重复包(duplicate bag)</p><p>允许重复的元组。</p></li><li><p>有序集合（ordered set)</p><p>相同的key-value元组只能出现一次，但是可以按key的顺序访问各个元组。</p></li></ul><blockquote><p>访问有序集合（ordered set)类型中的元素需要消耗表长度的对数级别的时间（oLog n),访问其余类型的元素只需要消耗常量级别的时间。</p></blockquote><h2 id="2-表权限"><a href="#2-表权限" class="headerlink" title="2.表权限"></a>2.表权限</h2><ul><li><p>public</p><p>允许任何进程访问（读写）。</p></li><li><p>private</p><p>只有拥有该表的进程才能访问。</p></li><li><p>protected</p><p>任何进程都可以读，只有拥有该表的进程才能写入。</p></li></ul><h2 id="3-其它参数"><a href="#3-其它参数" class="headerlink" title="3.其它参数"></a>3.其它参数</h2><ul><li><p>{keypos, N}</p><p>创建表的时候可以通过 {keypos, N} 指定键取自那个位置，对存储记录record非常的有用。</p></li><li><p>named_table</p><p>如果存在此选项，则以表的名称注册该表，然后在后续的操作使用该表名称而不是表的标识符。要获取指定标的标识符，可以使用 whereis/1。</p></li><li><p>{write_concurrency, boolean()}</p><p>默认为false。这种情况下，对表的写入修改的操作获得独占访问，阻塞对同一表的任何并发访问。如果设置为true，则表将优化为并发写访问。</p></li><li><p>{read_concurrency, boolean()}</p><p>默认为false。如果设置为true，则该表将优化为并发读访问。</p></li><li><p>compressed</p><p>压缩，如果存在此选项，那么将以更紧凑的格式存储表数据，以消耗更少的内存。但是，这会使表操作变慢。特别是需要查找整个对象（如match，select)这种操作，速度会慢很多，关键元素不会被压缩。</p></li></ul><h2 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4. 匹配"></a>4. 匹配</h2><p>ETS的查询方式遵循模式匹配，下面用例子说明：</p><p>表结构 :</p><pre><code class="hljs elm">#trap_client_info&#123;id , client_id  ,auth ,trans<span class="hljs-keyword">port</span> ,socket ,ip &#125;</code></pre><p>匹配:</p><pre><code class="hljs nsis"> ets:match(trap_connection_table,&#123;<span class="hljs-string">&#x27;_&#x27;</span>,&#123;trap_client_info,<span class="hljs-string">&#x27;<span class="hljs-variable">$1</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-variable">$2</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-variable">$3</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-variable">$4</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-variable">$5</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-variable">$6</span>&#x27;</span>&#125;&#125;). 结果：[[<span class="hljs-number">1</span>,&lt;&lt;<span class="hljs-string">&quot;4d45d94142276ad38364049c56d8ed43&quot;</span>&gt;&gt;,  &#123;<span class="hljs-number">127</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,  <span class="hljs-literal">true</span>,esockd_transport,<span class="hljs-comment">#Port&lt;0.48&gt;]]</span> ets:match(trap_connection_table,&#123;<span class="hljs-string">&#x27;_&#x27;</span>,&#123;trap_client_info,<span class="hljs-string">&#x27;<span class="hljs-variable">$1</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-variable">$2</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-variable">$3</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-variable">$4</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-variable">$5</span>&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>&#125;&#125;).  结果：[[<span class="hljs-number">1</span>,&lt;&lt;<span class="hljs-string">&quot;4d45d94142276ad38364049c56d8ed43&quot;</span>&gt;&gt;,  &#123;<span class="hljs-number">127</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,  <span class="hljs-literal">true</span>,esockd_transport]]</code></pre><p>通过上面的两个匹配语句，我们发现规律：</p><ul><li>如果要匹配指定的字段，我们可以用’$N’原子来实现</li><li>如果过滤字段，我们用’_’原子来实现。<br>想一下SQL的写法：<pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> trap_connection_table;</code></pre></li></ul><p>对应：</p><pre><code class="hljs dart">ets:match(trap_connection_table,&#123;<span class="hljs-string">&#x27;_&#x27;</span>,&#123;trap_client_info,<span class="hljs-string">&#x27;<span class="hljs-subst">$1</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-subst">$2</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-subst">$3</span>&#x27;</span>, <span class="hljs-string">&#x27;<span class="hljs-subst">$4</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-subst">$5</span>&#x27;</span>,<span class="hljs-string">&#x27;<span class="hljs-subst">$6</span>&#x27;</span>&#125;&#125;).</code></pre><pre><code class="hljs applescript">select <span class="hljs-built_in">id</span>,client_id <span class="hljs-keyword">from</span> trap_connection_table;</code></pre><p>对应：</p><pre><code class="hljs css">ets:<span class="hljs-built_in">match</span>(trap_connection_table,&#123;<span class="hljs-string">&#x27;_&#x27;</span>,&#123;trap_client_info,<span class="hljs-string">&#x27;$1&#x27;</span>,<span class="hljs-string">&#x27;$2&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>&#125;&#125;).</code></pre><blockquote><p>注意：$N会根据N进行排序，数字越大顺序越后。’_’表示我们忽略不要的字段。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Erlang学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下安装Erlang和SSL</title>
    <link href="/2019/10/01/clpqt1iud002p4cue8luzc97m.html"/>
    <url>/2019/10/01/clpqt1iud002p4cue8luzc97m.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>我们简单记录一下在Ubuntu上安装Erlang的过程 </p></blockquote><h2 id="1-先安装openssl"><a href="#1-先安装openssl" class="headerlink" title="1.先安装openssl"></a>1.先安装openssl</h2><p>下载openssl源码</p><pre><code class="hljs awk">$ wget http:<span class="hljs-regexp">//</span>www.openssl.org<span class="hljs-regexp">/source/</span>openssl-<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span>a.tar.gz$ tar -zxvf openssl-<span class="hljs-number">1.0</span>.<span class="hljs-number">2</span>a.tar.gz</code></pre><p>进入源码目录，注意如果不是最新下的目录，需要先执行 make clean 确保能够重新编译成功<br>为了不和系统的openssl冲突，我们安装的时候需要指定安装的路径</p><p><code>$ make clean</code></p><p><code>$ ./configure --prefix=/usr/local/opt</code></p><p>config之后，会生成Makefile，打开Makefile找到cc，在CFLAG参数列表里加上-fPIC</p><p><code>CC= cc</code></p><pre><code class="hljs apache"><span class="hljs-attribute">CFLAG</span>= -fPIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -Wa,—noexecstack -m<span class="hljs-number">64</span> -DL_ENDIAN -DTERMIO -O<span class="hljs-number">3</span> -Wall -DOPENSSL_IA<span class="hljs-number">32</span>_SSE<span class="hljs-number">2</span> -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT<span class="hljs-number">5</span> -DOPENSSL_BN_ASM_GF<span class="hljs-number">2</span>m -DSHA<span class="hljs-number">1</span>_ASM -DSHA<span class="hljs-number">256</span>_ASM -DSHA<span class="hljs-number">512</span>_ASM -DMD<span class="hljs-number">5</span>_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM</code></pre><p>编译并安装</p><p><code>$ sudo make &amp;&amp; make install</code></p><h2 id="2-安装erlang"><a href="#2-安装erlang" class="headerlink" title="2.安装erlang"></a>2.安装erlang</h2><p>官网下载最新的Erlang源码包。<a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p><p>解压，然后进入到erlang源码目录下。</p><p><code>$ make clean</code></p><p><code>$ sudo ./configure  --prefix=/your/path/erlang --with-ssl=/usr/local/opt/ssl --without-javac</code></p><p><code>$ sudo make &amp;&amp; make install</code> </p><blockquote><p>如果安装过程中报错，出现依赖缺失，先安装缺失依赖，然后在依次执行以上几个命令</p></blockquote><h2 id="3-添加环境变量"><a href="#3-添加环境变量" class="headerlink" title="3.添加环境变量"></a>3.添加环境变量</h2><pre><code class="hljs shell">export PATH=$PATH:/your/path/erlang/bin</code></pre><h2 id="4-安装rebar3"><a href="#4-安装rebar3" class="headerlink" title="4.安装rebar3"></a>4.安装rebar3</h2><p>从官网下载 rebar3  <a href="https://www.rebar3.org/">https://www.rebar3.org/</a></p><p>赋予可执行权限</p><p><code>$ sudo chmod a+x rebar3</code></p><p>复制到shell可访问的bin目录 或者添加到环境变量。我这里选择的是 复制到 bin目录</p><p><code>$ sudo mv rebar3 /usr/local/bin</code></p>]]></content>
    
    
    <categories>
      
      <category>Erlang学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式Erlang</title>
    <link href="/2019/10/01/clpqt1iue002s4cuec0m507jx.html"/>
    <url>/2019/10/01/clpqt1iue002s4cuec0m507jx.html</url>
    
    <content type="html"><![CDATA[<p>Erlang内置了相关接口允许程序跨多节点允许：多个进程可以透明地在其他节点分裂出进程，并且相互通过发送消息来通讯。分布式的各个节点都可以位于同一台物理主机上，也可以分布在不同的主机上。</p><h2 id="1-命名与通讯"><a href="#1-命名与通讯" class="headerlink" title="1.命名与通讯"></a>1.命名与通讯</h2><p>一个Erlang节点想要成为分布式Erlang系统的一部分，它必须拥有一个名字。</p><h2 id="2-节点间的连接与可见性"><a href="#2-节点间的连接与可见性" class="headerlink" title="2. 节点间的连接与可见性"></a>2. 节点间的连接与可见性</h2><p>为了能够相互通讯，Erlang的节点之间必须共享一个私密的cookie值。</p><p>如果一组节点共享相同的cookie值，它们中的任何一个节点便都能够知道其他所有节点的存在，并且可以相互交互。如果在启动节点带上 -hidden 标志，这样该节点便不会自动与任何节点连接了。使用net_kernel模块可以对此进行细粒度的控制，还能控制互联的其它方面。</p><h2 id="3-分布式应用"><a href="#3-分布式应用" class="headerlink" title="3.分布式应用"></a>3.分布式应用</h2><p>在多个Erlang节点的分布式系统中，如果正在运行的某个应用程序节点发生故障，则另外一个节点重新启动该应用程序。</p><h2 id="4-指定分布式应用"><a href="#4-指定分布式应用" class="headerlink" title="4.指定分布式应用"></a>4.指定分布式应用</h2><p>通过以下配置参数来指定分布式应用程序。</p><blockquote><p>distributed = [{Application，Timeout, NodeDesc}]</p></blockquote><blockquote><p>Application = atom()  指定应用程序</p></blockquote><blockquote><p>Timeout = integer()  指定另一个节点重新启动之前等待的毫秒数。默认0。</p></blockquote><blockquote><p>NodeDesc = [Node1 | {Node2, Node3}]  是优先级顺序的节点名称列表。</p></blockquote><p>为了使分布式程序正常工作， 可以运行的节点必须相互联系并协商启动应用程序的配置。使用一下的配置参数来完成。</p><ul><li><code>sync_nodes_mandatory = [Node]</code> - 指定必须启动的其他节点（在sync_nodes_timeout指定的超时时间内 ）。</li><li><code>sync_nodes_optional = [Node]</code> - 指定可以启动的其他节点（在sync_nodes_timeout指定的超时时间内 ）。</li><li><code>sync_nodes_timeout =integer（）| infinity</code>- 指定等待其他节点启动的毫秒数。</li></ul><p>看下面的Demo:</p><p>myapp这个应用程序运行在节点 node1@lxw,如果这个节点崩溃。myapp将在节点node2@lxw 或者 node3@lxw 重新启动。这个node1@lxwde 配置文件 node1.config如下。  </p><pre><code class="hljs erlang">[&#123;kernel,  [&#123;distributed, [&#123;myapp, <span class="hljs-number">5000</span>, [node1@lxw, &#123;node2@lxw, node3@lxw&#125;]&#125;]&#125;,   &#123;sync_nodes_mandatory, [node2@lxw, node3@lxw]&#125;,   &#123;sync_nodes_timeout, <span class="hljs-number">5000</span>&#125;  ] &#125;].</code></pre><p>对于node2@lxw和node3@lxw的配置文件，除了sync_nodes_mandatory的节点列表不同，其它都是相同的。node2@lxw的是[node1@lxw, node3@lxw], node3@lxw的是[node1@lxw, node2@lxw]。</p><p>sync_nodes_mandatory 元组要结合sync_nodes_timeout一起使用。当用这个配置启动分布式节点时，节点会一直处于锁定状态，直到所有节点都启动并被锁定，接着，它们之间会进行同步，然后在继续运行。如果启动的所有节点时间超过了 sync_nodes_timeout 配置的时间，那么它们都将崩溃。</p><h2 id="5-启动和停止分布式应用程序"><a href="#5-启动和停止分布式应用程序" class="headerlink" title="5.启动和停止分布式应用程序"></a>5.启动和停止分布式应用程序</h2><p>当所有的节点都已经启动时，通过在所有节点上调用 application:start(Application) 来启动分布式应用程序。</p><p>也可以使用启动脚本自动启动应用程序</p><pre><code class="hljs erlang">erl -sname node1 -config node1erl -sname node2 -config node2erl -sname node3 -config node3</code></pre><p>加入启动 application:start(Application) 参数</p><pre><code class="hljs erlang">erl -sname node1 -config node1 -eval <span class="hljs-string">&quot;application:start(Application)&quot;</span>erl -sname node2 -config node2 -eval <span class="hljs-string">&quot;application:start(Application)&quot;</span>erl -sname node3 -config node3 -eval <span class="hljs-string">&quot;application:start(Application)&quot;</span></code></pre><p>同样，需要在所有相关节点上调用 applicaiont:stop(Application) 来停止应用程序。</p><h2 id="6-故障转移"><a href="#6-故障转移" class="headerlink" title="6.故障转移"></a>6.故障转移</h2><p>如果正在运行应用程序的节点发生故障，则应用程序将在分布式配置参数中的节点列表中列出的第一个操作节点上重新启动（在指定的超时时间之后）。这称为 <strong>故障转移</strong>。</p><p>应用程序在新节点上以正常方式启动，调用：</p><blockquote><p>Module:start(normal, StartArgs)</p></blockquote><h2 id="7-恢复"><a href="#7-恢复" class="headerlink" title="7.恢复"></a>7.恢复</h2><p>如果启动节点，这个节点在分布式应用程序中有更高的运行优先权，这个应用程序将在新的节点启动，在老的节点停止，这个称为恢复。</p><h2 id="8-应用程序启动通过调用："><a href="#8-应用程序启动通过调用：" class="headerlink" title="8.应用程序启动通过调用："></a>8.应用程序启动通过调用：</h2><blockquote><p>Module:start({takeover, Node}, StartArgs)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Erlang学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>erlang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RULEX-网关开发框架</title>
    <link href="/1994/07/24/clpqt1its000o4cue7ro001xg.html"/>
    <url>/1994/07/24/clpqt1its000o4cue7ro001xg.html</url>
    
    <content type="html"><![CDATA[<p>RULEX 是一个轻量级工业类边缘网关开发框架</p><span id="more"></span><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>things</category>
      
    </categories>
    
    
    <tags>
      
      <tag>things</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
